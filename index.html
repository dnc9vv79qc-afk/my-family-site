<!DOCTYPE html>

<html lang="ja">

<head>

<meta charset="UTF-8">

<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

<title>é–“å–ã‚Šã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼ v5.96</title>

<style>

:root { --primary: #007AFF; --success: #34c759; --danger: #ff3b30; --warning: #FF9500; --bg: #f2f2f7; --card: #ffffff; }

body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; margin: 0; background: var(--bg); touch-action: none; display: flex; flex-direction: column; height: 100vh; overflow: hidden; }

.ver-label { position: fixed; top: 4px; right: 8px; font-size: 10px; color: #8e8e93; z-index: 100; pointer-events: none; font-weight: bold; text-align: right; }

.toolbar { padding: 12px; background: var(--card); border-bottom: 1px solid #d1d1d6; z-index: 10; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }

.grid-layout { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; margin-bottom: 8px; }

button { height: 48px; font-size: 14px; border: none; border-radius: 12px; color: white; font-weight: bold; cursor: pointer; display: flex; align-items: center; justify-content: center; width: 100%; -webkit-tap-highlight-color: transparent; }

button:active { opacity: 0.7; transform: scale(0.95); }

.btn-frame { background: #3a3a3c; }

.btn-room { background: var(--primary); }

.btn-wall { background: #616161; }

.btn-merge { background: #5856d6; }

.btn-copy { background: var(--success); }

.btn-help { background: #8e8e93; font-size: 18px; }

.btn-reset { background: #8e8e93; }

.btn-save { background: var(--warning); }

.color-circle { background: #fff; border: 2px solid #d1d1d6; border-radius: 50%; width: 40px; height: 40px; display: flex; align-items: center; justify-content: center; overflow: hidden; margin: 0 auto; }

input[type="color"] { width: 60px; height: 60px; border: none; background: none; cursor: pointer; padding: 0; }

.config-bar { background: #e5e5ea; padding: 10px; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #c6c6c8; }

.chip-group { display: flex; gap: 6px; }

.chip { background: #fff; padding: 8px 14px; border-radius: 20px; font-size: 13px; font-weight: bold; display: flex; align-items: center; gap: 6px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); cursor: pointer; }

.chip input { margin: 0; width: 18px; height: 18px; }

.summary { background: #1c1c1e; color: #fff; padding: 12px 16px; display: flex; justify-content: space-around; font-size: 14px; font-weight: bold; }

.summary b { color: var(--warning); }

#canvas-container { flex: 1; position: relative; background: #fff; overflow: hidden; touch-action: none; }

canvas { display: block; }

 

.modal-overlay { display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.6); z-index: 1000; align-items: center; justify-content: center; }

.modal { background: #fff; padding: 25px; border-radius: 20px; width: 85%; max-width: 320px; text-align: center; box-shadow: 0 10px 30px rgba(0,0,0,0.3); }

.modal input { width: 100%; padding: 12px; margin: 15px 0; border: 1px solid #ddd; border-radius: 10px; font-size: 14px; box-sizing: border-box; }

 

#helpModal .modal { max-width: 400px; text-align: left; max-height: 80vh; overflow-y: auto; }

#helpModal ul { padding-left: 20px; font-size: 13px; line-height: 1.6; }

#helpModal h3 { text-align: center; margin-top: 0; }

 

/* â˜…è¿½åŠ ï¼šä¿å­˜å®Œäº†ãƒˆãƒ¼ã‚¹ãƒˆ */

#toast {

  position: fixed;

  left: 50%;

  bottom: 22px;

  transform: translateX(-50%);

  background: rgba(28,28,30,0.92);

  color: #fff;

  padding: 10px 14px;

  border-radius: 14px;

  font-size: 13px;

  font-weight: 700;

  z-index: 2000;

  display: none;

  box-shadow: 0 10px 25px rgba(0,0,0,0.25);

  pointer-events: none;

  max-width: 90vw;

  text-align: center;

  line-height: 1.3;

}

</style>

</head>

<body>

<div class="ver-label">ver 5.96<br>by yuchiğŸ”</div>

 

<div class="toolbar">

  <div class="grid-layout">

    <button class="btn-frame" id="addFrameBtn">+ å¤–æ </button>

    <button class="btn-room" id="addGenericRoomBtn">+ éƒ¨å±‹è¿½åŠ </button>

    <button class="btn-wall" id="addWallBtn">+ å£</button>

  </div>

  <div class="grid-layout" style="grid-template-columns: 2fr 1fr 1fr;">

    <button id="mergeBtn" class="btn-merge">çµåˆãƒ¢ãƒ¼ãƒ‰</button>

    <button class="btn-copy" id="copyBtn">è¤‡è£½</button>

    <button class="btn-help" id="openHelpBtn">ï¼Ÿ</button>

  </div>

  <div class="grid-layout" style="grid-template-columns: 1fr 1fr 1fr;">

    <button class="btn-save" id="saveBtn">å…±æœ‰URL</button>

    <button class="btn-reset" id="resetBtn">æ¶ˆå»</button>

    <div class="color-circle"><input type="color" id="colorPicker" value="#ffffff"></div>

  </div>

</div>

 

<div class="config-bar">

  <div class="chip-group">

    <label class="chip"><input type="checkbox" id="showJou" checked>ç•³</label>

    <label class="chip"><input type="checkbox" id="showTsubo" checked>åª</label>

    <label class="chip" style="background:#d1d1d6;"><input type="checkbox" id="useHalfGrid">åŠã¾ã™</label>

  </div>

  <button id="centerBtn" style="width:auto; height:34px; padding:0 12px; background:var(--primary); font-size:12px;">è¡¨ç¤ºãƒªã‚»ãƒƒãƒˆ</button>

</div>

 

<div class="summary">

  <span>å»¶åºŠ: <b id="totalTsubo">0.00</b> åª</span>

  <span><b id="totalJou">0.0</b> ç•³</span>

</div>

 

<div id="canvas-container"><canvas id="canvas"></canvas></div>

 

<div id="saveModal" class="modal-overlay">

  <div class="modal">

    <h3>å…±æœ‰URLä½œæˆå®Œäº†</h3>

    <input type="text" id="shareUrlInput" readonly onclick="this.select()">

    <div style="display:flex; gap:10px;">

      <button style="flex:1; background:var(--primary);" id="copyUrlBtn">ã‚³ãƒ”ãƒ¼</button>

      <button style="flex:1; background:#8e8e93;" id="closeSaveModalBtn">é–‰ã˜ã‚‹</button>

    </div>

  </div>

</div>

 

<div id="helpModal" class="modal-overlay">

  <div class="modal">

    <h3>ğŸ  æ“ä½œãƒãƒ‹ãƒ¥ã‚¢ãƒ«</h3>

    <ul>

      <li><b>åŸºæœ¬:</b> ãƒœã‚¿ãƒ³ã§ãƒ‘ãƒ¼ãƒ„ã‚’è¿½åŠ ã—ã€ãƒ‰ãƒ©ãƒƒã‚°ã§ç§»å‹•ã€‚</li>

      <li><b>ã‚µã‚¤ã‚ºå¤‰æ›´:</b> ãƒ‘ãƒ¼ãƒ„å³ä¸‹ã®ä¸¸ã„ãƒãƒ³ãƒ‰ãƒ«ã‚’ãƒ‰ãƒ©ãƒƒã‚°ã€‚</li>

      <li><b>ç”»é¢ç§»å‹•:</b> èƒŒæ™¯éƒ¨åˆ†ã‚’ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦ã‚¹ãƒ©ã‚¤ãƒ‰ã€‚</li>

      <li><b>åå‰ç·¨é›†:</b> ãƒ‘ãƒ¼ãƒ„ã‚’ç´ æ—©ã2å›ã‚¿ãƒƒãƒ—ã€‚</li>

      <li><b>çµåˆãƒ¢ãƒ¼ãƒ‰:</b> å¤–æ ã‚’å¤ªãã—ã€åŒã˜åå‰ã®éƒ¨å±‹ã‚’åˆä½“ã€‚</li>

      <li><b>ä¿å­˜:</b> å…±æœ‰URLã‚’ç™ºè¡Œã—ã¦ç¶šãã‚’ç·¨é›†å¯èƒ½ã€‚</li>

    </ul>

    <p style="font-size:11px; color:#666; text-align:center;">ï¼ˆç”»é¢ã‚’ã‚¿ãƒƒãƒ—ã—ã¦é–‰ã˜ã‚‹ï¼‰</p>

  </div>

</div>

 

<!-- â˜…è¿½åŠ ï¼šãƒˆãƒ¼ã‚¹ãƒˆ -->

<div id="toast"></div>

 

<script type="module">

import { initializeApp } from https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js;

import {

  getFirestore, collection, addDoc, getDoc, doc,

  updateDoc, serverTimestamp

} from https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js;

 

const firebaseConfig = {

  apiKey: "AIzaSyBH4zoH5ZnfPcZmmXNvfeGOJz9__KkSMrg",

  authDomain: "test-55430.firebaseapp.com",

  projectId: "test-55430",

  storageBucket: "test-55430.firebasestorage.app",

  messagingSenderId: "742726212885",

  appId: "1:742726212885:web:597a48fc1ce0cb7f529d1c",

  measurementId: "G-PW24JY2LBP"

};

 

const app = initializeApp(firebaseConfig);

const db = getFirestore(app);

 

const canvas = document.getElementById('canvas');

const ctx = canvas.getContext('2d');

const container = document.getElementById('canvas-container');

 

const GRID_SIZE = 32;

 

let items = [];

let selectedItem = null;

let isResizing = false;

let isDragging = false;

let isMerged = false;

 

let camera = { x: 0, y: 0 };

let dragStart = null;

let lastCamera = { x: 0, y: 0 };

let startX, startY;

let lastTapTime = 0;

 

// â˜…å…±æœ‰URLã®ã€Œä¸Šæ›¸ãä¿å­˜ã€ç”¨

let currentDocId = null;

 

// â˜…è‡ªå‹•ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ï¼ˆã‚»ãƒ¼ãƒ–å¯¾è±¡æ•´ç†ï¼‰

let autosaveTimer = null;

const AUTOSAVE_NS = "madori_sim_v596";

const getAutosaveKey = (id) => `${AUTOSAVE_NS}:${id ? "doc:" + id : "draft"}`;

 

// â˜…ãƒˆãƒ¼ã‚¹ãƒˆ

let toastTimer = null;

function showToast(msg, ms = 1300) {

  const el = document.getElementById('toast');

  el.textContent = msg;

  el.style.display = 'block';

  clearTimeout(toastTimer);

  toastTimer = setTimeout(() => {

    el.style.display = 'none';

  }, ms);

}

 

// â˜…UIçŠ¶æ…‹ã‚’ä¿å­˜å¯¾è±¡ã«å«ã‚ã‚‹

function getUIState() {

  return {

    showJou: document.getElementById('showJou').checked,

    showTsubo: document.getElementById('showTsubo').checked,

    useHalfGrid: document.getElementById('useHalfGrid').checked

  };

}

function applyUIState(ui) {

  if (!ui) return;

  if (typeof ui.showJou === 'boolean') document.getElementById('showJou').checked = ui.showJou;

  if (typeof ui.showTsubo === 'boolean') document.getElementById('showTsubo').checked = ui.showTsubo;

  if (typeof ui.useHalfGrid === 'boolean') document.getElementById('useHalfGrid').checked = ui.useHalfGrid;

}

 

function scheduleAutosave() {

  clearTimeout(autosaveTimer);

  autosaveTimer = setTimeout(() => {

    try {

      const key = getAutosaveKey(currentDocId);

      const payload = {

        v: "5.96",

        savedAt: Date.now(),     // ãƒ­ãƒ¼ã‚«ãƒ«æœ€çµ‚ç·¨é›†æ™‚åˆ»ï¼ˆæ¯”è¼ƒç”¨ï¼‰

        docId: currentDocId,

        items,

        isMerged,

        camera,

        ui: getUIState()

      };

      localStorage.setItem(key, JSON.stringify(payload));

    } catch (e) {

      console.warn("autosave failed:", e);

    }

  }, 250);

}

 

function readLocalAutosave(id) {

  const key = getAutosaveKey(id);

  const raw = localStorage.getItem(key);

  if (!raw) return null;

  try {

    const data = JSON.parse(raw);

    if (!data || !Array.isArray(data.items)) return null;

    return data;

  } catch {

    return null;

  }

}

 

function applyStateFromData(data) {

  items = data.items || [];

  isMerged = !!data.isMerged;

  camera = data.camera || { x: 0, y: 0 };

  applyUIState(data.ui);

  selectedItem = null;

  draw();

}

 

function init() {

  resizeCanvas();

  window.addEventListener('resize', resizeCanvas);

 

  const params = new URLSearchParams(window.location.search);

  const id = params.get('id');

 

  if (id) {

    currentDocId = id;

 

    // Firestoreèª­ã¿è¾¼ã¿ â†’ ãƒ­ãƒ¼ã‚«ãƒ«ï¼ˆåŒã˜docï¼‰ã®ã»ã†ãŒæ–°ã—ã‘ã‚Œã°å¾©å…ƒææ¡ˆ

    getDoc(doc(db, "layouts", id)).then(snap => {

      const local = readLocalAutosave(currentDocId);

 

      if (snap.exists()) {

        const d = snap.data() || {};

        const firestoreUpdatedMs =

          d.updatedAt && typeof d.updatedAt.toMillis === "function"

            ? d.updatedAt.toMillis()

            : 0;

 

        const firestoreData = {

          items: d.items || [],

          isMerged: d.isMerged || false,

          camera: d.camera || { x: 0, y: 0 },

          ui: d.ui || null

        };

 

        // ãƒ­ãƒ¼ã‚«ãƒ«ã®ã»ã†ãŒæ–°ã—ã„ï¼ˆå°‘ã—ä½™è£•ã‚’è¦‹ã¦ 2ç§’å·®ï¼‰ãªã‚‰ææ¡ˆ

        const localMs = local?.savedAt || 0;

        const isLocalNewer = local && (localMs > firestoreUpdatedMs + 2000);

 

        if (isLocalNewer) {

          const ok = confirm("ã“ã®ç«¯æœ«ã«ã€ã‚ˆã‚Šæ–°ã—ã„ç·¨é›†ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã™ã€‚å¾©å…ƒã—ã¾ã™ã‹ï¼Ÿ");

          if (ok) {

            applyStateFromData(local);

            showToast("ãƒ­ãƒ¼ã‚«ãƒ«ã®æœ€æ–°ãƒ‡ãƒ¼ã‚¿ã‚’å¾©å…ƒã—ã¾ã—ãŸ");

            // å¾©å…ƒå¾Œã€ãƒ­ãƒ¼ã‚«ãƒ«ã‚’ä¿è­·

            scheduleAutosave();

            return;

          }

        }

 

        // Firestoreæ¡ç”¨

        applyStateFromData(firestoreData);

 

        // Firestoreæ¡ç”¨æ™‚ã¯ã€ãƒ­ãƒ¼ã‚«ãƒ«ã‚‚æ›´æ–°ã—ã¦ãŠãï¼ˆæ¬¡å›ã®å¾©å…ƒã‚’æ°—æŒã¡ã‚ˆãï¼‰

        scheduleAutosave();

      } else {

        // docãŒç„¡ã„ â†’ ãƒ­ãƒ¼ã‚«ãƒ«ãŒã‚ã‚Œã°å¾©å…ƒã€ãªã‘ã‚Œã°æ–°è¦

        if (local && confirm("ä¿å­˜ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚ç«¯æœ«ã®ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‹ã‚‰å¾©å…ƒã—ã¾ã™ã‹ï¼Ÿ")) {

          applyStateFromData(local);

          showToast("ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‹ã‚‰å¾©å…ƒã—ã¾ã—ãŸ");

          scheduleAutosave();

        } else {

          currentDocId = null;

          addFunc('å¤–æ ', 10, 10, '#f8f8f8', 'frame');

        }

      }

    });

 

  } else {

    // ä¸‹æ›¸ãå¾©å…ƒï¼ˆdraftï¼‰

    const draft = readLocalAutosave(null);

    if (draft && confirm("å‰å›ã®ä¸‹æ›¸ããƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã—ãŸã€‚å¾©å…ƒã—ã¾ã™ã‹ï¼Ÿ")) {

      applyStateFromData(draft);

      showToast("ä¸‹æ›¸ãã‚’å¾©å…ƒã—ã¾ã—ãŸ");

      scheduleAutosave();

    } else {

      addFunc('å¤–æ ', 10, 10, '#f8f8f8', 'frame');

    }

  }

}

 

function resizeCanvas() {

  canvas.width = container.clientWidth;

  canvas.height = container.clientHeight;

  draw();

}

 

const getSnapped = (val, step) => Math.round(val / step) * step;

 

window.draw = function() {

  ctx.save();

  ctx.clearRect(0, 0, canvas.width, canvas.height);

  ctx.translate(canvas.width/2 + camera.x, canvas.height/2 + camera.y);

 

  ctx.strokeStyle = "#e5e5ea";

  ctx.lineWidth = 0.5;

  for (let x = -1600; x <= 1600; x += GRID_SIZE) { ctx.beginPath(); ctx.moveTo(x, -1600); ctx.lineTo(x, 1600); ctx.stroke(); }

  for (let y = -1600; y <= 1600; y += GRID_SIZE) { ctx.beginPath(); ctx.moveTo(-1600, y); ctx.lineTo(1600, y); ctx.stroke(); }

 

  if (isMerged) drawMerged();

  else drawNormal();

 

  if (selectedItem && !(isMerged && selectedItem.type === 'frame')) {

    ctx.strokeStyle = "#007AFF"; ctx.lineWidth = 3;

    ctx.strokeRect(selectedItem.x, selectedItem.y, selectedItem.w, selectedItem.h);

 

    if (isDragging || isResizing) {

      const mw = (selectedItem.w / GRID_SIZE).toFixed(1).replace('.0','');

      const mh = (selectedItem.h / GRID_SIZE).toFixed(1).replace('.0','');

      ctx.fillStyle = "rgba(0, 122, 255, 0.9)"; ctx.fillRect(selectedItem.x, selectedItem.y - 30, 70, 24);

      ctx.fillStyle = "#fff"; ctx.font = "bold 14px sans-serif"; ctx.fillText(`${mw} Ã— ${mh}`, selectedItem.x + 5, selectedItem.y - 12);

    }

 

    ctx.fillStyle = "#fff"; ctx.strokeStyle = "#007AFF"; ctx.beginPath();

    ctx.arc(selectedItem.x + selectedItem.w, selectedItem.y + selectedItem.h, 16, 0, Math.PI*2);

    ctx.fill(); ctx.stroke();

  }

 

  ctx.restore();

  updateSummary();

};

 

function drawNormal() {

  items.forEach(item => {

    ctx.fillStyle = item.color;

    ctx.globalAlpha = item.type==='room' ? 0.8 : 1.0;

    ctx.fillRect(item.x, item.y, item.w, item.h);

    ctx.globalAlpha = 1.0;

 

    ctx.strokeStyle = item.type === 'frame' ? "#ccc" : "#333";

    ctx.lineWidth = 1;

    ctx.strokeRect(item.x, item.y, item.w, item.h);

 

    ctx.fillStyle = "#111";

    ctx.font = "bold 13px sans-serif";

    ctx.fillText(item.label, item.x + 6, item.y + 18);

  });

}

 

function drawMerged() {

  const roomMap = {}; const frameMap = {}; const groups = {};

  const sub = 16;

 

  items.forEach((item, index) => {

    if (item.type !== 'frame') {

      if (!groups[item.label]) groups[item.label] = { label: item.label, totalMasu: 0, textX: 0, textY: 0, lastIdx: -1 };

      groups[item.label].totalMasu += (item.w / GRID_SIZE) * (item.h / GRID_SIZE);

      if (index > groups[item.label].lastIdx) { groups[item.label].textX = item.x + item.w/2; groups[item.label].lastIdx = index; groups[item.label].textY = item.y + item.h/2; }

    }

    for (let x = item.x; x < item.x + item.w; x += sub) {

      for (let y = item.y; y < item.y + item.h; y += sub) {

        const pos = `${x},${y}`;

        if (item.type === 'frame') frameMap[pos] = item.label;

        else roomMap[pos] = { label: item.label, color: item.color };

      }

    }

  });

 

  items.forEach(item => { ctx.fillStyle = item.type === 'frame' ? "#f8f8f8" : item.color; ctx.fillRect(item.x, item.y, item.w, item.h); });

 

  const drawEdge = (map, color, width) => {

    ctx.strokeStyle = color; ctx.lineWidth = width;

    for (const pos in map) {

      const [x, y] = pos.split(',').map(Number);

      const label = map[pos].label || map[pos];

      [{dx:0, dy:-sub}, {dx:0, dy:sub}, {dx:-sub, dy:0}, {dx:sub, dy:0}].forEach(d => {

        if ((map[`${x+d.dx},${y+d.dy}`]?.label || map[`${x+d.dx},${y+d.dy}`]) !== label) {

          ctx.beginPath();

          if (d.dy !== 0) { ctx.moveTo(x, y + (d.dy > 0 ? sub : 0)); ctx.lineTo(x + sub, y + (d.dy > 0 ? sub : 0)); }

          else { ctx.moveTo(x + (d.dx > 0 ? sub : 0), y); ctx.lineTo(x + (d.dx > 0 ? sub : 0), y + sub); }

          ctx.stroke();

        }

      });

    }

  };

 

  drawEdge(roomMap, "#333", 2);

  drawEdge(frameMap, "#111", 6);

 

  for (const key in groups) {

    const g = groups[key];

    ctx.fillStyle = "#111"; ctx.textAlign = "center"; ctx.font = "bold 14px sans-serif";

    ctx.fillText(g.label, g.textX, g.textY - 4);

 

    let subText = "";

    if (document.getElementById('showJou').checked) subText += `${(g.totalMasu/2).toFixed(1)}ç•³ `;

    if (document.getElementById('showTsubo').checked) subText += `${(g.totalMasu/4).toFixed(2)}åª`;

 

    ctx.font = "11px sans-serif";

    ctx.fillText(subText, g.textX, g.textY + 12);

    ctx.textAlign = "left";

  }

}

 

function updateSummary() {

  let tm = 0;

  items.forEach(i => { if(i.type === 'frame') tm += (i.w/GRID_SIZE)*(i.h/GRID_SIZE); });

  document.getElementById('totalTsubo').innerText = (tm/4).toFixed(2);

  document.getElementById('totalJou').innerText = (tm/2).toFixed(1);

}

 

const addFunc = (l, w, h, c, t='room') => {

  const targetX = getSnapped(-camera.x, GRID_SIZE);

  const targetY = getSnapped(-camera.y, GRID_SIZE);

  const i = { type: t, x: targetX, y: targetY, w: w*GRID_SIZE, h: h*GRID_SIZE, label: l, color: c };

  if(t==='frame') items.unshift(i); else items.push(i);

  selectedItem = i;

  draw();

  scheduleAutosave();

};

 

document.getElementById('addGenericRoomBtn').onclick = () => { const n = prompt("éƒ¨å±‹å", "æ´‹å®¤"); if (n) addFunc(n, 4, 4, '#FFF3E0'); };

document.getElementById('addFrameBtn').onclick = () => addFunc('å¤–æ ', 10, 10, '#f8f8f8', 'frame');

document.getElementById('addWallBtn').onclick = () => addFunc('å£', 1, 4, '#616161', 'wall');

 

document.getElementById('mergeBtn').onclick = () => {

  isMerged = !isMerged;

  document.getElementById('mergeBtn').innerText = isMerged ? "ç·¨é›†" : "çµåˆãƒ¢ãƒ¼ãƒ‰";

  draw();

  scheduleAutosave();

};

 

document.getElementById('copyBtn').onclick = () => {

  if(selectedItem) {

    const i = {...selectedItem, x: selectedItem.x+GRID_SIZE, y: selectedItem.y+GRID_SIZE};

    items.push(i); selectedItem = i; draw();

    scheduleAutosave();

  }

};

 

document.getElementById('resetBtn').onclick = () => {

  if(selectedItem) {

    items = items.filter(i => i !== selectedItem);

    selectedItem = null;

    draw();

    scheduleAutosave();

  } else if(confirm("å…¨æ¶ˆå»ã—ã¾ã™ã‹ï¼Ÿ")) {

    items = [];

    addFunc('å¤–æ ', 10, 10, '#f8f8f8', 'frame');

    scheduleAutosave();

  } else {

    draw();

  }

};

 

document.getElementById('colorPicker').oninput = (e) => { if(selectedItem) { selectedItem.color = e.target.value; draw(); scheduleAutosave(); } };

 

document.getElementById('centerBtn').onclick = () => { camera = { x: 0, y: 0 }; draw(); scheduleAutosave(); };

 

// â˜…å¤‰æ›´ï¼šãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹å¤‰æ›´ã‚‚ä¿å­˜å¯¾è±¡ã«

document.querySelectorAll('input[type="checkbox"]').forEach(el => {

  el.onchange = () => { draw(); scheduleAutosave(); };

});

 

document.getElementById('openHelpBtn').onclick = () => document.getElementById('helpModal').style.display = 'flex';

document.getElementById('helpModal').onclick = () => document.getElementById('helpModal').style.display = 'none';

 

// â˜…å¤‰æ›´ï¼šåˆå›ã¯ãƒ¢ãƒ¼ãƒ€ãƒ«ï¼ˆURLç™ºè¡Œï¼‰ã€ä¸Šæ›¸ãã¯ãƒˆãƒ¼ã‚¹ãƒˆã ã‘

document.getElementById('saveBtn').onclick = async () => {

  try {

    const payload = {

      items,

      isMerged,

      camera,

      ui: getUIState(),

      updatedAt: serverTimestamp()

    };

 

    if (currentDocId) {

      await updateDoc(doc(db, "layouts", currentDocId), payload);

      showToast("ä¿å­˜ã—ã¾ã—ãŸ");

      scheduleAutosave();

      return;

    }

 

    const r = await addDoc(collection(db, "layouts"), payload);

    currentDocId = r.id;

 

    const newUrl = `${window.location.origin}${window.location.pathname}?id=${currentDocId}`;

    history.replaceState(null, "", newUrl);

 

    // draftã®autosaveã‚’docç”¨ã‚­ãƒ¼ã¸ç§»ã™ï¼ˆã‚ã‚‹ãªã‚‰ï¼‰

    try {

      const draftKey = getAutosaveKey(null);

      const docKey = getAutosaveKey(currentDocId);

      const raw = localStorage.getItem(draftKey);

      if (raw) localStorage.setItem(docKey, raw);

      localStorage.removeItem(draftKey);

    } catch {}

 

    document.getElementById('shareUrlInput').value = newUrl;

    document.getElementById('saveModal').style.display = 'flex';

    scheduleAutosave();

 

  } catch (e) {

    alert("ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸã€‚é€šä¿¡çŠ¶æ³ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚");

    console.error(e);

  }

};

 

document.getElementById('copyUrlBtn').onclick = () => { navigator.clipboard.writeText(document.getElementById('shareUrlInput').value); alert("ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ"); };

document.getElementById('closeSaveModalBtn').onclick = () => document.getElementById('saveModal').style.display = 'none';

 

canvas.addEventListener('touchstart', e => {

  const now = Date.now();

  const rect = canvas.getBoundingClientRect();

  const p = { x: e.touches[0].clientX - rect.left, y: e.touches[0].clientY - rect.top };

  const worldP = { x: p.x - canvas.width/2 - camera.x, y: p.y - canvas.height/2 - camera.y };

 

  if (now - lastTapTime < 300 && selectedItem && !isMerged) {

    const n = prompt("åå‰å¤‰æ›´", selectedItem.label);

    if(n) { selectedItem.label = n; draw(); scheduleAutosave(); }

    return;

  }

  lastTapTime = now;

 

  if(selectedItem && !(isMerged && selectedItem.type==='frame')

    && Math.abs(worldP.x-(selectedItem.x+selectedItem.w))<30

    && Math.abs(worldP.y-(selectedItem.y+selectedItem.h))<30) {

    isResizing = true; return;

  }

 

  let found = null;

  for (let i = items.length-1; i >= 0; i--) {

    if (!isMerged || items[i].type !== 'frame') {

      const it = items[i];

      if (worldP.x >= it.x && worldP.x <= it.x+it.w && worldP.y >= it.y && worldP.y <= it.y+it.h) { found = it; break; }

    }

  }

 

  if(found) {

    selectedItem = found;

    items.splice(items.indexOf(found), 1);

    items.push(found);

    startX = worldP.x - found.x; startY = worldP.y - found.y;

    isDragging = true;

  } else {

    selectedItem = null;

    dragStart = { x: e.touches[0].clientX, y: e.touches[0].clientY };

    lastCamera = { ...camera };

  }

  draw();

});

 

canvas.addEventListener('touchmove', e => {

  e.preventDefault();

  const rect = canvas.getBoundingClientRect();

  const p = { x: e.touches[0].clientX - rect.left, y: e.touches[0].clientY - rect.top };

  const worldP = { x: p.x - canvas.width/2 - camera.x, y: p.y - canvas.height/2 - camera.y };

 

  const snap = document.getElementById('useHalfGrid').checked ? 16 : 32;

 

  if (isResizing && selectedItem) {

    selectedItem.w = Math.max(snap, getSnapped(worldP.x - selectedItem.x, snap));

    selectedItem.h = Math.max(snap, getSnapped(worldP.y - selectedItem.y, snap));

  } else if (isDragging && selectedItem) {

    selectedItem.x = getSnapped(worldP.x - startX, snap);

    selectedItem.y = getSnapped(worldP.y - startY, snap);

  } else if (dragStart) {

    camera.x = lastCamera.x + (e.touches[0].clientX - dragStart.x);

    camera.y = lastCamera.y + (e.touches[0].clientY - dragStart.y);

  }

  draw();

});

 

canvas.addEventListener('touchend', () => {

  isResizing = false;

  isDragging = false;

  dragStart = null;

  draw();

  scheduleAutosave();

});

 

init();

</script>

</body>

</html>