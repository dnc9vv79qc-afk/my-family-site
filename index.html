<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>間取りシミュレーター v5.94</title>
    <style>
        :root { --primary: #007AFF; --success: #34c759; --danger: #ff3b30; --warning: #FF9500; --bg: #f2f2f7; --card: #ffffff; }
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; margin: 0; background: var(--bg); touch-action: none; display: flex; flex-direction: column; height: 100vh; overflow: hidden; }
        .ver-label { position: fixed; top: 4px; right: 8px; font-size: 9px; color: #8e8e93; z-index: 100; pointer-events: none; font-weight: bold; }
        .toolbar { padding: 12px; background: var(--card); border-bottom: 1px solid #d1d1d6; z-index: 10; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        .grid-layout { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; margin-bottom: 8px; }
        button { height: 48px; font-size: 14px; border: none; border-radius: 12px; color: white; font-weight: bold; cursor: pointer; display: flex; align-items: center; justify-content: center; width: 100%; -webkit-tap-highlight-color: transparent; }
        button:active { opacity: 0.7; transform: scale(0.95); }
        .btn-frame { background: #3a3a3c; }
        .btn-room { background: var(--primary); }
        .btn-wall { background: #616161; }
        .btn-merge { background: #5856d6; }
        .btn-copy { background: var(--success); }
        .btn-reset { background: #8e8e93; }
        .btn-save { background: var(--warning); }
        .color-circle { background: #fff; border: 2px solid #d1d1d6; border-radius: 50%; width: 40px; height: 40px; display: flex; align-items: center; justify-content: center; overflow: hidden; margin: 0 auto; }
        input[type="color"] { width: 60px; height: 60px; border: none; background: none; cursor: pointer; padding: 0; }
        .config-bar { background: #e5e5ea; padding: 10px; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #c6c6c8; }
        .chip-group { display: flex; gap: 6px; }
        .chip { background: #fff; padding: 8px 14px; border-radius: 20px; font-size: 13px; font-weight: bold; display: flex; align-items: center; gap: 6px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); cursor: pointer; }
        .chip input { margin: 0; width: 18px; height: 18px; }
        .summary { background: #1c1c1e; color: #fff; padding: 12px 16px; display: flex; justify-content: space-around; font-size: 14px; font-weight: bold; }
        .summary b { color: var(--warning); }
        #canvas-container { flex: 1; position: relative; background: #fff; overflow: hidden; touch-action: none; }
        canvas { display: block; }
        .modal-overlay { display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.6); z-index: 1000; align-items: center; justify-content: center; }
        .modal { background: #fff; padding: 25px; border-radius: 20px; width: 85%; max-width: 320px; text-align: center; }
        .modal input { width: 100%; padding: 12px; margin: 15px 0; border: 1px solid #ddd; border-radius: 10px; font-size: 14px; box-sizing: border-box; }
    </style>
</head>
<body>
    <div class="ver-label">ver 5.94 (Meters)</div>
    <div class="toolbar">
        <div class="grid-layout">
            <button class="btn-frame" id="addFrameBtn">+ 外枠</button>
            <button class="btn-room" id="addGenericRoomBtn">+ 部屋追加</button>
            <button class="btn-wall" id="addWallBtn">+ 壁</button>
        </div>
        <div class="grid-layout" style="grid-template-columns: 2fr 1fr 1fr;">
            <button id="mergeBtn" class="btn-merge">結合モード</button>
            <button class="btn-copy" id="copyBtn">複製</button>
            <div class="color-circle"><input type="color" id="colorPicker" value="#ffffff"></div>
        </div>
        <div class="grid-layout" style="grid-template-columns: 1fr 1fr;">
            <button class="btn-save" id="saveBtn">共有URL作成</button>
            <button class="btn-reset" id="resetBtn">削除 / 消去</button>
        </div>
    </div>
    
    <div class="config-bar">
        <div class="chip-group">
            <label class="chip"><input type="checkbox" id="showJou" checked>畳</label>
            <label class="chip"><input type="checkbox" id="showTsubo" checked>坪</label>
            <label class="chip" style="background:#d1d1d6;"><input type="checkbox" id="useHalfGrid">半ます</label>
        </div>
        <button id="centerBtn" style="width:auto; height:34px; padding:0 12px; background:var(--primary); font-size:12px;">表示を戻す</button>
    </div>

    <div class="summary">
        <span>延床: <b id="totalTsubo">0.00</b> 坪</span>
        <span><b id="totalJou">0.0</b> 畳</span>
    </div>

    <div id="canvas-container"><canvas id="canvas"></canvas></div>

    <div id="saveModal" class="modal-overlay">
        <div class="modal">
            <h3>共有URL作成完了</h3>
            <input type="text" id="shareUrlInput" readonly onclick="this.select()">
            <div style="display:flex; gap:10px;">
                <button style="flex:1; background:var(--primary);" id="copyUrlBtn">コピー</button>
                <button style="flex:1; background:#8e8e93;" id="closeModalBtn">閉じる</button>
            </div>
        </div>
    </div>

<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
    import { getFirestore, collection, addDoc, getDoc, doc } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";
    const firebaseConfig = { apiKey: "AIzaSyBH4zoH5ZnfPcZmmXNvfeGOJz9__KkSMrg", authDomain: "test-55430.firebaseapp.com", projectId: "test-55430", storageBucket: "test-55430.firebasestorage.app", messagingSenderId: "742726212885", appId: "1:742726212885:web:597a48fc1ce0cb7f529d1c", measurementId: "G-PW24JY2LBP" };
    const app = initializeApp(firebaseConfig); const db = getFirestore(app);
    const canvas = document.getElementById('canvas'); const ctx = canvas.getContext('2d'); const container = document.getElementById('canvas-container');
    const GRID_SIZE = 32;
    const METERS_PER_GRID = 0.91; // ★1マス = 0.91m
    let items = []; let selectedItem = null; let isResizing = false; let isDragging = false; let isMerged = false;
    let camera = { x: 0, y: 0 };
    let dragStart = null; let lastCamera = { x: 0, y: 0 };
    let startX, startY;
    let lastTapTime = 0;

    function init() {
        resizeCanvas(); window.addEventListener('resize', resizeCanvas);
        const params = new URLSearchParams(window.location.search);
        if (params.get('id')) {
            getDoc(doc(db, "layouts", params.get('id'))).then(snap => {
                if (snap.exists()) { items = snap.data().items; isMerged = snap.data().isMerged || false; draw(); }
                else { addFunc('外枠', 10, 10, '#f8f8f8', 'frame'); }
            });
        } else { addFunc('外枠', 10, 10, '#f8f8f8', 'frame'); }
    }

    function resizeCanvas() { canvas.width = container.clientWidth; canvas.height = container.clientHeight; draw(); }
    const getSnapped = (val, step) => Math.round(val / step) * step;

    window.draw = function() {
        ctx.save();
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.translate(canvas.width/2 + camera.x, canvas.height/2 + camera.y);
        
        ctx.strokeStyle = "#e5e5ea"; ctx.lineWidth = 0.5;
        const range = 2000;
        for (let x = -range; x <= range; x += GRID_SIZE) { ctx.beginPath(); ctx.moveTo(x, -range); ctx.lineTo(x, range); ctx.stroke(); }
        for (let y = -range; y <= range; y += GRID_SIZE) { ctx.beginPath(); ctx.moveTo(-range, y); ctx.lineTo(range, y); ctx.stroke(); }
        
        if (isMerged) drawMerged(); else drawNormal();

        if (selectedItem && !(isMerged && selectedItem.type === 'frame')) {
            ctx.strokeStyle = "#007AFF"; ctx.lineWidth = 3;
            ctx.strokeRect(selectedItem.x, selectedItem.y, selectedItem.w, selectedItem.h);
            
            // ★メートル表示
            if (isDragging || isResizing) {
                const mw = (selectedItem.w / GRID_SIZE);
                const mh = (selectedItem.h / GRID_SIZE);
                const m_w = (mw * METERS_PER_GRID).toFixed(2);
                const m_h = (mh * METERS_PER_GRID).toFixed(2);
                
                ctx.fillStyle = "rgba(0, 122, 255, 0.9)";
                ctx.fillRect(selectedItem.x, selectedItem.y - 40, 100, 32);
                ctx.fillStyle = "#fff";
                ctx.font = "bold 11px sans-serif";
                ctx.fillText(`${mw.toFixed(1)}マス (${m_w}m)`, selectedItem.x + 5, selectedItem.y - 25);
                ctx.fillText(`${mh.toFixed(1)}マス (${m_h}m)`, selectedItem.x + 5, selectedItem.y - 12);
            }

            ctx.fillStyle = "#fff"; ctx.strokeStyle = "#007AFF"; ctx.beginPath();
            ctx.arc(selectedItem.x + selectedItem.w, selectedItem.y + selectedItem.h, 16, 0, Math.PI*2);
            ctx.fill(); ctx.stroke();
        }
        ctx.restore();
        updateSummary();
    };

    function drawNormal() {
        items.forEach(item => {
            ctx.fillStyle = item.color; ctx.globalAlpha = item.type==='room' ? 0.8 : 1.0;
            ctx.fillRect(item.x, item.y, item.w, item.h); ctx.globalAlpha = 1.0;
            ctx.strokeStyle = item.type === 'frame' ? "#ccc" : "#333"; ctx.lineWidth = 1;
            ctx.strokeRect(item.x, item.y, item.w, item.h);
            ctx.fillStyle = "#111"; ctx.font = "bold 13px sans-serif";
            ctx.fillText(item.label, item.x + 6, item.y + 18);
        });
    }

    function drawMerged() {
        const roomMap = {}; const frameMap = {}; const groups = {};
        const sub = 16;
        items.forEach((item, index) => {
            if (item.type !== 'frame') {
                if (!groups[item.label]) groups[item.label] = { label: item.label, totalMasu: 0, textX: 0, textY: 0, lastIdx: -1 };
                groups[item.label].totalMasu += (item.w / GRID_SIZE) * (item.h / GRID_SIZE);
                if (index > groups[item.label].lastIdx) { groups[item.label].textX = item.x + item.w/2; groups[item.label].textY = item.y + item.h/2; groups[item.label].lastIdx = index; }
            }
            for (let x = item.x; x < item.x + item.w; x += sub) { for (let y = item.y; y < item.y + item.h; y += sub) {
                const pos = `${x},${y}`; if (item.type === 'frame') frameMap[pos] = item.label; else roomMap[pos] = { label: item.label, color: item.color };
            }}
        });

        items.forEach(item => { ctx.fillStyle = item.type === 'frame' ? "#f8f8f8" : item.color; ctx.fillRect(item.x, item.y, item.w, item.h); });

        const drawEdge = (map, color, width, isFrame) => {
            ctx.strokeStyle = color; ctx.lineWidth = width;
            for (const pos in map) {
                const [x, y] = pos.split(',').map(Number); const label = map[pos].label || map[pos];
                [{dx:0, dy:-sub}, {dx:0, dy:sub}, {dx:-sub, dy:0}, {dx:sub, dy:0}].forEach(d => {
                    if ((map[`${x+d.dx},${y+d.dy}`]?.label || map[`${x+d.dx},${y+d.dy}`]) !== label) {
                        ctx.beginPath();
                        if(d.dy!==0){ ctx.moveTo(x, y+(d.dy>0?sub:0)); ctx.lineTo(x+sub, y+(d.dy>0?sub:0)); } 
                        else { ctx.moveTo(x+(d.dx>0?sub:0), y); ctx.lineTo(x+(d.dx>0?sub:0), y+sub); }
                        ctx.stroke();
                        // ★外枠の長さを表示
                        if(isFrame && (map[`${x+d.dx},${y+d.dy}`] === undefined)) {
                            ctx.fillStyle = "#ff3b30"; ctx.font = "bold 9px sans-serif";
                            if(d.dy === -sub && x % 64 === 0) ctx.fillText(`${(sub*2/GRID_SIZE*METERS_PER_GRID).toFixed(2)}m`, x, y-2);
                        }
                    }
                });
            }
        };
        drawEdge(roomMap, "#333", 2, false);
        drawEdge(frameMap, "#111", 6, true);

        for (const key in groups) { 
            const g = groups[key]; ctx.fillStyle = "#111"; ctx.textAlign = "center"; ctx.font = "bold 14px sans-serif";
            ctx.fillText(g.label, g.textX, g.textY - 4);
            let subText = ""; 
            if (document.getElementById('showJou').checked) subText += `${(g.totalMasu/2).toFixed(1)}畳 `; 
            if (document.getElementById('showTsubo').checked) subText += `${(g.totalMasu/4).toFixed(2)}坪`;
            ctx.font = "11px sans-serif"; ctx.fillText(subText, g.textX, g.textY + 12); ctx.textAlign = "left";
        }
    }

    function updateSummary() {
        let tm = 0; items.forEach(i => { if(i.type === 'frame') tm += (i.w/GRID_SIZE)*(i.h/GRID_SIZE); });
        document.getElementById('totalTsubo').innerText = (tm/4).toFixed(2); document.getElementById('totalJou').innerText = (tm/2).toFixed(1);
    }

    const addFunc = (l, w, h, c, t='room') => { 
        const targetX = getSnapped(-camera.x, GRID_SIZE); const targetY = getSnapped(-camera.y, GRID_SIZE);
        const i = { type: t, x: targetX, y: targetY, w: w*GRID_SIZE, h: h*GRID_SIZE, label: l, color: c }; 
        if(t==='frame') items.unshift(i); else items.push(i); selectedItem = i; draw(); 
    };

    document.getElementById('addGenericRoomBtn').onclick = () => { const n = prompt("名前", "洋室"); if(n) addFunc(n, 4, 4, '#FFF3E0'); };
    document.getElementById('addFrameBtn').onclick = () => addFunc('外枠', 10, 10, '#f8f8f8', 'frame');
    document.getElementById('addWallBtn').onclick = () => addFunc('壁', 1, 4, '#616161', 'wall');
    document.getElementById('mergeBtn').onclick = () => { isMerged = !isMerged; document.getElementById('mergeBtn').innerText = isMerged ? "編集" : "結合モード"; draw(); };
    document.getElementById('copyBtn').onclick = () => { if(selectedItem) { const i = {...selectedItem, x: selectedItem.x+GRID_SIZE, y: selectedItem.y+GRID_SIZE}; items.push(i); selectedItem = i; draw(); } };
    document.getElementById('resetBtn').onclick = () => { if(selectedItem) { items = items.filter(i => i !== selectedItem); selectedItem = null; } else if(confirm("全消去？")) { items = []; addFunc('外枠', 10, 10, '#f8f8f8', 'frame'); } draw(); };
    document.getElementById('colorPicker').oninput = (e) => { if(selectedItem) { selectedItem.color = e.target.value; draw(); } };
    document.getElementById('centerBtn').onclick = () => { camera = { x: 0, y: 0 }; draw(); };
    document.querySelectorAll('input[type="checkbox"]').forEach(el => el.onchange = draw);

    document.getElementById('saveBtn').onclick = async () => { 
        const r = await addDoc(collection(db, "layouts"), { items, isMerged, updatedAt: new Date() });
        document.getElementById('shareUrlInput').value = `${window.location.origin}${window.location.pathname}?id=${r.id}`;
        document.getElementById('saveModal').style.display = 'flex';
    };
    document.getElementById('copyUrlBtn').onclick = () => { navigator.clipboard.writeText(document.getElementById('shareUrlInput').value); alert("コピー完了"); };
    document.getElementById('closeModalBtn').onclick = () => document.getElementById('saveModal').style.display = 'none';

    canvas.addEventListener('touchstart', e => {
        const now = Date.now(); const rect = canvas.getBoundingClientRect();
        const p = { x: e.touches[0].clientX - rect.left, y: e.touches[0].clientY - rect.top };
        const worldP = { x: p.x - canvas.width/2 - camera.x, y: p.y - canvas.height/2 - camera.y };
        if (now - lastTapTime < 300 && selectedItem && !isMerged) { const n = prompt("名前変更", selectedItem.label); if(n) { selectedItem.label = n; draw(); } return; }
        lastTapTime = now;
        if(selectedItem && !(isMerged && selectedItem.type==='frame') && Math.abs(worldP.x-(selectedItem.x+selectedItem.w))<30 && Math.abs(worldP.y-(selectedItem.y+selectedItem.h))<30) { isResizing = true; return; }
        let found = null;
        for (let i = items.length-1; i >= 0; i--) { if (!isMerged || items[i].type !== 'frame') {
            const it = items[i]; if (worldP.x >= it.x && worldP.x <= it.x+it.w && worldP.y >= it.y && worldP.y <= it.y+it.h) { found = it; break; }
        }}
        if(found) { selectedItem = found; items.splice(items.indexOf(found), 1); items.push(found); startX = worldP.x - found.x; startY = worldP.y - found.y; isDragging = true; }
        else { selectedItem = null; dragStart = { x: e.touches[0].clientX, y: e.touches[0].clientY }; lastCamera = { ...camera }; }
        draw();
    });

    canvas.addEventListener('touchmove', e => {
        e.preventDefault(); const rect = canvas.getBoundingClientRect();
        const p = { x: e.touches[0].clientX - rect.left, y: e.touches[0].clientY - rect.top };
        const worldP = { x: p.x - canvas.width/2 - camera.x, y: p.y - canvas.height/2 - camera.y };
        const snap = document.getElementById('useHalfGrid').checked ? 16 : 32;
        if (isResizing && selectedItem) { selectedItem.w = Math.max(snap, getSnapped(worldP.x - selectedItem.x, snap)); selectedItem.h = Math.max(snap, getSnapped(worldP.y - selectedItem.y, snap)); }
        else if (isDragging && selectedItem) { selectedItem.x = getSnapped(worldP.x - startX, snap); selectedItem.y = getSnapped(worldP.y - startY, snap); }
        else if (dragStart) { camera.x = lastCamera.x + (e.touches[0].clientX - dragStart.x); camera.y = lastCamera.y + (e.touches[0].clientY - dragStart.y); }
        draw();
    });

    canvas.addEventListener('touchend', () => { isResizing = false; isDragging = false; dragStart = null; draw(); });
    init();
</script>
</body>
</html>
