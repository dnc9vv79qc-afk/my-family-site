<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<title>é–“å–ã‚Šã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼ v5.95</title>

<style>
/* ===== Theme (Glass / Modern) ===== */
:root{
  --accent:#007AFF;
  --success:#34c759;
  --danger:#ff3b30;
  --warning:#FF9500;

  --bg:#f2f2f7;
  --card: rgba(255,255,255,.72);
  --stroke: rgba(60,60,67,.18);
  --text:#111;
  --muted: rgba(60,60,67,.6);
  --shadow: 0 10px 30px rgba(0,0,0,.10);
  --radius: 20px;
  --radius2: 26px;
}

@media (prefers-color-scheme: dark){
  :root{
    --bg:#000;
    --card: rgba(28,28,30,.68);
    --stroke: rgba(84,84,88,.55);
    --text:#fff;
    --muted: rgba(235,235,245,.6);
    --shadow: 0 16px 50px rgba(0,0,0,.45);
  }
}

*{ box-sizing: border-box; }

body{
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
  margin: 0;
  background: var(--bg);
  color: var(--text);
  touch-action: none;
  display: flex;
  flex-direction: column;
  height: 100vh;
  overflow: hidden;
}

.ver-label{
  position: fixed;
  top: 6px;
  right: 10px;
  font-size: 10px;
  color: var(--muted);
  z-index: 100;
  pointer-events: none;
  font-weight: 800;
  text-align: right;
  opacity: .85;
}

/* ===== Top bar: å…±æœ‰URLãƒ»è‰²ãƒ»ï¼Ÿã ã‘ ===== */
.toolbar{
  margin: 12px;
  border-radius: var(--radius2);
  background: var(--card);
  border: 1px solid var(--stroke);
  box-shadow: var(--shadow);
  backdrop-filter: blur(16px);
  -webkit-backdrop-filter: blur(16px);

  padding: 10px;
  display:flex;
  align-items:center;
  justify-content: space-between;
  gap: 10px;

  z-index: 10;
}

.top-left, .top-right{
  display:flex;
  align-items:center;
  gap: 10px;
}

.top-title{
  font-weight: 900;
  font-size: 13px;
  letter-spacing: .2px;
  color: var(--text);
  opacity: .9;
  user-select:none;
}

/* ===== Buttons ===== */
button{
  height: 44px;
  font-size: 13px;
  border: none;
  border-radius: 16px;
  color: white;
  font-weight: 900;
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: auto;
  padding: 0 14px;
  -webkit-tap-highlight-color: transparent;
  letter-spacing: .2px;
  transition: transform .08s ease, filter .08s ease;
}
button:active { opacity: 0.85; transform: scale(0.98); }

.btn-primary{ background: rgba(255,149,0,.95); } /* å…±æœ‰URL */
.btn-help{
  background: rgba(120,120,128,.18);
  color: var(--text);
  font-size: 18px;
  width: 44px;
  padding: 0;
}

.color-circle{
  background: rgba(120,120,128,.18);
  border: 1px solid var(--stroke);
  border-radius: 16px;
  width: 44px;
  height: 44px;
  display:flex;
  align-items:center;
  justify-content:center;
  overflow:hidden;
  box-shadow: none;
}
input[type="color"]{
  width: 70px;
  height: 70px;
  border: none;
  background: none;
  cursor: pointer;
  padding: 0;
}

/* ===== Config bar ===== */
.config-bar{
  margin: 0 12px 12px;
  border-radius: var(--radius2);
  background: var(--card);
  border: 1px solid var(--stroke);
  box-shadow: var(--shadow);
  backdrop-filter: blur(16px);
  -webkit-backdrop-filter: blur(16px);

  padding: 10px;
  display:flex;
  justify-content: space-between;
  align-items:center;
  gap: 10px;
}

.chip-group { display: flex; gap: 6px; flex-wrap: wrap; }
.chip{
  background: rgba(255,255,255,.55);
  border: 1px solid var(--stroke);
  padding: 8px 12px;
  border-radius: 999px;
  font-size: 13px;
  font-weight: 900;
  display:flex;
  align-items:center;
  gap: 6px;
  box-shadow: 0 1px 6px rgba(0,0,0,.06);
  cursor: pointer;
  color: var(--text);
}
@media (prefers-color-scheme: dark){
  .chip{ background: rgba(44,44,46,.65); }
}
.chip input { margin: 0; width: 18px; height: 18px; }

.right-actions{
  display:flex;
  align-items:center;
  gap: 10px;
}

/* ===== Segmented control (ç·¨é›†/çµåˆ) ===== */
.segment{
  display:flex;
  border: 1px solid var(--stroke);
  border-radius: 999px;
  overflow:hidden;
  background: rgba(120,120,128,.12);
}
.seg-btn{
  height: 34px;
  border-radius: 0;
  padding: 0 12px;
  background: transparent;
  color: var(--text);
  font-size: 12px;
  font-weight: 900;
  box-shadow:none;
}
.seg-btn.active{
  background: var(--accent);
  color: #fff;
}
.seg-btn:active{ transform: none; }

/* small buttons */
.small-btn{
  height: 34px;
  border-radius: 999px;
  padding: 0 12px;
  background: var(--accent);
  color:#fff;
  font-size: 12px;
  font-weight: 900;
}

/* ===== Summary ===== */
.summary{
  margin: 0 12px 12px;
  border-radius: 999px;
  background: var(--card);
  border: 1px solid var(--stroke);
  box-shadow: var(--shadow);
  backdrop-filter: blur(16px);
  -webkit-backdrop-filter: blur(16px);

  padding: 10px 14px;
  display:flex;
  justify-content: space-around;
  align-items:center;

  font-size: 14px;
  font-weight: 900;
}
.summary b{ color: var(--accent); }

/* ===== Canvas ===== */
#canvas-container{
  flex: 1;
  position: relative;
  margin: 0 12px 12px;
  border-radius: 24px;
  overflow: hidden;
  border: 1px solid var(--stroke);
  box-shadow: var(--shadow);
  background: #fff;
  touch-action: none;

  /* bottom-baråˆ†ã®ä½™ç™½ï¼ˆä¸‹ã§éš ã‚Œãªã„ã‚ˆã†ã«ï¼‰ */
  margin-bottom: 96px;
}
canvas{ display:block; }

/* ===== Bottom Bar ===== */
.bottom-bar{
  position: fixed;
  left: 12px; right: 12px;
  bottom: calc(12px + env(safe-area-inset-bottom));
  display: grid;
  grid-template-columns: repeat(5, 1fr);
  gap: 10px;
  padding: 10px;
  border-radius: 24px;
  background: var(--card);
  border: 1px solid var(--stroke);
  box-shadow: var(--shadow);
  backdrop-filter: blur(16px);
  -webkit-backdrop-filter: blur(16px);
  z-index: 60;
}

.pill{
  height: 48px;
  border-radius: 18px;
  background: rgba(120,120,128,.16);
  color: var(--text);
  box-shadow: none;
  font-weight: 900;
  font-size: 13px;
  letter-spacing: .2px;

  display:flex;
  align-items:center;
  justify-content:center;
  flex-direction: column;
  gap: 2px;
  padding: 6px 0;
}
.pill::after{
  content: attr(data-sub);
  font-size: 10px;
  font-weight: 800;
  color: var(--muted);
  letter-spacing: .1px;
}
.pill.primary{ background: var(--accent); color:#fff; }
.pill.primary::after{ color: rgba(255,255,255,.85); }
.pill.danger{
  background: rgba(255,59,48,.14);
  color: #ff3b30;
}
.pill:disabled{
  opacity: .35;
  filter: grayscale(1);
  transform: none !important;
  cursor: default;
}
@media (prefers-color-scheme: dark){
  .pill{ background: rgba(118,118,128,.24); }
  .pill.danger{ background: rgba(255,69,58,.18); color:#ff453a; }
}

/* ===== Modals ===== */
.modal-overlay{
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.6);
  z-index: 1000;
  align-items: center;
  justify-content: center;
}
.modal{
  background: #fff;
  padding: 25px;
  border-radius: 20px;
  width: 85%;
  max-width: 360px;
  text-align: center;
  box-shadow: 0 10px 30px rgba(0,0,0,0.3);
}
.modal input{
  width: 100%;
  padding: 12px;
  margin: 15px 0;
  border: 1px solid #ddd;
  border-radius: 10px;
  font-size: 14px;
  box-sizing: border-box;
}
#helpModal .modal{
  max-width: 420px;
  text-align: left;
  max-height: 80vh;
  overflow-y: auto;
}
#helpModal ul{ padding-left: 20px; font-size: 13px; line-height: 1.6; }
#helpModal h3{ text-align: center; margin-top: 0; }

.toolbar, .config-bar, .summary{
  padding-bottom: calc(10px + env(safe-area-inset-bottom));
}
</style>
</head>

<body>
<div class="ver-label">ver 5.95<br>by yuchiğŸ”</div>

<!-- Top: å…±æœ‰URLãƒ»è‰²ãƒ»ï¼Ÿ -->
<div class="toolbar">
  <div class="top-left">
    <button class="btn-help" id="openHelpBtn" aria-label="ãƒ˜ãƒ«ãƒ—">ï¼Ÿ</button>
    <div class="top-title">é–“å–ã‚Šã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼</div>
  </div>
  <div class="top-right">
    <button class="btn-primary" id="saveBtn">å…±æœ‰URL</button>
    <div class="color-circle" title="é¸æŠä¸­ãƒ‘ãƒ¼ãƒ„ã®è‰²">
      <input type="color" id="colorPicker" value="#ffffff">
    </div>
  </div>
</div>

<div class="config-bar">
  <div class="chip-group">
    <label class="chip"><input type="checkbox" id="showJou" checked>ç•³</label>
    <label class="chip"><input type="checkbox" id="showTsubo" checked>åª</label>
    <label class="chip" style="background:rgba(120,120,128,.20);"><input type="checkbox" id="useHalfGrid">åŠã¾ã™</label>
  </div>

  <div class="right-actions">
    <div class="segment" role="tablist" aria-label="è¡¨ç¤ºãƒ¢ãƒ¼ãƒ‰">
      <button class="seg-btn active" id="segEdit" type="button">ç·¨é›†</button>
      <button class="seg-btn" id="segMerge" type="button">çµåˆ</button>
    </div>
    <button id="fitBtn" class="small-btn" type="button">å¤–æ ã«ãƒ•ã‚£ãƒƒãƒˆ</button>
    <button id="centerBtn" class="small-btn" type="button">è¡¨ç¤ºãƒªã‚»ãƒƒãƒˆ</button>
  </div>
</div>

<div class="summary">
  <span>å»¶åºŠ: <b id="totalTsubo">0.00</b> åª</span>
  <span><b id="totalJou">0.0</b> ç•³</span>
</div>

<div id="canvas-container"><canvas id="canvas"></canvas></div>

<!-- Bottom bar -->
<div class="bottom-bar" id="bottomBar">
  <button class="pill" id="addFrameBtn2" data-sub="æ ã‚’è¿½åŠ ">å¤–æ </button>
  <button class="pill primary" id="addGenericRoomBtn2" data-sub="éƒ¨å±‹ã‚’è¿½åŠ ">éƒ¨å±‹</button>
  <button class="pill" id="addWallBtn2" data-sub="å£ã‚’è¿½åŠ ">å£</button>
  <button class="pill" id="copyBtn2" data-sub="é¸æŠã‚’è¤‡è£½">è¤‡è£½</button>
  <button class="pill danger" id="resetBtn2" data-sub="é¸æŠ/å…¨æ¶ˆå»">å‰Šé™¤</button>
</div>

<!-- Save Modal -->
<div id="saveModal" class="modal-overlay">
  <div class="modal">
    <h3>å…±æœ‰URL</h3>
    <div style="font-size:12px;color:#666;margin-top:-6px;">ï¼ˆåŒã˜URLã«ä¸Šæ›¸ãä¿å­˜ã•ã‚Œã¾ã™ï¼‰</div>
    <input type="text" id="shareUrlInput" readonly onclick="this.select()">
    <div style="display:flex; gap:10px;">
      <button style="flex:1; background:var(--accent);" id="copyUrlBtn">ã‚³ãƒ”ãƒ¼</button>
      <button style="flex:1; background:rgba(120,120,128,.45); color:#fff;" id="closeSaveModalBtn">é–‰ã˜ã‚‹</button>
    </div>
  </div>
</div>

<!-- Help Modal -->
<div id="helpModal" class="modal-overlay">
  <div class="modal">
    <h3>ğŸ  æ“ä½œãƒãƒ‹ãƒ¥ã‚¢ãƒ«</h3>
    <ul>
      <li><b>åŸºæœ¬:</b> ä¸‹ã®ãƒœã‚¿ãƒ³ã§ãƒ‘ãƒ¼ãƒ„ã‚’è¿½åŠ ã—ã€ãƒ‰ãƒ©ãƒƒã‚°ã§ç§»å‹•ã€‚</li>
      <li><b>ã‚µã‚¤ã‚ºå¤‰æ›´:</b> ãƒ‘ãƒ¼ãƒ„å³ä¸‹ã®ä¸¸ã„ãƒãƒ³ãƒ‰ãƒ«ã‚’ãƒ‰ãƒ©ãƒƒã‚°ã€‚</li>
      <li><b>ç”»é¢ç§»å‹•:</b> èƒŒæ™¯éƒ¨åˆ†ã‚’ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦ã‚¹ãƒ©ã‚¤ãƒ‰ã€‚</li>
      <li><b>åå‰ç·¨é›†:</b> ãƒ‘ãƒ¼ãƒ„ã‚’ç´ æ—©ã2å›ã‚¿ãƒƒãƒ—ï¼ˆç·¨é›†ãƒ¢ãƒ¼ãƒ‰ã®ã¿ï¼‰ã€‚</li>
      <li><b>çµåˆè¡¨ç¤º:</b> ã€Œçµåˆã€ã§åŒã˜åå‰ã®éƒ¨å±‹ã‚’åˆä½“è¡¨ç¤ºã€‚</li>
      <li><b>ä¿å­˜:</b> å…±æœ‰URLã‚’ç™ºè¡Œã—ã¦ç¶šãã‚’ç·¨é›†å¯èƒ½ã€‚</li>
    </ul>
    <p style="font-size:11px; color:#666; text-align:center;">ï¼ˆç”»é¢ã‚’ã‚¿ãƒƒãƒ—ã—ã¦é–‰ã˜ã‚‹ï¼‰</p>
  </div>
</div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
import { getFirestore, collection, addDoc, getDoc, doc, setDoc } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

const firebaseConfig = {
  apiKey: "AIzaSyBH4zoH5ZnfPcZmmXNvfeGOJz9__KkSMrg",
  authDomain: "test-55430.firebaseapp.com",
  projectId: "test-55430",
  storageBucket: "test-55430.firebasestorage.app",
  messagingSenderId: "742726212885",
  appId: "1:742726212885:web:597a48fc1ce0cb7f529d1c",
  measurementId: "G-PW24JY2LBP"
};

const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

const el = (id) => document.getElementById(id);

const canvas = el('canvas');
const ctx = canvas.getContext('2d');
const container = el('canvas-container');

const GRID_SIZE = 32;

let items = [];
let selectedItem = null;
let isResizing = false;
let isDragging = false;
let isMerged = false;

let camera = { x: 0, y: 0 };
let dragStart = null;
let lastCamera = { x: 0, y: 0 };
let startX, startY;
let lastTapTime = 0;

let layoutId = null; // â˜…å…±æœ‰URLã®idï¼ˆä¸Šæ›¸ãä¿å­˜ç”¨ï¼‰

const getSnapped = (val, step) => Math.round(val / step) * step;

function resizeCanvas(){
  canvas.width = container.clientWidth;
  canvas.height = container.clientHeight;
  draw();
}

function updateSegmentUI(){
  el('segEdit').classList.toggle('active', !isMerged);
  el('segMerge').classList.toggle('active', isMerged);
}
function setMergedMode(val){
  isMerged = val;
  updateSegmentUI();
  draw();
}

function updateSummary(){
  let tm = 0;
  items.forEach(i => { if(i.type === 'frame') tm += (i.w/GRID_SIZE)*(i.h/GRID_SIZE); });
  el('totalTsubo').innerText = (tm/4).toFixed(2);
  el('totalJou').innerText = (tm/2).toFixed(1);
}

function syncBottomBarState(){
  // è¤‡è£½ã¯é¸æŠãŒãªã„ã¨ä¸å¯ï¼ˆèª¤çˆ†é˜²æ­¢ï¼‰
  el('copyBtn2').disabled = !selectedItem;
  // å‰Šé™¤ã¯ã€Œå…¨æ¶ˆå»ã€ã«ã‚‚ä½¿ã†ã®ã§å¸¸ã«æŠ¼ã›ã‚‹ï¼ˆèª¤çˆ†ã¯confirmã§å®ˆã‚‹ï¼‰
}

function addFunc(label, w, h, color, type='room'){
  const targetX = getSnapped(-camera.x, GRID_SIZE);
  const targetY = getSnapped(-camera.y, GRID_SIZE);
  const i = { type, x: targetX, y: targetY, w: w*GRID_SIZE, h: h*GRID_SIZE, label, color };
  if(type === 'frame') items.unshift(i); else items.push(i);
  selectedItem = i;
  draw();
}

function fitToFrame(){
  const frames = items.filter(i => i.type === 'frame');
  const targets = frames.length ? frames : items;
  if (!targets.length) return;

  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
  targets.forEach(it => {
    minX = Math.min(minX, it.x);
    minY = Math.min(minY, it.y);
    maxX = Math.max(maxX, it.x + it.w);
    maxY = Math.max(maxY, it.y + it.h);
  });

  const cx = (minX + maxX) / 2;
  const cy = (minY + maxY) / 2;

  camera = { x: -cx, y: -cy };
  draw();
}

function drawNormal(){
  items.forEach(item => {
    ctx.fillStyle = item.color;
    ctx.globalAlpha = item.type==='room' ? 0.82 : 1.0;
    ctx.fillRect(item.x, item.y, item.w, item.h);
    ctx.globalAlpha = 1.0;

    ctx.strokeStyle = item.type === 'frame' ? "#cfcfd6" : "#333";
    ctx.lineWidth = 1;
    ctx.strokeRect(item.x, item.y, item.w, item.h);

    ctx.fillStyle = "#111";
    ctx.font = "bold 13px sans-serif";
    ctx.fillText(item.label, item.x + 6, item.y + 18);
  });
}

function drawMerged(){
  const roomMap = {};
  const frameMap = {};
  const groups = {};
  const sub = 16;

  items.forEach((item, index) => {
    if (item.type !== 'frame') {
      if (!groups[item.label]) groups[item.label] = { label: item.label, totalMasu: 0, textX: 0, textY: 0, lastIdx: -1 };
      groups[item.label].totalMasu += (item.w / GRID_SIZE) * (item.h / GRID_SIZE);
      if (index > groups[item.label].lastIdx) {
        groups[item.label].textX = item.x + item.w/2;
        groups[item.label].textY = item.y + item.h/2;
        groups[item.label].lastIdx = index;
      }
    }

    for (let x = item.x; x < item.x + item.w; x += sub) {
      for (let y = item.y; y < item.y + item.h; y += sub) {
        const pos = `${x},${y}`;
        if (item.type === 'frame') frameMap[pos] = item.label;
        else roomMap[pos] = { label: item.label, color: item.color };
      }
    }
  });

  items.forEach(item => {
    ctx.fillStyle = item.type === 'frame' ? "#f8f8f8" : item.color;
    ctx.fillRect(item.x, item.y, item.w, item.h);
  });

  const drawEdge = (map, color, width) => {
    ctx.strokeStyle = color;
    ctx.lineWidth = width;
    for (const pos in map) {
      const [x, y] = pos.split(',').map(Number);
      const label = map[pos].label || map[pos];
      [{dx:0, dy:-sub}, {dx:0, dy:sub}, {dx:-sub, dy:0}, {dx:sub, dy:0}].forEach(d => {
        if ((map[`${x+d.dx},${y+d.dy}`]?.label || map[`${x+d.dx},${y+d.dy}`]) !== label) {
          ctx.beginPath();
          if(d.dy!==0){
            ctx.moveTo(x, y+(d.dy>0?sub:0));
            ctx.lineTo(x+sub, y+(d.dy>0?sub:0));
          } else {
            ctx.moveTo(x+(d.dx>0?sub:0), y);
            ctx.lineTo(x+(d.dx>0?sub:0), y+sub);
          }
          ctx.stroke();
        }
      });
    }
  };

  drawEdge(roomMap, "#333", 2);
  drawEdge(frameMap, "#111", 6);

  for (const key in groups) {
    const g = groups[key];
    ctx.fillStyle = "#111";
    ctx.textAlign = "center";
    ctx.font = "bold 14px sans-serif";
    ctx.fillText(g.label, g.textX, g.textY - 4);

    let subText = "";
    if (el('showJou').checked) subText += `${(g.totalMasu/2).toFixed(1)}ç•³ `;
    if (el('showTsubo').checked) subText += `${(g.totalMasu/4).toFixed(2)}åª`;

    ctx.font = "11px sans-serif";
    ctx.fillText(subText, g.textX, g.textY + 12);
    ctx.textAlign = "left";
  }
}

window.draw = function(){
  ctx.save();
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  ctx.translate(canvas.width/2 + camera.x, canvas.height/2 + camera.y);

  // grid
  ctx.strokeStyle = "#e5e5ea";
  ctx.lineWidth = 0.5;
  for (let x = -1600; x <= 1600; x += GRID_SIZE) {
    ctx.beginPath(); ctx.moveTo(x, -1600); ctx.lineTo(x, 1600); ctx.stroke();
  }
  for (let y = -1600; y <= 1600; y += GRID_SIZE) {
    ctx.beginPath(); ctx.moveTo(-1600, y); ctx.lineTo(1600, y); ctx.stroke();
  }

  if (isMerged) drawMerged();
  else drawNormal();

  // selection box
  if (selectedItem && !(isMerged && selectedItem.type === 'frame')) {
    ctx.strokeStyle = "#007AFF";
    ctx.lineWidth = 3;
    ctx.strokeRect(selectedItem.x, selectedItem.y, selectedItem.w, selectedItem.h);

    if (isDragging || isResizing) {
      const mw = (selectedItem.w / GRID_SIZE).toFixed(1).replace('.0','');
      const mh = (selectedItem.h / GRID_SIZE).toFixed(1).replace('.0','');
      ctx.fillStyle = "rgba(0, 122, 255, 0.9)";
      ctx.fillRect(selectedItem.x, selectedItem.y - 30, 70, 24);
      ctx.fillStyle = "#fff";
      ctx.font = "bold 14px sans-serif";
      ctx.fillText(`${mw} Ã— ${mh}`, selectedItem.x + 5, selectedItem.y - 12);
    }

    // resize handle
    ctx.fillStyle = "#fff";
    ctx.strokeStyle = "#007AFF";
    ctx.beginPath();
    ctx.arc(selectedItem.x + selectedItem.w, selectedItem.y + selectedItem.h, 16, 0, Math.PI*2);
    ctx.fill(); ctx.stroke();
  }

  ctx.restore();
  updateSummary();
  syncBottomBarState();
};

function init(){
  resizeCanvas();
  window.addEventListener('resize', resizeCanvas);

  // segmented
  el('segEdit').onclick = () => setMergedMode(false);
  el('segMerge').onclick = () => setMergedMode(true);

  // URL param
  const params = new URLSearchParams(window.location.search);
  const id = params.get('id');
  layoutId = id || null;

  if (layoutId) {
    getDoc(doc(db, "layouts", layoutId)).then(snap => {
      if (snap.exists()) {
        const data = snap.data();
        items = data.items || [];
        isMerged = !!data.isMerged;
        updateSegmentUI();
        draw();
      } else {
        addFunc('å¤–æ ', 10, 10, '#f8f8f8', 'frame');
        updateSegmentUI();
      }
    });
  } else {
    addFunc('å¤–æ ', 10, 10, '#f8f8f8', 'frame');
    updateSegmentUI();
  }
}

/* ===== Top actions ===== */
el('openHelpBtn').onclick = () => el('helpModal').style.display = 'flex';
el('helpModal').onclick = () => el('helpModal').style.display = 'none';

el('saveBtn').onclick = async () => {
  // â˜…æ–°è¦ä½œæˆï¼šidãŒç„¡ã„ãªã‚‰ä½œã£ã¦URLã‚’æ›´æ–°ï¼ˆä»¥å¾Œã¯åŒã˜URLã«ä¸Šæ›¸ãï¼‰
  if (!layoutId) {
    const r = await addDoc(collection(db, "layouts"), { items, isMerged, updatedAt: new Date() });
    layoutId = r.id;

    const newUrl = `${window.location.origin}${window.location.pathname}?id=${layoutId}`;
    history.replaceState(null, "", newUrl);
  }

  // â˜…ä¸Šæ›¸ãä¿å­˜
  await setDoc(doc(db, "layouts", layoutId), { items, isMerged, updatedAt: new Date() }, { merge: true });

  el('shareUrlInput').value = `${window.location.origin}${window.location.pathname}?id=${layoutId}`;
  el('saveModal').style.display = 'flex';
};

el('copyUrlBtn').onclick = () => {
  navigator.clipboard.writeText(el('shareUrlInput').value);
  alert("ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ");
};
el('closeSaveModalBtn').onclick = () => el('saveModal').style.display = 'none';

el('colorPicker').oninput = (e) => {
  if(selectedItem){
    selectedItem.color = e.target.value;
    draw();
  }
};

el('centerBtn').onclick = () => { camera = { x: 0, y: 0 }; draw(); };
el('fitBtn').onclick = fitToFrame;

document.querySelectorAll('input[type="checkbox"]').forEach(c => c.onchange = draw);

/* ===== Bottom actions ===== */
el('addGenericRoomBtn2').onclick = () => {
  const n = prompt("éƒ¨å±‹å", "æ´‹å®¤");
  if (n) addFunc(n, 4, 4, '#FFF3E0', 'room');
};
el('addFrameBtn2').onclick = () => addFunc('å¤–æ ', 10, 10, '#f8f8f8', 'frame');
el('addWallBtn2').onclick = () => addFunc('å£', 1, 4, '#616161', 'wall');

el('copyBtn2').onclick = () => {
  if(selectedItem){
    const i = { ...selectedItem, x: selectedItem.x + GRID_SIZE, y: selectedItem.y + GRID_SIZE };
    items.push(i);
    selectedItem = i;
    draw();
  }
};

el('resetBtn2').onclick = () => {
  if(selectedItem){
    items = items.filter(i => i !== selectedItem);
    selectedItem = null;
  } else if(confirm("å…¨æ¶ˆå»ã—ã¾ã™ã‹ï¼Ÿ")) {
    items = [];
    addFunc('å¤–æ ', 10, 10, '#f8f8f8', 'frame');
  }
  draw();
};

/* ===== Touch interactions ===== */
canvas.addEventListener('touchstart', e => {
  const now = Date.now();
  const rect = canvas.getBoundingClientRect();
  const p = { x: e.touches[0].clientX - rect.left, y: e.touches[0].clientY - rect.top };
  const worldP = { x: p.x - canvas.width/2 - camera.x, y: p.y - canvas.height/2 - camera.y };

  // double tap rename (only in edit mode)
  if (now - lastTapTime < 300 && selectedItem && !isMerged) {
    const n = prompt("åå‰å¤‰æ›´", selectedItem.label);
    if(n) { selectedItem.label = n; draw(); }
    return;
  }
  lastTapTime = now;

  // resize handle
  if(selectedItem && !(isMerged && selectedItem.type==='frame')
     && Math.abs(worldP.x-(selectedItem.x+selectedItem.w))<30
     && Math.abs(worldP.y-(selectedItem.y+selectedItem.h))<30){
    isResizing = true;
    return;
  }

  // hit test
  let found = null;
  for (let i = items.length-1; i >= 0; i--) {
    if (!isMerged || items[i].type !== 'frame') {
      const it = items[i];
      if (worldP.x >= it.x && worldP.x <= it.x+it.w && worldP.y >= it.y && worldP.y <= it.y+it.h) {
        found = it; break;
      }
    }
  }

  if(found){
    selectedItem = found;
    items.splice(items.indexOf(found), 1);
    items.push(found);
    startX = worldP.x - found.x;
    startY = worldP.y - found.y;
    isDragging = true;
  } else {
    selectedItem = null;
    dragStart = { x: e.touches[0].clientX, y: e.touches[0].clientY };
    lastCamera = { ...camera };
  }
  draw();
});

canvas.addEventListener('touchmove', e => {
  e.preventDefault();
  const rect = canvas.getBoundingClientRect();
  const p = { x: e.touches[0].clientX - rect.left, y: e.touches[0].clientY - rect.top };
  const worldP = { x: p.x - canvas.width/2 - camera.x, y: p.y - canvas.height/2 - camera.y };

  const snap = el('useHalfGrid').checked ? 16 : 32;

  if (isResizing && selectedItem) {
    selectedItem.w = Math.max(snap, getSnapped(worldP.x - selectedItem.x, snap));
    selectedItem.h = Math.max(snap, getSnapped(worldP.y - selectedItem.y, snap));
  } else if (isDragging && selectedItem) {
    selectedItem.x = getSnapped(worldP.x - startX, snap);
    selectedItem.y = getSnapped(worldP.y - startY, snap);
  } else if (dragStart) {
    camera.x = lastCamera.x + (e.touches[0].clientX - dragStart.x);
    camera.y = lastCamera.y + (e.touches[0].clientY - dragStart.y);
  }
  draw();
});

canvas.addEventListener('touchend', () => {
  isResizing = false;
  isDragging = false;
  dragStart = null;
  draw();
});

init();
</script>
</body>
</html>
