<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>間取りシミュレーター v3.1</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; margin: 0; background: #f0f2f5; touch-action: none; display: flex; flex-direction: column; height: 100vh; overflow: hidden; }
        
        /* ツールバー */
        .toolbar { padding: 8px 12px; background: #fff; display: flex; flex-wrap: wrap; gap: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.05); z-index: 10; align-items: center; justify-content: center; }
        
        button { padding: 6px 10px; font-size: 12px; border: none; border-radius: 6px; background: #007AFF; color: white; font-weight: bold; cursor: pointer; white-space: nowrap; transition: transform 0.1s; }
        button:active { transform: scale(0.96); }
        
        /* ボタン色分け */
        .btn-frame { background: #333; }
        .btn-merge { background: #5856d6; }
        .btn-room-ldk { background: #4FC3F7; color: #004D40; }
        .btn-room-bath { background: #0288D1; color: #fff; }
        .btn-kitchen { background: #FF7043; color: #fff; }
        .btn-wall { background: #616161; color: #fff; }
        .btn-copy { background: #34c759; }
        .btn-delete { background: #ff3b30; }
        .btn-save { background: #FF9500; }

        /* カラーピッカー周り */
        .color-control { display: flex; align-items: center; gap: 4px; background: #eee; padding: 4px 8px; border-radius: 4px; border: 1px solid #ccc; }
        input[type="color"] { border: none; width: 24px; height: 24px; cursor: pointer; background: none; padding: 0; }

        .summary-bar { background: #222; color: #fff; padding: 6px 12px; font-size: 11px; display: flex; justify-content: space-around; align-items: center; border-top: 1px solid #444; }
        .total-highlight { color: #FFD60A; font-size: 1.1em; font-weight: bold; }
        
        .config { padding: 6px 12px; background: #E5E5EA; display: flex; overflow-x: auto; align-items: center; gap: 10px; font-size: 11px; border-bottom: 1px solid #ccc; white-space: nowrap; -webkit-overflow-scrolling: touch; }
        .config label { display: flex; align-items: center; gap: 4px; padding: 4px 8px; border-radius: 12px; background: #fff; box-shadow: 0 1px 2px rgba(0,0,0,0.1); }
        
        #canvas-container { flex: 1; position: relative; overflow: hidden; background: #fff; width: 100%; }
        canvas { display: block; touch-action: none; }
        
        /* モーダル */
        .modal-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 100; justify-content: center; align-items: center; }
        .modal-box { background: #fff; padding: 20px; border-radius: 12px; width: 85%; max-width: 350px; text-align: center; }
        .url-input { width: 100%; padding: 8px; margin: 10px 0; font-size: 14px; border: 1px solid #ddd; border-radius: 4px; background: #f9f9f9; }
    </style>
</head>
<body>

    <div id="loading" class="modal-overlay" style="z-index: 101;"><div style="color:#fff; font-weight:bold;">読み込み中...</div></div>

    <div id="saveModal" class="modal-overlay">
        <div class="modal-box">
            <h3 style="margin-top:0;">共有リンクを作成しました</h3>
            <p style="font-size:12px; color:#666;">このURLをコピーして共有してください</p>
            <input type="text" id="shareUrlInput" class="url-input" readonly onclick="this.select()">
            <div style="display:flex; gap:10px; justify-content: center;">
                <button onclick="copyToClipboard()">コピー</button>
                <button style="background:#8E8E93" onclick="closeModal()">閉じる</button>
            </div>
        </div>
    </div>

    <div class="toolbar">
        <button class="btn-frame" onclick="addFrame()">+外枠</button>
        <button class="btn-room-ldk" onclick="addRoom('LDK', 6, 6, '#E1F5FE')">+LDK</button>
        <button onclick="addRoom('洋室', 4, 4, '#FFF3E0')">+洋室</button>
        <button class="btn-room-bath" onclick="addRoom('浴室', 2, 2, '#B3E5FC')">+浴室</button>
        <button class="btn-kitchen" onclick="addRoom('キッチン', 3, 1, '#FFCCBC')">+キッチン</button>
        <button class="btn-wall" onclick="addWall()">+壁/PS</button>
        
        <div class="color-control">
            <span style="font-size:11px; font-weight:bold; color:#555;">色:</span>
            <input type="color" id="colorPicker" value="#ffffff" onchange="changeColor()" title="選択中のアイテムの色を変更">
        </div>

        <button id="mergeBtn" class="btn-merge" onclick="toggleMerge()">結合</button>
        <button class="btn-copy" onclick="duplicateItem()">複製</button>
        <button onclick="renameItem()">名前</button>
        <button class="btn-delete" onclick="deleteItem()">削除</button>
        <button class="btn-save" onclick="saveLayout()">保存/共有</button>
    </div>

    <div class="summary-bar">
        <span>延床: <span id="totalTsubo" class="total-highlight">0.00</span> 坪</span>
        <span>(<span id="totalHeibe">0.00</span> ㎡)</span>
        <span><span id="totalJou">0.0</span> 畳</span>
    </div>

    <div class="config">
        <label><input type="checkbox" id="showMasu" checked onchange="draw()">マス</label>
        <label><input type="checkbox" id="showJou" checked onchange="draw()">畳</label>
        <label><input type="checkbox" id="showMeter" checked onchange="draw()">m</label>
        <label><input type="checkbox" id="showHeibe" onchange="draw()">㎡</label>
        <label><input type="checkbox" id="showTsubo" onchange="draw()">坪</label>
    </div>

    <div id="canvas-container">
        <canvas id="canvas"></canvas>
    </div>

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const container = document.getElementById('canvas-container');
    const colorPicker = document.getElementById('colorPicker');
    
    // 設定
    const GRID_SIZE = 32;       
    const HANDLE_SIZE = 20;     
    const MODULE = 0.91;        

    let items = [];
    let selectedItem = null;
    let isResizing = false;
    let isMerged = false;
    let startX, startY;

    function init() {
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        const params = new URLSearchParams(window.location.search);
        const dataStr = params.get('data');

        if (dataStr) {
            document.getElementById('loading').style.display = 'flex';
            setTimeout(() => {
                try {
                    const jsonStr = decodeURIComponent(escape(atob(dataStr)));
                    const data = JSON.parse(jsonStr);
                    
                    if (data.items) items = data.items;
                    if (typeof data.isMerged !== 'undefined') {
                        isMerged = data.isMerged;
                        const btn = document.getElementById('mergeBtn');
                        btn.innerText = isMerged ? "結合解除" : "結合";
                        btn.style.background = isMerged ? "#8e8e93" : "#5856d6";
                    }
                    draw();
                } catch (e) {
                    console.error("データ読み込みエラー:", e);
                    addFrame();
                } finally {
                    document.getElementById('loading').style.display = 'none';
                }
            }, 100);
        } else {
            addFrame();
        }
    }

    function resizeCanvas() {
        canvas.width = container.clientWidth;
        canvas.height = container.clientHeight;
        draw();
    }

    function addRoom(label, w, h, color) {
        const cx = Math.floor((canvas.width/2)/GRID_SIZE)*GRID_SIZE;
        const cy = Math.floor((canvas.height/2)/GRID_SIZE)*GRID_SIZE;
        const newItem = { type: 'room', x: cx, y: cy, w: w*GRID_SIZE, h: h*GRID_SIZE, label: label, color: color };
        items.push(newItem);
        selectedItem = newItem; 
        updateColorPicker(color);
        draw();
    }
    function addFrame() {
        const cx = Math.floor((canvas.width/2)/GRID_SIZE)*GRID_SIZE - GRID_SIZE*2;
        const cy = Math.floor((canvas.height/2)/GRID_SIZE)*GRID_SIZE - GRID_SIZE*2;
        items.unshift({ type: 'frame', x: cx, y: cy, w: 6*GRID_SIZE, h: 6*GRID_SIZE, label: '外枠', color: '#f8f8f8' });
        selectedItem = items[0]; 
        updateColorPicker('#f8f8f8');
        draw();
    }
    function addWall() {
        const cx = Math.floor((canvas.width/2)/GRID_SIZE)*GRID_SIZE;
        const cy = Math.floor((canvas.height/2)/GRID_SIZE)*GRID_SIZE;
        const newItem = { type: 'wall', x: cx, y: cy, w: 1*GRID_SIZE, h: 2*GRID_SIZE, label: '壁', color: '#555555' };
        items.push(newItem);
        selectedItem = newItem;
        updateColorPicker('#555555');
        draw();
    }

    function changeColor() {
        if (selectedItem) {
            selectedItem.color = colorPicker.value;
            draw();
        }
    }
    function updateColorPicker(color) {
        colorPicker.value = color;
    }

    function duplicateItem() {
        if (!selectedItem) return alert("選択してください");
        const newItem = { ...selectedItem, x: selectedItem.x + GRID_SIZE, y: selectedItem.y + GRID_SIZE };
        items.push(newItem); selectedItem = newItem; draw();
    }
    function renameItem() {
        if (!selectedItem) return alert("選択してください");
        const newName = prompt("名前を変更", selectedItem.label);
        if (newName !== null) { selectedItem.label = newName; draw(); }
    }
    function deleteItem() {
        if (selectedItem) { items = items.filter(i => i !== selectedItem); selectedItem = null; draw(); }
    }
    function toggleMerge() {
        isMerged = !isMerged;
        const btn = document.getElementById('mergeBtn');
        btn.innerText = isMerged ? "結合解除" : "結合";
        btn.style.background = isMerged ? "#8e8e93" : "#5856d6";
        selectedItem = null; draw();
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const showJou = document.getElementById('showJou').checked;
        const showTsubo = document.getElementById('showTsubo').checked;
        const showHeibe = document.getElementById('showHeibe').checked;
        const showMeter = document.getElementById('showMeter').checked;
        const showMasu = document.getElementById('showMasu').checked;

        // グリッド
        ctx.strokeStyle = "#eef0f2"; ctx.lineWidth = 1;
        for (let x=0; x<=canvas.width; x+=GRID_SIZE) { ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,canvas.height); ctx.stroke(); }
        for (let y=0; y<=canvas.height; y+=GRID_SIZE) { ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(canvas.width,y); ctx.stroke(); }

        let totalMasu = 0;
        let roomMap = new Map();
        let frameMap = new Set();
        let groupedRooms = {};

        items.forEach(item => {
            const gw = Math.round(item.w/GRID_SIZE), gh = Math.round(item.h/GRID_SIZE);
            const gx = Math.round(item.x/GRID_SIZE), gy = Math.round(item.y/GRID_SIZE);

            if (item.type === 'frame') {
                totalMasu += gw*gh;
                for(let x=0; x<gw; x++) for(let y=0; y<gh; y++) frameMap.add(`${gx+x},${gy+y}`);
            } else if (item.type === 'room') {
                if (!groupedRooms[item.label]) groupedRooms[item.label] = { totalMasu: 0, largestItem: item, maxArea: 0 };
                const area = gw*gh;
                groupedRooms[item.label].totalMasu += area;
                if (area > groupedRooms[item.label].maxArea) {
                    groupedRooms[item.label].largestItem = item;
                    groupedRooms[item.label].maxArea = area;
                }
                for(let x=0; x<gw; x++) for(let y=0; y<gh; y++) roomMap.set(`${gx+x},${gy+y}`, item);
            }
        });

        if (isMerged) {
            // 結合時の塗りつぶし
            ctx.fillStyle = "#f4f4f4";
            frameMap.forEach(key => { const [gx,gy] = key.split(',').map(Number); ctx.fillRect(gx*GRID_SIZE, gy*GRID_SIZE, GRID_SIZE, GRID_SIZE); });

            // 結合時の太枠描画（外壁線）
            ctx.strokeStyle = "#333";
            ctx.lineWidth = 3;
            ctx.beginPath();
            frameMap.forEach(key => {
                const [gx, gy] = key.split(',').map(Number);
                // 上
                if (!frameMap.has(`${gx},${gy-1}`)) { ctx.moveTo(gx*GRID_SIZE, gy*GRID_SIZE); ctx.lineTo((gx+1)*GRID_SIZE, gy*GRID_SIZE); }
                // 下
                if (!frameMap.has(`${gx},${gy+1}`)) { ctx.moveTo(gx*GRID_SIZE, (gy+1)*GRID_SIZE); ctx.lineTo((gx+1)*GRID_SIZE, (gy+1)*GRID_SIZE); }
                // 左
                if (!frameMap.has(`${gx-1},${gy}`)) { ctx.moveTo(gx*GRID_SIZE, gy*GRID_SIZE); ctx.lineTo(gx*GRID_SIZE, (gy+1)*GRID_SIZE); }
                // 右
                if (!frameMap.has(`${gx+1},${gy}`)) { ctx.moveTo((gx+1)*GRID_SIZE, gy*GRID_SIZE); ctx.lineTo((gx+1)*GRID_SIZE, (gy+1)*GRID_SIZE); }
            });
            ctx.stroke();

        } else {
            // 通常時の外枠
            items.filter(i => i.type === 'frame').forEach(item => { ctx.fillStyle = item.color; ctx.fillRect(item.x, item.y, item.w, item.h); });
        }

        // 部屋
        roomMap.forEach((item, key) => {
            const [gx, gy] = key.split(',').map(Number);
            ctx.fillStyle = item.color; 
            ctx.globalAlpha = 0.85; 
            ctx.fillRect(gx*GRID_SIZE, gy*GRID_SIZE, GRID_SIZE, GRID_SIZE); 
            ctx.globalAlpha = 1.0;
        });

        // 壁
        items.filter(i => i.type === 'wall').forEach(item => {
            ctx.fillStyle = item.color;
            ctx.fillRect(item.x, item.y, item.w, item.h);
        });

        // 未結合時の点線枠
        if (!isMerged) {
            items.filter(i => i.type === 'frame').forEach(item => {
                ctx.strokeStyle = (selectedItem === item) ? "#007AFF" : "#bbb";
                ctx.lineWidth = 1; ctx.setLineDash([4, 2]); ctx.strokeRect(item.x, item.y, item.w, item.h); ctx.setLineDash([]);
                drawItemText(ctx, item, Math.round(item.w/GRID_SIZE)*Math.round(item.h/GRID_SIZE), true, showMeter, showJou, showTsubo, showHeibe, showMasu);
            });
        }
        
        // 部屋の境界線
        ctx.lineWidth = 1.5; ctx.strokeStyle = "#444";
        roomMap.forEach((item, key) => {
            const [gx, gy] = key.split(',').map(Number);
            const check = (dx, dy) => { const n = roomMap.get(`${gx+dx},${gy+dy}`); return !n || n.label !== item.label; };
            ctx.beginPath();
            if (check(1,0)) { ctx.moveTo((gx+1)*GRID_SIZE, gy*GRID_SIZE); ctx.lineTo((gx+1)*GRID_SIZE, (gy+1)*GRID_SIZE); }
            if (check(-1,0)) { ctx.moveTo(gx*GRID_SIZE, gy*GRID_SIZE); ctx.lineTo(gx*GRID_SIZE, (gy+1)*GRID_SIZE); }
            if (check(0,1)) { ctx.moveTo(gx*GRID_SIZE, (gy+1)*GRID_SIZE); ctx.lineTo((gx+1)*GRID_SIZE, (gy+1)*GRID_SIZE); }
            if (check(0,-1)) { ctx.moveTo(gx*GRID_SIZE, gy*GRID_SIZE); ctx.lineTo((gx+1)*GRID_SIZE, gy*GRID_SIZE); }
            ctx.stroke();
        });

        // 選択ハンドルの描画
        if (selectedItem) {
            const item = selectedItem;
            if (!(isMerged && item.type === 'frame')) {
                ctx.strokeStyle = "#FF3B30"; ctx.lineWidth = 2; ctx.strokeRect(item.x, item.y, item.w, item.h);
                ctx.fillStyle = "#FF3B30"; ctx.beginPath(); ctx.arc(item.x + item.w, item.y + item.h, HANDLE_SIZE/2, 0, Math.PI * 2); ctx.fill();
            }
        }

        // テキスト描画
        Object.values(groupedRooms).forEach(group => {
            drawItemText(ctx, group.largestItem, group.totalMasu, false, showMeter, showJou, showTsubo, showHeibe, showMasu);
        });
        
        // 壁のラベル
        items.filter(i => i.type === 'wall' && (i.w>GRID_SIZE || i.h>GRID_SIZE)).forEach(item => {
             ctx.fillStyle = "#fff"; ctx.font = "bold 11px sans-serif"; ctx.fillText(item.label, item.x+2, item.y+12);
        });

        document.getElementById('totalTsubo').innerText = (totalMasu / 4).toFixed(2);
        document.getElementById('totalHeibe').innerText = (totalMasu * MODULE * MODULE).toFixed(2);
        document.getElementById('totalJou').innerText = (totalMasu / 2).toFixed(1);
    }

    // テキスト描画関数（㎡・坪の処理を追加）
    function drawItemText(ctx, item, totalM, isFrame, sMeter, sJou, sTsubo, sHeibe, sMasu) {
        if (!item) return;
        let textY = item.y + 16;
        const c = item.color.replace('#','');
        const r = parseInt(c.substr(0,2),16), g = parseInt(c.substr(2,2),16), b = parseInt(c.substr(4,2),16);
        const isDark = (r*0.299 + g*0.587 + b*0.114) < 140;

        ctx.fillStyle = isDark ? "#fff" : (isFrame ? "#666" : "#000");
        ctx.font = "bold 12px sans-serif";
        ctx.fillText(item.label, item.x + 4, textY);
        
        if (item.h <= GRID_SIZE && item.w <= GRID_SIZE*3) return;

        ctx.font = "10px sans-serif";
        const gw = Math.round(item.w/GRID_SIZE), gh = Math.round(item.h/GRID_SIZE);
        
        if (sMeter) {
            textY += 12; ctx.fillStyle = "#007AFF"; if(isDark) ctx.fillStyle="#81D4FA";
            ctx.fillText(`${(gw*MODULE).toFixed(2)}×${(gh*MODULE).toFixed(2)}`, item.x + 4, textY);
            ctx.fillStyle = isDark ? "#fff" : (isFrame ? "#666" : "#000");
        }
        if (sMasu) { textY += 12; ctx.fillText(`${gw}×${gh}マ`, item.x + 4, textY); }
        if (sJou) { textY += 12; ctx.fillText(`${(totalM/2).toFixed(1)}畳`, item.x + 4, textY); }
        
        // ここを追加：㎡と坪の描画処理
        if (sHeibe) {
            textY += 12;
            const m2 = totalM * MODULE * MODULE;
            ctx.fillText(`${m2.toFixed(2)}㎡`, item.x + 4, textY);
        }
        if (sTsubo) {
            textY += 12;
            const tsubo = totalM / 4;
            ctx.fillText(`${tsubo.toFixed(2)}坪`, item.x + 4, textY);
        }
    }

    function getPointerPos(e) {
        const rect = canvas.getBoundingClientRect();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        return { x: clientX - rect.left, y: clientY - rect.top };
    }
    function handleStart(x, y) {
        if (selectedItem && !(isMerged && selectedItem.type === 'frame')) {
            const hX = selectedItem.x + selectedItem.w, hY = selectedItem.y + selectedItem.h;
            if (Math.abs(x - hX) < HANDLE_SIZE*1.5 && Math.abs(y - hY) < HANDLE_SIZE*1.5) { isResizing = true; return; }
        }
        let found = items.slice().reverse().find(r => {
            if (isMerged && r.type === 'frame') return false;
            const m = (r.type==='wall')?10:0;
            return x >= r.x-m && x <= r.x+r.w+m && y >= r.y-m && y <= r.y+r.h+m;
        });
        if (found) { 
            selectedItem = found; startX = x - found.x; startY = y - found.y;
            updateColorPicker(found.color);
            if(found.type !== 'frame') { items = items.filter(i => i !== found); items.push(found); }
        } else { selectedItem = null; }
        draw();
    }
    function handleMove(x, y) {
        if (!selectedItem) return;
        if (isResizing) {
            let nw = Math.round((x - selectedItem.x)/GRID_SIZE)*GRID_SIZE;
            let nh = Math.round((y - selectedItem.y)/GRID_SIZE)*GRID_SIZE;
            selectedItem.w = Math.max(GRID_SIZE, nw); selectedItem.h = Math.max(GRID_SIZE, nh);
        } else {
            selectedItem.x = Math.round((x - startX)/GRID_SIZE)*GRID_SIZE;
            selectedItem.y = Math.round((y - startY)/GRID_SIZE)*GRID_SIZE;
        }
        draw();
    }

    canvas.addEventListener('mousedown', e => handleStart(getPointerPos(e).x, getPointerPos(e).y));
    canvas.addEventListener('mousemove', e => { if(e.buttons===1) handleMove(getPointerPos(e).x, getPointerPos(e).y); });
    canvas.addEventListener('mouseup', () => isResizing = false);
    canvas.addEventListener('touchstart', e => handleStart(getPointerPos(e).x, getPointerPos(e).y), {passive:false});
    canvas.addEventListener('touchmove', e => { e.preventDefault(); handleMove(getPointerPos(e).x, getPointerPos(e).y); }, {passive:false});
    canvas.addEventListener('touchend', () => isResizing = false);

    function saveLayout() {
        const data = { items: items, isMerged: isMerged };
        try {
            const jsonString = JSON.stringify(data);
            const encoded = btoa(unescape(encodeURIComponent(jsonString)));
            const baseUrl = window.location.protocol + "//" + window.location.host + window.location.pathname;
            const shareUrl = baseUrl + "?data=" + encoded;

            document.getElementById('shareUrlInput').value = shareUrl;
            document.getElementById('saveModal').style.display = 'flex';
        } catch(e) {
            console.error(e);
            alert("データ量が多すぎてURL化できませんでした。\n要素を減らして再度試してください。");
        }
    }

    function closeModal() { document.getElementById('saveModal').style.display = 'none'; }
    function copyToClipboard() {
        const i = document.getElementById('shareUrlInput'); i.select();
        if (navigator.clipboard) {
            navigator.clipboard.writeText(i.value).then(() => alert("コピーしました")).catch(() => {
                document.execCommand("copy");
                alert("コピーしました");
            });
        } else {
            document.execCommand("copy");
            alert("コピーしました");
        }
    }

    window.onload = init;
</script>
</body>
</html>