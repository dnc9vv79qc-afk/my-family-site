<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>間取りシミュレーター v4.8</title>
    <style>
        :root {
            --primary: #007AFF;
            --success: #34c759;
            --danger: #ff3b30;
            --warning: #FF9500;
            --bg: #f2f2f7;
            --card: #ffffff;
            --text: #1c1c1e;
        }
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; margin: 0; background: var(--bg); color: var(--text); touch-action: none; display: flex; flex-direction: column; height: 100vh; overflow: hidden; }
        
        .ver-label { position: fixed; top: 8px; right: 12px; font-size: 10px; color: #8e8e93; z-index: 100; pointer-events: none; font-weight: bold; }

        /* ツールバー */
        .toolbar { padding: 12px; background: var(--card); display: flex; flex-direction: column; gap: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.05); z-index: 10; border-bottom: 1px solid #d1d1d6; }
        .toolbar-row { display: flex; gap: 8px; overflow-x: auto; white-space: nowrap; align-items: center; padding-bottom: 4px; -webkit-overflow-scrolling: touch; }
        .toolbar-row::-webkit-scrollbar { display: none; }
        
        button { 
            height: 44px; padding: 0 16px; font-size: 14px; border: none; border-radius: 12px; 
            background: var(--primary); color: white; font-weight: 600; cursor: pointer; flex-shrink: 0;
            transition: transform 0.1s, opacity 0.1s; display: flex; align-items: center; justify-content: center;
        }
        button:active { transform: scale(0.96); opacity: 0.8; }
        .btn-frame { background: #3a3a3c; }
        .btn-merge { background: #5856d6; width: 100px; }
        .btn-delete { background: var(--danger); }
        .btn-save { background: var(--warning); }
        .btn-secondary { background: #8e8e93; }

        /* 設定パネル（スマホ最適化） */
        .config-panel { 
            padding: 10px 12px; background: #e5e5ea; display: flex; overflow-x: auto; gap: 8px; 
            border-bottom: 1px solid #c6c6c8; align-items: center;
        }
        .toggle-btn {
            background: #fff; border-radius: 10px; padding: 8px 12px; display: flex; align-items: center; gap: 6px;
            font-size: 12px; font-weight: 600; box-shadow: 0 1px 3px rgba(0,0,0,0.1); cursor: pointer;
        }
        .toggle-btn input { width: 18px; height: 18px; margin: 0; accent-color: var(--primary); }

        /* カラーピッカー */
        .color-selector {
            display: flex; align-items: center; background: #f2f2f7; padding: 2px 10px; border-radius: 12px; 
            height: 40px; border: 1px solid #d1d1d6; gap: 8px;
        }
        input[type="color"] { width: 32px; height: 32px; border: none; background: none; cursor: pointer; padding: 0; }

        /* サマリーバー */
        .summary { 
            background: #1c1c1e; color: #fff; padding: 12px; display: flex; justify-content: space-around; 
            font-size: 13px; font-weight: 500; border-bottom: 2px solid var(--warning);
        }
        .summary b { color: var(--warning); font-size: 1.2em; }

        /* キャンバス領域 */
        #canvas-container { flex: 1; position: relative; background: #fff; }
        canvas { display: block; touch-action: none; }

        /* 微調整コントロール（フローティング） */
        #nudge-controls { 
            position: absolute; bottom: 30px; right: 20px; display: none; flex-direction: column; 
            align-items: center; gap: 8px; background: rgba(255,255,255,0.75); backdrop-filter: blur(10px);
            padding: 12px; border-radius: 30px; box-shadow: 0 8px 24px rgba(0,0,0,0.15); z-index: 50;
        }
        .nudge-btn { width: 50px; height: 50px; border-radius: 25px; background: var(--primary); font-size: 22px; }

        /* モーダル */
        .modal-overlay { display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.6); z-index: 100; align-items: center; justify-content: center; padding: 20px; }
        .modal { background: #fff; padding: 24px; border-radius: 20px; width: 100%; max-width: 360px; text-align: center; }
    </style>
</head>
<body>
    <div class="ver-label">ver 4.8</div>
    
    <div class="toolbar">
        <div class="toolbar-row">
            <button class="btn-frame" onclick="addFrame()">+ 外枠</button>
            <button style="background: #4FC3F7; color: #004D40;" onclick="addRoom('LDK', 6, 6, '#E1F5FE')">+ LDK</button>
            <button style="background: #007AFF;" onclick="addRoom('洋室', 4, 4, '#FFF3E0')">+ 洋室</button>
            <button style="background: #0288D1;" onclick="addRoom('浴室', 2, 2, '#B3E5FC')">+ 浴室</button>
            <button style="background: #FF7043;" onclick="addRoom('キッチン', 3, 1, '#FFCCBC')">+ K</button>
            <div class="color-selector">
                <input type="color" id="colorPicker" value="#ffffff" oninput="changeColor()">
            </div>
        </div>
        <div class="toolbar-row">
            <button id="mergeBtn" class="btn-merge" onclick="toggleMerge()">結合モード</button>
            <button style="background: var(--success);" onclick="duplicateItem()">複製</button>
            <button onclick="renameItem()">名前</button>
            <button class="btn-delete" onclick="deleteItem()">削除</button>
            <button class="btn-save" onclick="saveLayout()">共有</button>
            <button class="btn-secondary" onclick="resetCanvas()">消去</button>
        </div>
    </div>

    <div class="summary">
        <span>延床: <b id="totalTsubo">0.00</b> 坪</span>
        <span>(<span id="totalHeibe">0.00</span> ㎡)</span>
        <span><b id="totalJou">0.0</b> 畳</span>
    </div>

    <div class="config-panel">
        <label class="toggle-btn"><input type="checkbox" id="useHalfGrid" onchange="draw()">半マス</label>
        <label class="toggle-btn"><input type="checkbox" id="showMasu" checked onchange="draw()">マス</label>
        <label class="toggle-btn"><input type="checkbox" id="showJou" checked onchange="draw()">畳</label>
        <label class="toggle-btn"><input type="checkbox" id="showTsubo" onchange="draw()">坪</label>
    </div>

    <div id="canvas-container">
        <canvas id="canvas"></canvas>
        <div id="nudge-controls">
            <button class="nudge-btn" onclick="nudgeItem(0, -1)">▲</button>
            <div style="display:flex; gap:8px;">
                <button class="nudge-btn" onclick="nudgeItem(-1, 0)">◀</button>
                <button class="nudge-btn" onclick="nudgeItem(1, 0)">▶</button>
            </div>
            <button class="nudge-btn" onclick="nudgeItem(0, 1)">▼</button>
        </div>
    </div>

    <div id="saveModal" class="modal-overlay">
        <div class="modal">
            <h3>共有URLを作成しました</h3>
            <input type="text" id="shareUrlInput" class="url-input" readonly onclick="this.select()">
            <div style="display:flex; gap:12px; margin-top:20px;">
                <button style="flex:1;" onclick="copyToClipboard()">URLをコピー</button>
                <button style="flex:1; background:#8e8e93;" onclick="closeModal()">閉じる</button>
            </div>
        </div>
    </div>

<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
    import { getFirestore, collection, addDoc, getDoc, doc } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

    const firebaseConfig = { apiKey: "AIzaSyBH4zoH5ZnfPcZmmXNvfeGOJz9__KkSMrg", authDomain: "test-55430.firebaseapp.com", projectId: "test-55430", storageBucket: "test-55430.firebasestorage.app", messagingSenderId: "742726212885", appId: "1:742726212885:web:597a48fc1ce0cb7f529d1c", measurementId: "G-PW24JY2LBP" };
    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const container = document.getElementById('canvas-container');
    const GRID_SIZE = 32; const SUB_GRID = 16; const MODULE = 0.91;
    let items = []; let selectedItem = null; let isResizing = false; let isMerged = false; let startX, startY;

    async function init() {
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        const params = new URLSearchParams(window.location.search);
        const planId = params.get('id');
        if (planId) {
            try {
                const docSnap = await getDoc(doc(db, "layouts", planId));
                if (docSnap.exists()) { items = docSnap.data().items; isMerged = docSnap.data().isMerged || false; updateMergeButtonUI(); draw(); }
                else { addFrame(); }
            } catch (e) { addFrame(); }
        } else { addFrame(); }
    }

    function resizeCanvas() { canvas.width = container.clientWidth; canvas.height = container.clientHeight; draw(); }

    window.draw = function() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.strokeStyle = "#e5e5ea"; ctx.lineWidth = 1;
        for (let x=0; x<=canvas.width; x+=GRID_SIZE) { ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,canvas.height); ctx.stroke(); }
        for (let y=0; y<=canvas.height; y+=GRID_SIZE) { ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(canvas.width,y); ctx.stroke(); }

        if (isMerged) { drawMergedLayout(); } else { drawNormalLayout(); }

        if (selectedItem && !(isMerged && selectedItem.type === 'frame')) {
            ctx.strokeStyle = "#007AFF"; ctx.lineWidth = 3; ctx.strokeRect(selectedItem.x, selectedItem.y, selectedItem.w, selectedItem.h);
            ctx.fillStyle = "#fff"; ctx.strokeStyle = "#007AFF"; ctx.beginPath(); ctx.arc(selectedItem.x + selectedItem.w, selectedItem.y + selectedItem.h, 18, 0, Math.PI*2); ctx.fill(); ctx.stroke();
            drawSizeTooltip(selectedItem);
        }
        updateSummary();
    }

    function drawNormalLayout() {
        items.forEach(item => {
            ctx.fillStyle = item.color; ctx.globalAlpha = item.type==='room' ? 0.8 : 1.0;
            ctx.fillRect(item.x, item.y, item.w, item.h); ctx.globalAlpha = 1.0;
            ctx.strokeStyle = item.type === 'frame' ? "#c7c7cc" : "#3a3a3c"; ctx.lineWidth = 1; ctx.strokeRect(item.x, item.y, item.w, item.h);
            drawItemText(item, true);
        });
    }

    function drawMergedLayout() {
        const roomMap = {}; const frameMap = {}; const groups = {};
        const showJou = document.getElementById('showJou').checked;
        const showTsubo = document.getElementById('showTsubo').checked;

        items.forEach((item, index) => {
            if (item.type !== 'frame') {
                if (!groups[item.label]) groups[item.label] = { label: item.label, totalMasu: 0, textX: 0, textY: 0, lastIndex: -1 };
                groups[item.label].totalMasu += (item.w / GRID_SIZE) * (item.h / GRID_SIZE);
                if (index > groups[item.label].lastIndex) { groups[item.label].textX = item.x + item.w / 2; groups[item.label].textY = item.y + item.h / 2; groups[item.label].lastIndex = index; }
            }
            for (let x = item.x; x < item.x + item.w; x += SUB_GRID) {
                for (let y = item.y; y < item.y + item.h; y += SUB_GRID) {
                    const pos = `${x},${y}`;
                    if (item.type === 'frame') frameMap[pos] = item.label;
                    else roomMap[pos] = { label: item.label, color: item.color };
                }
            }
        });

        items.forEach(item => {
            ctx.fillStyle = item.type === 'frame' ? "#f2f2f7" : item.color;
            ctx.fillRect(item.x, item.y, item.w, item.h);
        });

        ctx.lineWidth = 2; ctx.strokeStyle = "#3a3a3c";
        for (const pos in roomMap) {
            const [x, y] = pos.split(',').map(Number);
            const current = roomMap[pos];
            const checks = [{dx:0, dy:-SUB_GRID, x1:x, y1:y, x2:x+SUB_GRID, y2:y}, {dx:0, dy:SUB_GRID, x1:x, y1:y+SUB_GRID, x2:x+SUB_GRID, y2:y+SUB_GRID}, {dx:-SUB_GRID, dy:0, x1:x, y1:y, x2:x, y2:y+SUB_GRID}, {dx:SUB_GRID, dy:0, x1:x+SUB_GRID, y1:y, x2:x+SUB_GRID, y2:y+SUB_GRID}];
            checks.forEach(d => {
                const neighbor = roomMap[`${x+d.dx},${y+d.dy}`];
                if (!neighbor || neighbor.label !== current.label) { ctx.beginPath(); ctx.moveTo(d.x1, d.y1); ctx.lineTo(d.x2, d.y2); ctx.stroke(); }
            });
        }

        ctx.lineWidth = 4; ctx.strokeStyle = "#1c1c1e";
        for (const pos in frameMap) {
            const [x, y] = pos.split(',').map(Number);
            const currentLabel = frameMap[pos];
            const checks = [{dx:0, dy:-SUB_GRID, x1:x, y1:y, x2:x+SUB_GRID, y2:y}, {dx:0, dy:SUB_GRID, x1:x, y1:y+SUB_GRID, x2:x+SUB_GRID, y2:y+SUB_GRID}, {dx:-SUB_GRID, dy:0, x1:x, y1:y, x2:x, y2:y+SUB_GRID}, {dx:SUB_GRID, dy:0, x1:x+SUB_GRID, y1:y, x2:x+SUB_GRID, y2:y+SUB_GRID}];
            checks.forEach(c => {
                const neighborLabel = frameMap[`${x+c.dx},${y+c.dy}`];
                if (!neighborLabel || neighborLabel !== currentLabel) { ctx.beginPath(); ctx.moveTo(c.x1, c.y1); ctx.lineTo(c.x2, c.y2); ctx.stroke(); }
            });
        }

        for (const key in groups) { 
            const g = groups[key];
            ctx.fillStyle = "#1c1c1e"; ctx.textAlign = "center"; ctx.font = "bold 14px sans-serif";
            ctx.fillText(g.label, g.textX, g.textY - 5);
            ctx.font = "11px sans-serif";
            let subText = "";
            if (showJou) subText += `${(g.totalMasu/2).toFixed(1)}畳 `;
            if (showTsubo) subText += `${(g.totalMasu/4).toFixed(2)}坪`;
            ctx.fillText(subText, g.textX, g.textY + 12);
            ctx.textAlign = "left";
        }
    }

    function drawItemText(item, forceDetails) {
        if (item.w < 16 || item.h < 16 || item.type === 'frame') return;
        const showJou = document.getElementById('showJou').checked;
        const showTsubo = document.getElementById('showTsubo').checked;
        const areaMasu = (item.w/GRID_SIZE) * (item.h/GRID_SIZE);
        ctx.fillStyle = "#1c1c1e"; ctx.font = "bold 13px sans-serif";
        let ty = item.y + 16; ctx.fillText(item.label, item.x + 6, ty);
        if (!forceDetails) return;
        ctx.font = "10px sans-serif";
        if (showJou) { ty += 13; ctx.fillText(`${(areaMasu/2).toFixed(1)}畳`, item.x+6, ty); }
        if (showTsubo) { ty += 13; ctx.fillText(`${(areaMasu/4).toFixed(2)}坪`, item.x+6, ty); }
    }

    function drawSizeTooltip(item) {
        if (!document.getElementById('showMasu').checked) return;
        const text = `${item.w/GRID_SIZE} × ${item.h/GRID_SIZE}`;
        ctx.font = "bold 12px sans-serif"; const tw = ctx.measureText(text).width;
        ctx.fillStyle = "rgba(0,122,255,0.95)"; ctx.beginPath(); ctx.roundRect(item.x, item.y - 36, tw + 16, 28, 8); ctx.fill();
        ctx.fillStyle = "#fff"; ctx.fillText(text, item.x + 8, item.y - 17);
    }

    function updateSummary() {
        let totalMasu = 0; items.forEach(item => { if(item.type === 'frame') totalMasu += (item.w/GRID_SIZE)*(item.h/GRID_SIZE); });
        document.getElementById('totalTsubo').innerText = (totalMasu / 4).toFixed(2);
        document.getElementById('totalHeibe').innerText = (totalMasu * MODULE * MODULE).toFixed(2);
        document.getElementById('totalJou').innerText = (totalMasu / 2).toFixed(1);
    }

    function updateMergeButtonUI() {
        const btn = document.getElementById('mergeBtn');
        btn.innerText = isMerged ? "編集モード" : "結合モード";
        btn.style.background = isMerged ? "#8e8e93" : "#5856d6";
    }

    window.toggleMerge = () => { isMerged = !isMerged; updateMergeButtonUI(); draw(); };
    window.addRoom = (label, w, h, color) => { const newItem = { type: 'room', x: 64, y: 64, w: w*GRID_SIZE, h: h*GRID_SIZE, label: label, color: color }; items.push(newItem); selectedItem = newItem; draw(); };
    window.addFrame = () => { const newItem = { type: 'frame', x: 32, y: 32, w: 6*GRID_SIZE, h: 6*GRID_SIZE, label: '外枠', color: '#f2f2f7' }; items.unshift(newItem); selectedItem = newItem; draw(); };
    window.duplicateItem = () => { if(!selectedItem) return; const newItem = {...selectedItem, x: selectedItem.x+16, y: selectedItem.y+16}; items.push(newItem); selectedItem = newItem; draw(); };
    window.renameItem = () => { if(!selectedItem) return; const newLabel = prompt("名前変更", selectedItem.label); if(newLabel) { selectedItem.label = newLabel; draw(); } };
    window.deleteItem = () => { items = items.filter(i => i !== selectedItem); selectedItem = null; draw(); };
    window.changeColor = () => { if(selectedItem) { selectedItem.color = document.getElementById('colorPicker').value; draw(); } };
    window.resetCanvas = () => { if(confirm("消去しますか？")) { items = []; isMerged = false; updateMergeButtonUI(); addFrame(); draw(); } };
    window.nudgeItem = (dx, dy) => { if(!selectedItem) return; const step = document.getElementById('useHalfGrid').checked ? 16 : 32; selectedItem.x += dx * step; selectedItem.y += dy * step; draw(); };
    window.saveLayout = async () => {
        try { const docRef = await addDoc(collection(db, "layouts"), { items, isMerged, updatedAt: new Date() }); document.getElementById('shareUrlInput').value = `${window.location.origin}${window.location.pathname}?id=${docRef.id}`; document.getElementById('saveModal').style.display = 'flex'; } catch (e) { alert("エラーが発生しました"); }
    };
    window.closeModal = () => document.getElementById('saveModal').style.display = 'none';
    window.copyToClipboard = () => { navigator.clipboard.writeText(document.getElementById('shareUrlInput').value); alert("コピーしました"); };

    function getPos(e) { const rect = canvas.getBoundingClientRect(); const cx = e.touches ? e.touches[0].clientX : e.clientX; const cy = e.touches ? e.touches[0].clientY : e.clientY; return { x: cx - rect.left, y: cy - rect.top }; }
    canvas.addEventListener('touchstart', e => {
        const p = getPos(e);
        if(selectedItem && !(isMerged && selectedItem.type==='frame')) { if(Math.abs(p.x - (selectedItem.x+selectedItem.w)) < 30 && Math.abs(p.y - (selectedItem.y+selectedItem.h)) < 30) { isResizing = true; return; } }
        let foundIdx = -1;
        for (let i = items.length - 1; i >= 0; i--) { if (isMerged && items[i].type === 'frame') continue; if (p.x >= items[i].x && p.x <= items[i].x+items[i].w && p.y >= items[i].y && p.y <= items[i].y+items[i].h) { foundIdx = i; break; } }
        if(foundIdx !== -1) {
            selectedItem = items[foundIdx]; items.splice(foundIdx, 1); items.push(selectedItem);
            startX = p.x - selectedItem.x; startY = p.y - selectedItem.y;
            document.getElementById('nudge-controls').style.display = 'flex';
            document.getElementById('colorPicker').value = selectedItem.color;
        } else { selectedItem = null; document.getElementById('nudge-controls').style.display = 'none'; }
        draw();
    }, {passive: false});
    canvas.addEventListener('touchmove', e => {
        if(!selectedItem) return; e.preventDefault(); const p = getPos(e); const snap = document.getElementById('useHalfGrid').checked ? 16 : 32;
        if(isResizing) { selectedItem.w = Math.max(16, Math.round((p.x - selectedItem.x)/snap)*snap); selectedItem.h = Math.max(16, Math.round((p.y - selectedItem.y)/snap)*snap); }
        else { selectedItem.x = Math.round((p.x - startX)/snap)*snap; selectedItem.y = Math.round((p.y - startY)/snap)*snap; }
        draw();
    }, {passive: false});
    canvas.addEventListener('touchend', () => isResizing = false);
    init();
</script>
</body>
</html>
