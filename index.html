<!doctype html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, maximum-scale=1.0, user-scalable=no" />
<title>é–“å–ã‚Šæ¤œè¨ã‚µã‚¤ãƒˆï¼ˆIchijo) v7.0</title>

<style>
:root{
--accent:#007AFF;
--danger:#ff3b30;
--measure:#FF2D55;
--bg:#f2f2f7;
--card: rgba(255,255,255,.72);
--stroke: rgba(60,60,67,.18);
--text:#111;
--muted: rgba(60,60,67,.6);
--shadow: 0 10px 30px rgba(0,0,0,.10);
--radius2: 26px;
}

@media (prefers-color-scheme: dark){
:root{
--bg:#000;
--card: rgba(28,28,30,.68);
--stroke: rgba(84,84,88,.55);
--text:#fff;
--muted: rgba(235,235,245,.6);
--shadow: 0 16px 50px rgba(0,0,0,.45);
}
}

*{ box-sizing: border-box; }

html, body { height: 100%; }

body {
font-family:
-apple-system, BlinkMacSystemFont,
"SF Pro Display", "SF Pro Text",
"Hiragino Sans", "Hiragino Kaku Gothic ProN",
"Noto Sans JP",
"Yu Gothic", "YuGothic",
"Meiryo",
sans-serif;
-webkit-font-smoothing: antialiased;
text-rendering: optimizeLegibility;

margin: 0;
background: var(--bg);
color: var(--text);

/* â–¼ ä¿®æ­£: ãƒãƒƒãƒã®é«˜ã•(env)ã«12pxã‚’åŠ ç®—ã—ã¦ç¢ºä¿ã™ã‚‹ */
padding-top: calc(env(safe-area-inset-top) + 12px);

padding-left: env(safe-area-inset-left);
padding-right: env(safe-area-inset-right);

touch-action: none;

display: flex;
flex-direction: column;

/* â–¼ ä¿®æ­£: é«˜ã•ã®è¨ˆç®—æ–¹æ³•ã‚’å®‰å®šã•ã›ã‚‹ */
height: 100%;
position: fixed; /* Safariã§ã®ãƒã‚¦ãƒ³ã‚¹ã‚„ä½™è¨ˆãªã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚’é˜²æ­¢ */
inset: 0;
overflow: hidden;
}


.ver-label{
position: fixed;
top: calc(6px + env(safe-area-inset-top));
right: 10px;
font-size: 10px;
color: var(--muted);
z-index: 100;
pointer-events: none;
font-weight: 800;
text-align: right;
opacity: .85;
}

.toolbar {
/* â–¼ ä¿®æ­£: ä¸Šãƒãƒ¼ã‚¸ãƒ³ã‚’0ã«ã—ã€å·¦å³ã¨ä¸‹ã ã‘12pxã«ã™ã‚‹ */
margin: 0 12px 8px 12px;

border-radius: var(--radius2);
background: var(--card);
border: 1px solid var(--stroke);
box-shadow: var(--shadow);
backdrop-filter: blur(16px);
-webkit-backdrop-filter: blur(16px);

padding: 10px;
display: flex;
align-items: center;
justify-content: space-between;
gap: 10px;

z-index: 10;
}


.top-left, .top-right{ display:flex; align-items:center; gap: 10px; }
.top-title{ font-weight: 900; font-size: 13px; letter-spacing: .3px; opacity: .9; user-select:text; cursor:text; padding:4px 8px; border-radius:10px; max-width: 44vw; overflow:hidden; text-overflow: ellipsis; white-space: nowrap; }
.top-title:focus{ outline:2px solid rgba(0,122,255,.35); background: rgba(0,122,255,.08); }

button{
height: 44px;
font-size: 13px;
border: none;
border-radius: 16px;
color: white;
font-weight: 900;
cursor: pointer;
display: inline-flex;
align-items: center;
justify-content: center;
padding: 0 14px;
-webkit-tap-highlight-color: transparent;
letter-spacing: .2px;
transition: transform .08s ease, filter .08s ease, opacity .08s ease;
}
button:active { opacity: 0.85; transform: scale(0.98); }

.btn-primary{ background: rgba(255,149,0,.95); }
.btn-help{
background: rgba(120,120,128,.18);
color: var(--text);
font-size: 18px;
width: 44px;
padding: 0;
}

.mode-banner{
margin: 0 12px 12px;
border-radius: 999px;
background: rgba(255,149,0,.14);
border: 1px solid rgba(255,149,0,.30);
color: rgba(255,149,0,.95);
box-shadow: var(--shadow);
backdrop-filter: blur(16px);
-webkit-backdrop-filter: blur(16px);
padding: 8px 12px;
font-size: 12px;
font-weight: 900;
display:flex;
align-items:center;
justify-content: space-between;
gap: 10px;
}
.mode-banner button{
height: 34px;
border-radius: 999px;
padding: 0 12px;
font-size: 12px;
}

.config-bar{
margin: 0 12px 12px;
border-radius: var(--radius2);
background: var(--card);
border: 1px solid var(--stroke);
box-shadow: var(--shadow);
backdrop-filter: blur(16px);
-webkit-backdrop-filter: blur(16px);

padding: 10px;
display:flex;
justify-content: space-between;
align-items:center;
gap: 10px;
flex-wrap: wrap;
}

.chip-group { display: flex; gap: 6px; flex-wrap: wrap; }
.chip{
background: rgba(255,255,255,.55);
border: 1px solid var(--stroke);
padding: 8px 12px;
border-radius: 999px;
font-size: 13px;
font-weight: 900;
display:flex;
align-items:center;
gap: 6px;
box-shadow: 0 1px 6px rgba(0,0,0,.06);
cursor: pointer;
color: var(--text);
}
@media (prefers-color-scheme: dark){
.chip{ background: rgba(44,44,46,.65); }
}
.chip input { margin: 0; width: 18px; height: 18px; }


/* range chip */
.range-chip{
cursor: default;
gap: 8px;
padding: 8px 10px;
}
.range-chip input[type="range"]{
width: 92px;
height: 18px;
}
@media (max-width: 420px){
.range-chip input[type="range"]{ width: 72px; }
}

.right-actions{
display:flex;
align-items:center;
gap: 10px;
flex-wrap: wrap;
justify-content: flex-end;
}

.segment{
display:flex;
align-items: center;
border: 1px solid var(--stroke);
border-radius: 14px;
background: rgba(120,120,128,.12);
padding: 2px;
height: 36px;
}
.seg-btn{
height: 32px;
min-width: 56px;
padding: 0 12px;
border-radius: 12px;
background: transparent;
color: var(--text);
font-size: 12px;
font-weight: 900;
line-height: 1;
box-shadow:none;
white-space: nowrap;
}
.seg-btn.active{ background: var(--accent); color: #fff; }
.seg-btn:active{ transform: none; }

.small-btn{
height: 34px;
border-radius: 999px;
padding: 0 12px;
background: var(--accent);
color:#fff;
font-size: 12px;
font-weight: 900;
}
.small-btn.gray{
background: rgba(120,120,128,.25);
color: var(--text);
border: 1px solid var(--stroke);
}
.small-btn.active{
background: var(--measure) !important;
color: #fff !important;
border: none !important;
}

.small-btn.view-active{
background: var(--accent) !important;
color: #fff !important;
border: none !important;
}
.small-btn:disabled{ opacity: .4; transform: none !important; cursor: default; }

/* iOS Safariã§ç¢ºå®Ÿã«è‰²ãƒ”ãƒƒã‚«ãƒ¼ã‚’é–‹ã‹ã›ã‚‹: label + input(color) ã‚’é€æ˜ã§è¢«ã›ã‚‹ */
.color-label{
position: relative;
overflow: hidden;

/* ãƒ©ãƒ™ãƒ«å†…ã«è‰²è¦‹æœ¬ã‚’å‡ºã™ */
display: inline-flex;
align-items: center;
justify-content: center;
gap: 8px;
padding-left: 12px;
}

/* å…ˆé ­ã«è‰²è¦‹æœ¬ï¼ˆCSSå¤‰æ•° --swatch ã‚’ä½¿ã†ï¼‰ */
.color-label::before{
content: "";
width: 14px;
height: 14px;
border-radius: 999px;
background: var(--swatch, #ffffff);
border: 1px solid rgba(0,0,0,.12);
}
.color-label input[type="color"]{
position: absolute;
inset: 0;
width: 100%;
height: 100%;
opacity: 0; /* display:noneã¯NG */
border: 0;
padding: 0;
}
.color-label[data-disabled="1"]{
opacity: .35;
filter: grayscale(1);
pointer-events: none;
}

/* ===== Summaryï¼ˆå»¶åºŠã®ã¿ï¼šå¤–æ (frame)é¢ç©ï¼‰ ===== */
.summary{
margin: 0 12px 12px;
border-radius: 999px;
background: var(--card);
border: 1px solid var(--stroke);
box-shadow: var(--shadow);
backdrop-filter: blur(16px);
-webkit-backdrop-filter: blur(16px);

padding: 10px 14px;
display:flex;
justify-content: space-around;
align-items:center;

font-size: 14px;
font-weight: 900;
}
.summary b{ color: var(--accent); }

/* ===== Canvas ===== */
#canvas-container{
flex: 1;
position: relative;
margin: 0 12px 12px;
border-radius: 24px;
overflow: hidden;
border: 1px solid var(--stroke);
box-shadow: var(--shadow);
background: #fff;
touch-action: none;

margin-bottom: calc(96px + env(safe-area-inset-bottom));
}
canvas{ display:block; }

/* ===== Bottom Bar ===== */
.bottom-bar{
position: fixed;
left: 12px; right: 12px;
bottom: calc(12px + env(safe-area-inset-bottom));
display: grid;

/* â–¼ ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ã€Œéƒ¨å±‹ãƒ¢ãƒ¼ãƒ‰ã€ã®åˆ—ï¼ˆå¤–æ ãƒ¢ãƒ¼ãƒ‰ã§ä¸Šæ›¸ãï¼‰ */
grid-template-columns: 1.05fr 1.05fr 1.75fr 0.75fr 0.85fr 0.85fr;

gap: 10px;
padding: 10px;
border-radius: 24px;
background: var(--card);
border: 1px solid var(--stroke);
box-shadow: var(--shadow);
backdrop-filter: blur(16px);
-webkit-backdrop-filter: blur(16px);
z-index: 60;
}

/* âœ… å¤–æ ãƒ¢ãƒ¼ãƒ‰ï¼šå¤–å£è¿½åŠ ï¼‹å‰Šé™¤ã ã‘ã«ã—ã¦ã€è¦‹ãŸç›®ã‚‚æŠ¼ã—ã‚„ã™ã */
.bottom-bar.mode-outer{
grid-template-columns: 1fr 1fr;
}

/* å°ã•ã„ç”»é¢ã¯å°‘ã—è©°ã‚ã‚‹ï¼ˆæŠ¼ã—ã‚„ã™ã•ã¯ç¶­æŒï¼‰ */
@media (max-width: 390px){
.bottom-bar{ gap: 8px; left: 10px; right: 10px; }
}


.pill{
height: 48px;
border-radius: 18px;
background: rgba(120,120,128,.16);
color: var(--text);
box-shadow: none;
font-weight: 900;
font-size: 13px;
letter-spacing: .2px;

display:flex;
align-items:center;
justify-content:center;
flex-direction: column;
gap: 2px;
padding: 6px 0;
}
.pill.active{
background: var(--accent);
color: #fff;
box-shadow: 0 8px 18px rgba(0,122,255,.25);
}

.pill::after{
content: attr(data-sub);
font-size: 10px;
font-weight: 800;
color: var(--muted);
letter-spacing: .1px;
}
.pill.primary{ background: var(--accent); color:#fff; }
.pill.primary::after{ color: rgba(255,255,255,.85); }
.pill.danger{
background: rgba(255,59,48,.14);
color: #ff3b30;
}
.pill:disabled{
opacity: .35;
filter: grayscale(1);
transform: none !important;
cursor: default;
}

/* ãƒœãƒˆãƒ ãƒãƒ¼ï¼šé¸æŠåã®çœç•¥è¡¨ç¤º */
#selectedNameDisplay{
max-width: 100%;
white-space: nowrap;
overflow: hidden;
text-overflow: ellipsis;
display: block;
}


/* ===== Modals ===== */
.modal-overlay{
display: none;
position: fixed;
inset: 0;
background: rgba(0,0,0,0.6);
z-index: 1000;
align-items: center;
justify-content: center;
}
.modal{
background: #fff;
padding: 25px;
border-radius: 20px;
width: 85%;
max-width: 360px;
text-align: center;
box-shadow: 0 10px 30px rgba(0,0,0,0.3);
}
.modal input{
width: 100%;
padding: 12px;
margin: 15px 0;
border: 1px solid #ddd;
border-radius: 10px;
font-size: 14px;
box-sizing: border-box;
}
#helpModal .modal{
max-width: 420px;
text-align: left;
max-height: 80vh;
overflow-y: auto;
}
#helpModal ul{ padding-left: 20px; font-size: 13px; line-height: 1.6; }
#helpModal h3{ text-align: center; margin-top: 0; }

.modal.sheet{ width: 92%; max-width: 420px; text-align: left; border-radius: 22px; }

#labelInput{
width: 100%;
padding: 12px 12px;
border: 1px solid #ddd;
border-radius: 14px;
font-size: 16px;
font-weight: 800;
outline: none;
}

.chip-grid{
display: grid;
grid-template-columns: repeat(4, 1fr);
gap: 8px;
margin-top: 12px;
}
.name-chip{
height: 38px;
border-radius: 14px;
border: 1px solid var(--stroke);
background: rgba(120,120,128,.14);
color: var(--text);
font-weight: 900;
font-size: 13px;
letter-spacing: .2px;
padding: 0 8px;
width: 100%;
justify-content: center;
box-shadow: none;
gap: 8px;
display:flex;
}
.name-chip .dot{
width: 12px;
height: 12px;
border-radius: 999px;
border: 1px solid rgba(0,0,0,.08);
}
.name-chip:active{ transform: scale(.98); opacity: .9; }

.menu-list{
display:flex;
flex-direction: column;
gap: 10px;
margin-top: 14px;
}
.menu-btn{
height: 42px;
border-radius: 16px;
border: 1px solid var(--stroke);
background: rgba(120,120,128,.14);
color: var(--text);
font-weight: 900;
justify-content: center;
display:flex;
align-items:center;
justify-content:center;
}
.menu-btn.danger{
background: rgba(255,59,48,.14);
color: #ff3b30;
}

/* é•·æŠ¼ã—ãƒ¡ãƒ‹ãƒ¥ãƒ¼ï¼šè‰²å¤‰æ›´ã‚‚ä»–ãƒœã‚¿ãƒ³ã¨åŒã˜è¦‹ãŸç›®ã«ï¼ˆå³ã«è‰²ãƒ‰ãƒƒãƒˆï¼‰ */
.menu-color-label{
position: relative;
overflow: hidden;
justify-content: space-between;
padding: 0 14px;
gap: 10px;
}
.menu-color-label input[type="color"]{
position: absolute;
inset: 0;
width: 100%;
height: 100%;
opacity: 0;
border: 0;
padding: 0;
}
.menu-color-dot{
width: 14px;
height: 14px;
border-radius: 999px;
background: var(--swatch, #FFF3E0);
border: 1px solid rgba(0,0,0,.12);
pointer-events: none;
}
@media (prefers-color-scheme: dark){
.menu-color-dot{ border-color: rgba(255,255,255,.22); }
}

/* Preset manager */
.preset-list{ display:flex; flex-direction:column; gap:10px; margin-top: 10px; }
.preset-row{
display:grid;
grid-template-columns: 1fr 54px 54px;
gap: 8px;
align-items:center;
}
.preset-row input[type="text"]{
margin: 0;
padding: 10px 10px;
border-radius: 14px;
border: 1px solid #ddd;
font-weight: 800;
}
.preset-row input[type="color"]{
width: 54px;
height: 42px;
border-radius: 14px;
padding: 0;
border: 1px solid var(--stroke);
background: transparent;
}
.preset-del{
height: 42px;
border-radius: 14px;
background: rgba(255,59,48,.14);
color:#ff3b30;
border: 1px solid rgba(255,59,48,.25);
font-weight: 900;
}

#presetModal .modal.sheet{
max-height: calc(86vh - env(safe-area-inset-bottom));
display: flex;
flex-direction: column;
}
#presetList{
overflow: auto;
-webkit-overflow-scrolling: touch;
flex: 1;
padding-right: 4px;
}
.preset-footer{
position: sticky;
bottom: 0;
padding-top: 10px;
background: inherit;
}
#presetSearch{
width: 100%;
padding: 10px 12px;
border-radius: 14px;
border: 1px solid #ddd;
font-weight: 800;
outline: none;
}

/* Layout list */
.layout-list{
overflow:auto;
-webkit-overflow-scrolling: touch;
flex: 1;
padding-right: 4px;
margin-top: 10px;
}
.layout-row{
display: grid;
grid-template-columns: 1fr 74px 74px 44px;
gap: 8px;
align-items: center;
margin-bottom: 10px;
}
.layout-row input[type="text"]{
margin: 0;
padding: 10px 10px;
border-radius: 14px;
border: 1px solid #ddd;
font-weight: 800;
}
.layout-btn{
height: 42px;
border-radius: 14px;
border: 1px solid var(--stroke);
background: rgba(120,120,128,.14);
color: var(--text);
font-weight: 900;
justify-content: center;
}
.layout-del{
height: 42px;
border-radius: 14px;
background: rgba(255,59,48,.14);
color:#ff3b30;
border: 1px solid rgba(255,59,48,.25);
font-weight: 900;
padding: 0;
}

/* ä½œæ¥­ãƒ¢ãƒ¼ãƒ‰ãƒ’ãƒ³ãƒˆ */
.work-hint{
position: sticky;
top: 0;
z-index: 20;
margin: 4px 12px 0;
padding: 8px 10px;
border-radius: 12px;
background: rgba(255,255,255,.9);
border: 1px solid rgba(0,0,0,.08);
color: #333;
font-size: 12px;
line-height: 1.35;
backdrop-filter: blur(8px);
}
.work-hint b{ font-weight: 800; }

/* --- ãƒˆãƒ¼ã‚¹ãƒˆé€šçŸ¥ï¼ˆåŸºæœ¬ï¼šæ“ä½œä¸­ç”¨ï¼‰ --- */
.toast {
position: fixed;
left: 50%;
bottom: 90px;
transform: translateX(-50%);

background: rgba(20, 20, 20, 0.9);
color: #fff;

/* åŸºæœ¬ã¯å°ã•ãï¼ˆæ“ä½œä¸­ãªã©ï¼‰ */
font-size: 12px;
padding: 8px 16px;
border-radius: 999px;

opacity: 0;
pointer-events: none;
transition: opacity 0.2s ease, transform 0.2s ease;
z-index: 2000;

max-width: 85vw;
white-space: normal;
text-align: center;
line-height: 1.4;
}

/* â˜…è¿½åŠ : ä¿å­˜ç”¨ï¼ˆå¤§ããç›®ç«‹ãŸã›ã‚‹ï¼‰ */
.toast.large {
bottom: 110px; /* å°‘ã—ä¸Šã« */
font-size: 15px; /* æ–‡å­—å¤§ãã */
font-weight: bold; /* å¤ªå­— */
padding: 14px 24px; /* ä½™ç™½ãŸã£ã·ã‚Š */
background: rgba(20, 20, 20, 0.95);
box-shadow: 0 4px 14px rgba(0,0,0,0.25);
}

/* è¡¨ç¤ºç”¨ */
.toast.show {
opacity: 1;
transform: translateX(-50%) translateY(-4px);
}



/* --- ã‚³ãƒ³ãƒ‘ã‚¯ãƒˆåŒ–CSS --- */

/* ãƒãƒ¼å…¨ä½“ã®ä½™ç™½ã‚’å‰Šæ¸› */
.config-bar.compact {
padding: 8px 10px;
gap: 6px;
flex-direction: column; /* ç¢ºå®Ÿã«ç¸¦2æ®µã«ã™ã‚‹ */
align-items: stretch;
}

/* 1è¡Œã”ã¨ã®è¨­å®š */
.config-row {
display: flex;
align-items: center;
gap: 6px;
justify-content: space-between;
}

/* å°ã•ã„ãƒãƒƒãƒ—ï¼ˆå˜ä½ãªã©ï¼‰ */
.chip.tiny {
padding: 0 8px;
height: 28px; /* é«˜ã•å‰Šæ¸› */
font-size: 11px; /* æ–‡å­—ã‚µã‚¤ã‚ºç¸®å° */
font-weight: 800;
gap: 4px;
}
.chip.tiny input[type="checkbox"] {
width: 14px;
height: 14px;
}

/* ã‚°ãƒ«ãƒ¼ãƒ—åŒ– */
.group-tiny {
display: flex;
gap: 4px;
}

/* åŒºåˆ‡ã‚Šç·š */
.v-line {
width: 1px;
height: 16px;
background: rgba(0,0,0,0.1);
margin: 0 2px;
}
@media (prefers-color-scheme: dark){ .v-line{ background: rgba(255,255,255,0.15); } }

/* å£ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã®æ¥µå°åŒ– */
.range-chip-tiny {
flex: 1; /* ç©ºãã‚¹ãƒšãƒ¼ã‚¹ã‚’åŸ‹ã‚ã‚‹ */
display: flex;
align-items: center;
justify-content: space-between;
padding: 0 8px;
min-width: 0; /* flexç¸®å°ç”¨ */
}
.range-chip-tiny input[type="range"] {
width: 100%; /* è¦ªã«åˆã‚ã›ã¦ä¼¸ç¸® */
height: 14px;
margin: 0 6px;
min-width: 40px;
}
.range-chip-tiny .lbl { font-size:10px; opacity:0.7; }
.range-chip-tiny .val { font-size:11px; min-width:14px; text-align:right; }

/* 2æ®µç›®ã®ãƒœã‚¿ãƒ³ç¾¤ */
.small-btn.tiny {
height: 30px;
padding: 0 10px;
font-size: 11px;
border-radius: 8px;
}
.segment.tiny {
height: 30px;
border-radius: 8px;
}
.segment.tiny .seg-btn {
height: 26px;
font-size: 11px;
min-width: 40px;
padding: 0 8px;
}

/* Undo/Redoãªã©ã®çµåˆãƒœã‚¿ãƒ³ */
.joined-tiny {
display: flex;
background: rgba(120,120,128,.12);
border-radius: 8px;
padding: 2px;
flex-shrink: 0;
}
.joined-tiny button {
background: transparent;
border: none;
height: 26px;
border-radius: 6px;
font-size: 14px;
width: 32px;
padding: 0;
color: var(--text);
font-weight: 900;
}
.joined-tiny button:active { background: rgba(0,0,0,0.05); }
.joined-tiny button:disabled { opacity: 0.3; }

/* å…¨ä½“ãƒ»ãƒªã‚»ãƒƒãƒˆãƒœã‚¿ãƒ³ã¯æ–‡å­—ã®ã¿ã§çœã‚¹ãƒšãƒ¼ã‚¹ */
.joined-tiny .btn-text {
font-size: 10px;
width: auto;
padding: 0 6px;
}

/* è‰²ãƒœã‚¿ãƒ³ */
.color-label-tiny {
display: flex;
align-items: center;
justify-content: center;
width: 36px;
padding: 0;
position: relative;
overflow: hidden;
}
.color-label-tiny .color-dot {
width: 16px;
height: 16px;
border-radius: 999px;
background: var(--swatch, #fff);
border: 1px solid rgba(0,0,0,0.1);
pointer-events: none;
}
.color-label-tiny input {
position: absolute; opacity: 0; inset: 0; width: 100%;
}
.color-label-tiny::before { display: none; } /* æ—¢å­˜ã‚¹ã‚¿ã‚¤ãƒ«ã®æ‰“ã¡æ¶ˆã— */

/* å³å¯„ã›èª¿æ•´ */
.right-edge { margin-left: auto; }




/* UIç°¡ç´ åŒ–: ä¸Šéƒ¨ã®ã‚¯ã‚¤ãƒƒã‚¯è‰²å¤‰æ›´ã¯éè¡¨ç¤ºï¼ˆå¿…è¦ãªã‚‰å‰Šé™¤ã—ã¦OKï¼‰ */
#quickColorBtn{ display:none !important; }

/* --- ğŸ†• ãƒãƒ‹ãƒ¥ã‚¢ãƒ«ç”¨ã‚¹ã‚¿ã‚¤ãƒªãƒƒã‚·ãƒ¥CSS --- */
#helpModal .modal {
  background: #f2f2f7; /* èƒŒæ™¯ã‚’å°‘ã—ã‚°ãƒ¬ãƒ¼ã« */
  padding: 0;
  overflow: hidden;
  max-width: 460px;
  display: flex;
  flex-direction: column;
}
#helpModal .modal-header {
  padding: 20px;
  background: #fff;
  border-bottom: 1px solid rgba(0,0,0,0.05);
  text-align: center;
}
#helpModal h3 { margin: 0; font-size: 17px; }
#helpModal .modal-body {
  padding: 20px;
  overflow-y: auto;
  max-height: 60vh;
  -webkit-overflow-scrolling: touch;
}

/* ã‚»ã‚¯ã‚·ãƒ§ãƒ³ */
.help-section {
  margin-bottom: 24px;
}
.help-section-title {
  font-size: 13px;
  color: #666;
  margin: 0 0 8px 4px;
  font-weight: 600;
  text-transform: uppercase;
}

/* ã‚«ãƒ¼ãƒ‰ãƒªã‚¹ãƒˆ */
.help-list {
  background: #fff;
  border-radius: 12px;
  overflow: hidden;
  box-shadow: 0 1px 3px rgba(0,0,0,0.05);
}
.help-row {
  display: flex;
  align-items: flex-start;
  padding: 12px 16px;
  border-bottom: 1px solid #ebedf0;
  gap: 12px;
}
.help-row:last-child { border-bottom: none; }

.help-icon {
  width: 28px;
  height: 28px;
  background: var(--accent);
  border-radius: 6px;
  color: #fff;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 16px;
  flex-shrink: 0;
}
.help-icon.green { background: #34C759; }
.help-icon.orange { background: #FF9500; }
.help-icon.pink { background: #FF2D55; }
.help-icon.gray { background: #8E8E93; }

.help-content { font-size: 13px; line-height: 1.5; color: #111; }
.help-content b { display: block; font-size: 14px; margin-bottom: 2px; }

/* é–‰ã˜ã‚‹ãƒœã‚¿ãƒ³ã‚¨ãƒªã‚¢ */
#helpModal .modal-footer {
  padding: 16px 20px 24px; /* ä¸‹ã«ä½™è£•ã‚’ */
  background: #f2f2f7;
}
#helpCloseBtn {
  width: 100%;
  height: 48px;
  background: #fff;
  color: var(--accent);
  font-weight: 700;
  border-radius: 12px;
  border: none;
  font-size: 15px;
  box-shadow: 0 2px 5px rgba(0,0,0,0.05);
}
#helpCloseBtn:active { background: #e5e5ea; transform: scale(0.98); }


</style>
</head>

<body>
<div class="ver-label">ver 1.11<br>by yuchiğŸ”</div>

<div class="toolbar">
<div class="top-left">
<button class="btn-help" id="openHelpBtn" aria-label="ãƒ˜ãƒ«ãƒ—">ï¼Ÿ</button>
<div class="top-title" id="topTitle" contenteditable="true" spellcheck="false" role="textbox" aria-label="é–“å–ã‚Šåï¼ˆã‚¿ãƒƒãƒ—ã—ã¦ç·¨é›†ï¼‰">MORI</div>
</div>

<!-- å…±æœ‰ / é–²è¦§ãƒ¢ãƒ¼ãƒ‰ã§ã¯ã‚³ãƒ”ãƒ¼ã—ã¦-->

<div class="top-right">
<button class="btn-primary" id="downloadImageBtn" style="background:#34C759; margin-right:10px;">ç”»åƒä¿å­˜</button>
<button class="btn-primary" id="shareBtn">å…±æœ‰</button>
</div>


</div>

<div id="modeBanner" class="mode-banner" style="display:none;">
<div>é–²è¦§ãƒ¢ãƒ¼ãƒ‰ï¼ˆä¸Šæ›¸ãã•ã‚Œã¾ã›ã‚“ï¼‰</div>
<button id="copyToEditBtn" style="background:var(--accent);">ã‚³ãƒ”ãƒ¼ã—ã¦ç·¨é›†</button>
</div>

<div class="config-bar compact">

<div class="config-row">
<div class="group-tiny">
<label class="chip tiny"><input type="checkbox" id="showJou" checked>ç•³</label>
<label class="chip tiny"><input type="checkbox" id="showTsubo" checked>åª</label>
<label class="chip tiny"><input type="checkbox" id="showM2" checked>mÂ²</label>
</div>

<div class="v-line"></div>

<label class="chip tiny"><input type="checkbox" id="useHalfGrid">åŠã¾ã™</label>

<div class="chip tiny range-chip-tiny" id="wallThickChip" title="å£ã®å¤ªã•">
<span class="lbl">å£</span>
<input type="range" id="wallThickSlider" min="4" max="24" step="1" value="12">
<span id="wallThickVal" class="val">12</span>
</div>
</div>

<div class="config-row">
<div class="segment tiny" role="tablist">
<button class="seg-btn" id="segEdit" type="button">å¤–å£</button>
<button class="seg-btn active" id="segMerge" type="button">éƒ¨å±‹</button>
</div>


<button id="viewBtn" class="small-btn tiny gray" type="button" title="é–²è¦§ãƒ¢ãƒ¼ãƒ‰ï¼ˆæ‹¡å¤§/ç§»å‹•ï¼‰">é–²è¦§</button>

<button id="fitBtn" class="small-btn tiny gray" type="button" title="å…¨ä½“ã‚’è¡¨ç¤º">å…¨ä½“</button>


<button id="measureBtn" class="small-btn tiny gray" type="button">è¨ˆæ¸¬</button>

<div class="joined-tiny">
<button id="undoBtn" class="btn-icon" type="button">â†©ï¸</button>
<button id="redoBtn" class="btn-icon" type="button" disabled>â†ªï¸</button>
</div>

<label id="quickColorBtn" class="small-btn tiny color-label-tiny" data-disabled="1" title="è‰²å¤‰æ›´">
<span class="color-dot"></span>
<input type="color" id="quickColorInput" value="#ffffff" />
</label>
</div>

</div>


<!-- ä½œæ¥­ãƒ¢ãƒ¼ãƒ‰ãƒ’ãƒ³ãƒˆ -->
<div id="workHint" class="work-hint"></div>
<!-- âœ… å»¶åºŠã®ã¿ï¼ˆå¤–æ frameé¢ç©ï¼‰ -->
<div class="summary">
<span>å»¶åºŠ: <b id="totalTsubo">0.00</b> åª</span>
<span id="jouWrap"><b id="totalJou">0.0</b> ç•³</span>
<span id="m2Wrap"><b id="totalM2">0.0</b> mÂ²</span>
</div>

<div id="canvas-container"><canvas id="canvas"></canvas></div>

<div class="bottom-bar" id="defaultBar">
<!-- éƒ¨å±‹ãƒ¢ãƒ¼ãƒ‰ï¼šè¿½åŠ  -->
<button class="pill primary" id="addGenericRoomBtn2" data-sub="ãƒ—ãƒªã‚»ãƒƒãƒˆé¸æŠ">éƒ¨å±‹</button>
<button class="pill" id="addInnerWallBtn2" data-sub="2ç‚¹ã‚¿ãƒƒãƒ—">å†…å£</button>

<!-- å¤–æ ãƒ¢ãƒ¼ãƒ‰ï¼šå¤–å£ã®è¿½åŠ /å‰Šé™¤ï¼ˆéƒ¨å±‹ãƒ¢ãƒ¼ãƒ‰æ™‚ã¯éè¡¨ç¤ºï¼‰ -->
<button class="pill primary" id="addFrameBtn2" data-sub="è¿½åŠ " style="display:none;">å¤–å£</button>

<!-- éƒ¨å±‹ãƒ¢ãƒ¼ãƒ‰ï¼šé¸æŠä¸­ã®ç·¨é›† -->
<button class="pill" id="editNameBtn" data-sub="åå‰å¤‰æ›´" type="button">
<span id="selectedNameDisplay">æœªé¸æŠ</span>
</button>

<label class="pill" id="selectedColorLabel" data-sub="è‰²" style="position:relative; overflow:hidden;" aria-label="é¸æŠä¸­ã®è‰²">
<span class="color-dot" id="selectedColorDot" style="width:20px; height:20px; border-radius:50%; border:1px solid rgba(0,0,0,0.2); background:#fff;"></span>
<input type="color" id="selectedColorInput" style="position:absolute; inset:0; opacity:0; width:100%; height:100%;" disabled>
</label>

<!-- éƒ¨å±‹ãƒ¢ãƒ¼ãƒ‰ï¼šè¡¨é¢ã«å‡ºã™ -->
<button class="pill" id="dupSelectedBtn" data-sub="è¤‡è£½" type="button">è¤‡è£½</button>
<button class="pill danger" id="delSelectedBtn" data-sub="å‰Šé™¤" type="button">å‰Šé™¤</button>
</div>

<!-- å…±æœ‰ãƒ¢ãƒ¼ãƒ€ãƒ« -->
<div id="shareModal" class="modal-overlay">
<div class="modal">
<h3>å…±æœ‰</h3>

<div style="text-align:left; font-size:12px; font-weight:bold; color:#666; margin-bottom:4px;">é–“å–ã‚Šå</div>
<input type="text" id="layoutTitleInput" value="MORIYASUğŸ " maxlength="20" style="margin-top:0; font-weight:bold;">

<div style="font-size:12px;color:#666;margin-top:10px;">å…±æœ‰URLï¼ˆèª­ã¿å–ã‚Šå°‚ç”¨ï¼šä¸Šæ›¸ãã•ã‚Œã¾ã›ã‚“ï¼‰</div>
<input type="text" id="shareUrlInput" readonly onclick="this.select()">

<div style="display:flex; gap:10px;">
<button style="flex:1; background:var(--accent);" id="copyUrlBtn">ã‚³ãƒ”ãƒ¼</button>
<button style="flex:1; background:rgba(120,120,128,.45); color:#fff;" id="closeShareModalBtn">é–‰ã˜ã‚‹</button>
</div>

<div style="display:flex; gap:10px; margin-top:10px;">
<button style="flex:1; background:rgba(120,120,128,.18); color:#111; border:1px solid rgba(60,60,67,.18);" id="openLayoutsBtn">ä¿å­˜ä¸€è¦§</button>
<button style="flex:1; background:rgba(120,120,128,.18); color:#111; border:1px solid rgba(60,60,67,.18);" id="saveAsBtn">åˆ¥åã§ä¿å­˜</button>
</div>

<p style="font-size:11px;color:#666; margin-top:10px; line-height:1.5;">
â€»å…±æœ‰URLã¯ã€Œã“ã®çŠ¶æ…‹ã®ã‚³ãƒ”ãƒ¼ã€ã§ã™ã€‚è‡ªåˆ†ã®ç·¨é›†ã¯å…ƒã®ã¾ã¾ç¶šã‘ã‚‰ã‚Œã¾ã™ã€‚
</p>
</div>
</div>

<div id="layoutsModal" class="modal-overlay">
<div class="modal sheet" style="max-height:calc(86vh - env(safe-area-inset-bottom)); display:flex; flex-direction:column;">
<h3 style="margin:0 0 6px;">ä¿å­˜ä¸€è¦§</h3>
<div style="font-size:12px;color:#666;margin-bottom:6px;">è‡ªåˆ†ç”¨ã®ç·¨é›†URLã ã‘è¡¨ç¤º / åå‰ã¯ç·¨é›†ã§ãã¾ã™</div>
<div style="font-size:12px;color:#666;margin-bottom:10px;">â€»ãŠæ°—ã«å…¥ã‚Šç­‰ã§ç©ºã®ç”»é¢ã«ãªã£ãŸå ´åˆã¯ã€ã“ã“ã§ã€Œé–‹ãã€ã‹ã‚‰ç·¨é›†ã‚’å†é–‹ã§ãã¾ã™</div>

<div class="layout-list" id="layoutList"></div>

<div class="preset-footer">
<div style="display:flex; gap:10px; margin-top:10px;">
<button class="small-btn gray" id="layoutsCloseBtn" type="button" style="height:42px; flex:1;">é–‰ã˜ã‚‹</button>
</div>
</div>
</div>
</div>


<div id="helpModal" class="modal-overlay">
  <div class="modal">
    <div class="modal-header">
      <h3>ä½¿ã„æ–¹ãƒ»æ“ä½œã‚¬ã‚¤ãƒ‰</h3>
    </div>
    
    <div class="modal-body">
      
      <div class="help-section">
        <div class="help-section-title">åŸºæœ¬æ“ä½œ</div>
        <div class="help-list">
          <div class="help-row">
            <div class="help-icon">ğŸ‘†</div>
            <div class="help-content">
              <b>ç§»å‹•ãƒ»é¸æŠ</b>
              éƒ¨å±‹ã®ä¸­å¤®ãƒãƒ³ãƒ‰ãƒ«ã‚’ãƒ‰ãƒ©ãƒƒã‚°ã§ç§»å‹•ã€‚ã‚¿ãƒƒãƒ—ã§é¸æŠã€‚ä½•ã‚‚ãªã„æ‰€ã‚’ã‚¿ãƒƒãƒ—ã§è§£é™¤ã€‚
            </div>
          </div>
          <div class="help-row">
            <div class="help-icon">â†˜ï¸</div>
            <div class="help-content">
              <b>ã‚µã‚¤ã‚ºå¤‰æ›´</b>
              é¸æŠæ™‚ã€å³ä¸‹ã«å‡ºã‚‹ç™½ã„ä¸¸ãƒãƒ³ãƒ‰ãƒ«ã‚’ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦èª¿æ•´ã€‚
            </div>
          </div>
          <div class="help-row">
            <div class="help-icon orange">ğŸ¨</div>
            <div class="help-content">
              <b>è‰²ãƒ»åå‰ã®å¤‰æ›´</b>
              éƒ¨å±‹ã‚’é¸æŠã—ã€ç”»é¢ä¸‹ã®ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ã‹ã‚‰å¤‰æ›´ã€‚åå‰å¤‰æ›´ã¯éƒ¨å±‹ã‚’ã€Œ2å›ã‚¿ãƒƒãƒ—ã€ã§ã‚‚å¯èƒ½ã€‚
            </div>
          </div>
        </div>
      </div>

      <div class="help-section">
        <div class="help-section-title">ä½œæˆã®æµã‚Œ</div>
        <div class="help-list">
          <div class="help-row">
            <div class="help-icon gray">1</div>
            <div class="help-content">
              <b>å¤–å£ãƒ¢ãƒ¼ãƒ‰</b>
              ã¾ãšã¯å®¶ã®ã€Œå¤–æ ã€ã‚’ä½œã‚Šã¾ã™ã€‚ã‚µã‚¤ã‚ºã‚’æ±ºã‚ãŸã‚‰ã€Œéƒ¨å±‹ã€ãƒ¢ãƒ¼ãƒ‰ã¸ã€‚
            </div>
          </div>
          <div class="help-row">
            <div class="help-icon green">2</div>
            <div class="help-content">
              <b>éƒ¨å±‹ãƒ¢ãƒ¼ãƒ‰</b>
              éƒ¨å±‹ã‚’è¿½åŠ ã—ã¦é…ç½®ã—ã¾ã™ã€‚å†…å£ã¯ã€Œå†…å£ã€ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ã‹ã‚‰2ç‚¹ã‚’ã‚¿ãƒƒãƒ—ã€‚
            </div>
          </div>
        </div>
      </div>

      <div class="help-section">
        <div class="help-section-title">ä¾¿åˆ©æ©Ÿèƒ½</div>
        <div class="help-list">
          <div class="help-row">
            <div class="help-icon pink">ğŸ“</div>
            <div class="help-content">
              <b>è¨ˆæ¸¬ãƒ¢ãƒ¼ãƒ‰</b>
              2ç‚¹ã‚’ã‚¿ãƒƒãƒ—ã™ã‚‹ã¨ã€ãã®é–“ã®è·é›¢ã‚’è¡¨ç¤ºã—ã¾ã™ã€‚
            </div>
          </div>
          <div class="help-row">
            <div class="help-icon">ğŸ‘€</div>
            <div class="help-content">
              <b>é–²è¦§ãƒ¢ãƒ¼ãƒ‰</b>
              èª¤æ“ä½œã‚’é˜²ããªãŒã‚‰ã€ãƒ”ãƒ³ãƒæ“ä½œï¼ˆ2æœ¬æŒ‡ï¼‰ã§æ‹¡å¤§ãƒ»ç¸®å°ã‚„ç§»å‹•ãŒã§ãã¾ã™ã€‚
            </div>
          </div>
        </div>
      </div>

    </div>

    <div class="modal-footer">
      <button id="helpCloseBtn" type="button">é–‰ã˜ã‚‹</button>
    </div>
  </div>
</div>



<div id="labelModal" class="modal-overlay">
<div class="modal sheet">
<h3 id="labelModalTitle" style="margin:0 0 6px;">éƒ¨å±‹ã‚’è¿½åŠ </h3>
<div id="labelModalSub" style="font-size:12px;color:#666;margin-bottom:10px;">ãƒ—ãƒªã‚»ãƒƒãƒˆã‚’ã‚¿ãƒƒãƒ—ã§å³è¿½åŠ  / å…¥åŠ›ã—ã¦OKã§ã‚‚è¿½åŠ </div>

<input type="text" id="labelInput" placeholder="éƒ¨å±‹åï¼ˆå…¥åŠ›è¿½åŠ ï¼‰" maxlength="12">

<div style="display:flex; gap:10px; margin:12px 0 6px; align-items:center;">
<button class="small-btn gray" id="openPresetBtn" type="button" style="height:36px;">ãƒ—ãƒªã‚»ãƒƒãƒˆç·¨é›†</button>

<!-- âœ… è¿½åŠ æ™‚ã‚‚è‰²ã‚’é¸ã¹ã‚‹ï¼ˆiOSå¯¾å¿œï¼‰ -->
<label id="addColorBtn" class="small-btn gray color-label" style="height:36px;">
è‰²
<input type="color" id="addColorInput" value="#FFF3E0">
</label>

<div id="addHint" style="font-size: 12px; color: #666; align-self: center; display: block;">â€»ãƒãƒƒãƒ—ã¯å³è¿½åŠ </div>
</div>

<div class="chip-grid" id="labelChips"></div>

<div style="display:flex; gap:10px; margin-top:14px;">
<button style="flex:1; background:rgba(120,120,128,.45); color:#fff;" id="labelCancelBtn" type="button">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
<button style="flex:1; background:var(--accent);" id="labelOkBtn" type="button">OK</button>
</div>
</div>
</div>

<div id="menuModal" class="modal-overlay">
<div class="modal sheet">
<h3 style="margin:0 0 6px;">ãƒ¡ãƒ‹ãƒ¥ãƒ¼</h3>
<div id="menuTitle" style="font-size:12px;color:#666;margin-bottom:8px;">é¸æŠä¸­</div>

<div class="menu-list">
<button class="menu-btn" id="menuEditBtn" type="button">åå‰å¤‰æ›´</button>

<!-- âœ… è‰²å¤‰æ›´ï¼ˆiOS Safariã§ã‚‚ç¢ºå®Ÿã«é–‹ãï¼‰ -->
<label class="menu-btn menu-color-label" id="menuColorBtn" title="è‰²ã‚’å¤‰æ›´">
<span>è‰²å¤‰æ›´</span>
<span class="menu-color-dot" aria-hidden="true"></span>
<input type="color" id="menuColorInput" value="#FFF3E0">
</label>

<button class="menu-btn" id="menuDupBtn" type="button">è¤‡è£½</button>
<button class="menu-btn danger" id="menuDelBtn" type="button">å‰Šé™¤</button>
</div>

<div style="display:flex; gap:10px; margin-top:14px;">
<button style="flex:1; background:rgba(120,120,128,.45); color:#fff;" id="menuCloseBtn" type="button">é–‰ã˜ã‚‹</button>
</div>
</div>
</div>

<div id="presetModal" class="modal-overlay">
<div class="modal sheet">
<h3 style="margin:0 0 6px;">ãƒ—ãƒªã‚»ãƒƒãƒˆç·¨é›†</h3>
<div style="font-size:12px;color:#666;margin-bottom:8px;">éƒ¨å±‹åã¨è‰²ã‚’è¿½åŠ /å¤‰æ›´ã§ãã¾ã™</div>

<input id="presetSearch" type="text" placeholder="æ¤œç´¢ï¼ˆä¾‹ï¼šLDKï¼‰">

<div class="preset-list" id="presetList"></div>

<div class="preset-footer">
<div style="display:flex; gap:10px; margin-top:12px;">
<button class="small-btn gray" id="presetAddBtn" type="button" style="height:42px;">ï¼‹è¿½åŠ </button>
<button class="small-btn" id="presetSaveBtn" type="button" style="height:42px;">ä¿å­˜</button>
</div>

<div style="display:flex; gap:10px; margin-top:10px;">
<button style="flex:1; background:rgba(120,120,128,.45); color:#fff;" id="presetCloseBtn" type="button">é–‰ã˜ã‚‹</button>
</div>
</div>
</div>
</div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
import {
getFirestore, collection, addDoc, getDoc, doc, setDoc
} from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

const firebaseConfig = {
apiKey: "AIzaSyBH4zoH5ZnfPcZmmXNvfeGOJz9__KkSMrg",
authDomain: "test-55430.firebaseapp.com",
projectId: "test-55430",
storageBucket: "test-55430.firebasestorage.app",
messagingSenderId: "742726212885",
appId: "1:742726212885:web:597a48fc1ce0cb7f529d1c",
measurementId: "G-PW24JY2LBP"
};

const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

const el = (id) => document.getElementById(id);

// canvas
let canvas = el('canvas'); // â˜… const ã‹ã‚‰ let ã«å¤‰æ›´
let ctx = canvas.getContext('2d'); // â˜… const ã‹ã‚‰ let ã«å¤‰æ›´

const container = el('canvas-container');

// --- canvas view (Retinaå¯¾å¿œ) ---
let VIEW_W = 0;     // è¡¨ç¤ºä¸Šã®å¹…ï¼ˆCSS px / ä»®æƒ³ã‚­ãƒ£ãƒ³ãƒã‚¹æ™‚ã¯å†…éƒ¨pxï¼‰
let VIEW_H = 0;     // è¡¨ç¤ºä¸Šã®é«˜ã•ï¼ˆCSS px / ä»®æƒ³ã‚­ãƒ£ãƒ³ãƒã‚¹æ™‚ã¯å†…éƒ¨pxï¼‰
let RENDER_DPR = 1; // Retinaç­‰ã®è§£åƒåº¦å€ç‡ï¼ˆä»®æƒ³ã‚­ãƒ£ãƒ³ãƒã‚¹æ™‚ã¯1ï¼‰

// constants
const GRID_SIZE = 32;
const HISTORY_MAX = 50;

const PRESET_KEY = "floorplan_presets_v1";
const LAYOUTS_KEY = "floorplan_saved_layouts_v2";
const DRAFT_KEY = "floorplan_draft_v1";
const DRAFT_TTL_MS = 1000 * 60 * 60 * 24 * 14; // 14æ—¥ï¼ˆä»»æ„ï¼‰ // v2: editable only list

const WALL_THICK_KEY = "wallThick_v1";
let WALL_DEFAULT_THICK = 12;
const WALL_HANDLE_R = 18;
const WALL_HIT_PAD = 12;
const SNAP_ANGLE_DEG = 15;

const AUTOSAVE_DELAY = 1500;
const TSUBO_TO_M2 = 3.305785;

const MOVE_HANDLE_R = 14;
const MOVE_HANDLE_HIT = 22;

const SMALL_ROOM_MAX_MASU = 4;

// state
let items = [];
let selectedItem = null;
let isMerged = false;
let camera = { x: 0, y: 0 };
let scale = 1.0;

let lastTapTime = 0;
let overlapPick = { key: null, idx: 0, ts: 0 };
let layoutId = null;
let isReadOnly = false;

let isViewMode = false; // é–²è¦§ï¼ˆãƒ‘ãƒ³/ã‚ºãƒ¼ãƒ å„ªå…ˆï¼‰
let isExporting = false; // â˜…è¿½åŠ : ç”»åƒå‡ºåŠ›ä¸­ãƒ•ãƒ©ã‚°


let currentTitle = "MORIYASUğŸ ";

const DEFAULT_TITLE = "MORIYASUğŸ ";

function setTitle(raw, opts={}){
const t = String(raw ?? "").replace(/\n/g, " ").trim() || DEFAULT_TITLE;
currentTitle = t;

// UI
try{ el('topTitle').innerText = t; }catch(_){}
try{ el('layoutTitleInput').value = t; }catch(_){}

// Readonlyã§ã¯ä¿å­˜ã—ãªã„
if(isReadOnly) return;

// ãƒ‰ãƒ©ãƒ•ãƒˆä¿å­˜ï¼†ï¼ˆidãŒã‚ã‚Œã°ï¼‰Firestoreä¿å­˜ã®äºˆç´„
if(!opts.silent){
scheduleAutoSave();
if(layoutId) upsertLayoutMeta(layoutId, { title: currentTitle });
}
}


let editingItem = null;
let menuItem = null;

let labelModalMode = "edit";
let addPendingColor = "#FFF3E0";

let isMeasureMode = false;
let measurePoints = [];

let isWallPlaceMode = false;
let wallPlaceStart = null; // {x,y} when placing wall by 2 taps

// history
let undoStack = [];
let redoStack = [];
let gestureSnapshot = null;

// autosave
let autosaveTimer = null;

// presets
let presets = [];
let presetSearchQuery = "";

// touch state
let longPressTimer = null;
let pressStart = null;
let pressStartWorld = null;
let pendingItem = null;
let pendingWallHandle = null;
let pendingAction = null;
let dragActive = false;
let rectDragOffset = null;
let wallMoveOffset = null;
let emptyTapCandidate = false;

// pinch
let pinchActive = false;
let pinchStartDist = 0;
let pinchStartScale = 1;
let pinchWorldMid = null;

// polyfill: roundRect
if(!CanvasRenderingContext2D.prototype.roundRect){
CanvasRenderingContext2D.prototype.roundRect = function(x,y,w,h,r){
r = Math.min(r, w/2, h/2);
this.beginPath();
this.moveTo(x+r, y);
this.arcTo(x+w, y, x+w, y+h, r);
this.arcTo(x+w, y+h, x, y+h, r);
this.arcTo(x, y+h, x, y, r);
this.arcTo(x, y, x+w, y, r);
this.closePath();
return this;
};
}

function uid(){
return Math.random().toString(36).slice(2, 10) + Date.now().toString(36).slice(-4);
}

function ensureIds(){
items.forEach(it => {
if(!it.id) it.id = uid();
if(typeof it.locked !== "boolean") it.locked = false;
if(it.type === 'wallLine'){
if(typeof it.thick !== "number") it.thick = WALL_DEFAULT_THICK;
if(!it.color) it.color = "#111";
if(!it.label) it.label = "å£";
}
if(it.type !== 'wallLine'){
if(!it.color) it.color = "#FFF3E0";
if(!it.label) it.label = "éƒ¨å±‹";
}
});
}

function normalizeZ(){
const frames = items.filter(i => i.type === 'frame');
const others = items.filter(i => i.type !== 'frame');
items = [...frames, ...others];
}

function getSnapStep(){
return el('useHalfGrid').checked ? 16 : 32;
}
function getSnapped(val, step){
return Math.round(val / step) * step;
}
function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

/* coordinate */
function screenToWorld(screenX, screenY){
const rect = canvas.getBoundingClientRect();
// clientX/Y ã¯CSS pxãªã®ã§ã€ã“ã“ã‚‚CSS pxåŸºæº–ã§åˆã‚ã›ã‚‹ï¼ˆRetinaå†…éƒ¨è§£åƒåº¦ã¨åˆ†é›¢ï¼‰
const cx = rect.width/2;
const cy = rect.height/2;
const x = (screenX - rect.left - cx - camera.x) / scale;
const y = (screenY - rect.top - cy - camera.y) / scale;
return {x,y};
}

/* firestore save */
async function saveLayoutToFirestore(){
if(!layoutId || isReadOnly) return;
try{
await setDoc(doc(db, "layouts", layoutId), {
items,
isMerged,
title: currentTitle,
readonly: false,
updatedAt: new Date()
}, { merge: true });
}catch(e){
console.warn("save failed", e);
}
}

function scheduleAutoSave(){
if(isReadOnly) return;

// âœ… idãŒç„¡ãã¦ã‚‚ãƒ‰ãƒ©ãƒ•ãƒˆä¿å­˜ï¼ˆãŠæ°—ã«å…¥ã‚Šèµ·å‹•ã§ã‚‚å¾©å…ƒã§ãã‚‹ï¼‰
saveDraft();

// Firestoreä¿å­˜ã¯ç·¨é›†IDãŒã‚ã‚‹æ™‚ã ã‘
if(!layoutId) return;

if(autosaveTimer) clearTimeout(autosaveTimer);
autosaveTimer = setTimeout(async () => {
await saveLayoutToFirestore();
touchLayoutMeta(layoutId);
}, AUTOSAVE_DELAY);
}

async function ensureEditableLayoutId(){
if(layoutId) return layoutId;
const r = await addDoc(collection(db, "layouts"), {
items,
isMerged,
title: currentTitle,
readonly: false,
createdAt: new Date(),
updatedAt: new Date()
});
layoutId = r.id;
const newUrl = `${window.location.origin}${window.location.pathname}?id=${layoutId}`;
history.replaceState(null, "", newUrl);
upsertLayoutMeta(layoutId, { title: currentTitle, updatedAt: Date.now() });
return layoutId;
}

async function createReadOnlyShareSnapshot(){
// å…±æœ‰ã¯ã€Œèª­ã¿å–ã‚Šå°‚ç”¨ã‚³ãƒ”ãƒ¼ã€ã‚’ç™ºè¡Œ
const r = await addDoc(collection(db, "layouts"), {
items,
isMerged,
title: currentTitle,
readonly: true,
createdAt: new Date(),
updatedAt: new Date()
});
return r.id;
}

/* history */
function snapshot(){
ensureIds();
return {
items: items.map(i => ({...i})),
selectedId: selectedItem?.id || null,
isMerged,
camera: {...camera},
scale,
layoutId,
title: currentTitle
};
}

function restore(s){
items = (s.items || []).map(i => ({...i}));
ensureIds();
normalizeZ();
isMerged = !!s.isMerged;
camera = s.camera ? {...s.camera} : {x:0,y:0};
scale = typeof s.scale === "number" ? s.scale : 1.0;
layoutId = s.layoutId ?? layoutId;
setTitle(s.title || currentTitle, {silent:true});

selectedItem = s.selectedId ? items.find(i => i.id === s.selectedId) || null : null;
updateSegmentUI();
updateWorkHint();
draw();
}

/* --- Draft (ãŠæ°—ã«å…¥ã‚Šèµ·å‹•ã§ã‚‚å¾©å…ƒã§ãã‚‹) --- */
function saveDraft(){
try{
const s = snapshot();
localStorage.setItem(DRAFT_KEY, JSON.stringify({ ...s, ts: Date.now() }));
}catch(_){}
}
function loadDraft(){
try{
const raw = localStorage.getItem(DRAFT_KEY);
if(!raw) return null;
const d = JSON.parse(raw);
if(!d) return null;
if(d.ts && (Date.now() - d.ts > DRAFT_TTL_MS)) return null;
if(!Array.isArray(d.items) || d.items.length === 0) return null;
return d;
}catch(_){ return null; }
}
function clearDraft(){
try{ localStorage.removeItem(DRAFT_KEY); }catch(_){}
}
async function maybeRestoreDraftOnBoot(){
const d = loadDraft();
if(!d) return false;

const title = (d.title || "ç„¡é¡Œ").slice(0, 24);
const ok = confirm(`æœ€å¾Œã«ä½œæ¥­ã—ã¦ã„ãŸã€Œ${title}ã€ã‚’å¾©å…ƒã—ã¾ã™ã‹ï¼Ÿ`);
if(!ok) return false;

restore(d);

// ç·¨é›†URLã‚’ç¢ºä¿ã—ã¦ä»¥å¾Œã®ä¿å­˜ã‚’å®‰å®šã•ã›ã‚‹
await ensureEditableLayoutId();
if(!isReadOnly){
await saveLayoutToFirestore();
touchLayoutMeta(layoutId);
}
return true;
}

// âœ… è¿½åŠ : ã‚¿ãƒ–ã‚’é–‰ã˜ã‚‹/ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã«å›ã‚‹æ™‚ã«ã‚‚ãƒ‰ãƒ©ãƒ•ãƒˆã‚’ç¢ºå®Ÿã«ä¿å­˜ï¼ˆSafari/iOSå¯¾ç­–ï¼‰
window.addEventListener('pagehide', () => { try{ if(!isReadOnly) saveDraft(); }catch(_){} });
document.addEventListener('visibilitychange', () => {
try{
if(document.visibilityState === 'hidden' && !isReadOnly) saveDraft();
}catch(_){}
});

function pushHistory(){
if(isReadOnly) return;
undoStack.push(snapshot());
if (undoStack.length > HISTORY_MAX) undoStack.shift();
redoStack = [];
syncHistoryButtons();
}

function undo(){
if (isReadOnly) return;
if (!undoStack.length) return;
redoStack.push(snapshot());
restore(undoStack.pop());
syncHistoryButtons();
scheduleAutoSave();
}

function redo(){
if (isReadOnly) return;
if (!redoStack.length) return;
undoStack.push(snapshot());
restore(redoStack.pop());
syncHistoryButtons();
scheduleAutoSave();
}

function syncHistoryButtons(){
el('undoBtn').disabled = isReadOnly || undoStack.length === 0;
el('redoBtn').disabled = isReadOnly || redoStack.length === 0;
}

/* presets */
function defaultPresets(){
// å›³é¢ã£ã½ãè¦‹ãˆã‚‹ã‚ˆã†ã«å…¨ä½“çš„ã«æ·¡ã„è‰²ã«å¯„ã›ã‚‹
return [
{ name: "LDK", color: "#F4EBD2" },
{ name: "æ´‹å®¤", color: "#F7F3EA" },
{ name: "å¯å®¤", color: "#F2F6EF" },
{ name: "åœŸé–“", color: "#F1F1F1" },
{ name: "åç´", color: "#F6F2F7" },
{ name: "æ´—é¢", color: "#EFF7F7" },
{ name: "ãƒˆã‚¤ãƒ¬", color: "#FFF9E6" },
{ name: "ç„é–¢", color: "#F8EFEA" },
];
}
function loadPresets(){
try{
const raw = localStorage.getItem(PRESET_KEY);
if(raw){
const arr = JSON.parse(raw);
if(Array.isArray(arr) && arr.length){
return arr.map(p => ({
name: String(p.name||"").trim() || "éƒ¨å±‹",
color: String(p.color||"#FFF3E0")
}));
}
}
}catch(_){}
return defaultPresets();
}
function savePresets(){
localStorage.setItem(PRESET_KEY, JSON.stringify(presets));
}
function escapeHtml(s){
return String(s).replace(/[&<>"']/g, m => ({
"&":"&amp;",
"<":"&lt;",
">":"&gt;",
'"':"&quot;",
"'":"&#39;"
}[m]));
}

function onPresetPicked(name, color){
if(isReadOnly) return;
if(labelModalMode === "add"){
addPendingColor = color || addPendingColor || "#FFF3E0";
el('addColorInput').value = addPendingColor;
closeLabelModal();
addRect(name, 4, 4, addPendingColor, 'room');
return;
}
el('labelInput').value = name;
applyLabel(true, color);
}

function renderPresetChips(){
const box = el('labelChips');
box.innerHTML = "";
presets.forEach(p => {
const b = document.createElement("button");
b.type = "button";
b.className = "name-chip";
b.innerHTML = `<span class="dot" style="background:${p.color}"></span><span>${escapeHtml(p.name)}</span>`;
b.addEventListener("click", () => onPresetPicked(p.name, p.color));
box.appendChild(b);
});
}

function renderPresetEditorList(){
const list = el('presetList');
list.innerHTML = "";
const q = (presetSearchQuery || "").toLowerCase();
const visible = presets
.map((p, idx) => ({...p, idx}))
.filter(p => !q || (p.name || "").toLowerCase().includes(q));

visible.forEach(({name, color, idx}) => {
const row = document.createElement("div");
row.className = "preset-row";
row.innerHTML = `
<input type="text" value="${escapeHtml(name)}" maxlength="12" data-idx="${idx}" data-k="name">
<input type="color" value="${color}" data-idx="${idx}" data-k="color">
<button class="preset-del" type="button" data-idx="${idx}">å‰Šé™¤</button>
`;
list.appendChild(row);
});

list.querySelectorAll('input').forEach(inp => {
inp.addEventListener('input', () => {
const i = Number(inp.dataset.idx);
const k = inp.dataset.k;
if(!presets[i]) return;
if(k === 'name') presets[i].name = (inp.value || "").trim().slice(0,12) || "éƒ¨å±‹";
if(k === 'color') presets[i].color = inp.value || "#FFF3E0";
});
});
list.querySelectorAll('.preset-del').forEach(btn => {
btn.addEventListener('click', () => {
const i = Number(btn.dataset.idx);
presets.splice(i, 1);
renderPresetEditorList();
});
});
}

el('presetList').addEventListener('focusin', (e) => {
const row = e.target.closest?.('.preset-row');
if(row) row.scrollIntoView({ block: 'center', behavior: 'smooth' });
});

/* layouts list (editable only) */
function loadLayouts(){
try{
const raw = localStorage.getItem(LAYOUTS_KEY);
const arr = raw ? JSON.parse(raw) : [];
if(Array.isArray(arr)) return arr;
}catch(_){}
return [];
}
function saveLayouts(arr){
localStorage.setItem(LAYOUTS_KEY, JSON.stringify(arr));
}
function formatDate(ts){
try{
const d = new Date(ts);
return d.toLocaleString('ja-JP', { month:'2-digit', day:'2-digit', hour:'2-digit', minute:'2-digit' });
}catch(_){ return ""; }
}
function upsertLayoutMeta(id, patch){
const list = loadLayouts();
const idx = list.findIndex(x => x.id === id);
const title = patch.title || currentTitle || "MORIYASUğŸ ";

if(idx >= 0){
list[idx] = { ...list[idx], ...patch, title };
}else{
list.unshift({ id, title, updatedAt: patch.updatedAt || Date.now() });
}
saveLayouts(list);
}
function touchLayoutMeta(id){
if(!id) return;
upsertLayoutMeta(id, { updatedAt: Date.now() });
}
function renderLayoutList(){
const box = el('layoutList');
box.innerHTML = "";
const list = loadLayouts();

if(!list.length){
box.innerHTML = `<div style="font-size:13px;color:#666;">ã¾ã ä¿å­˜ãŒã‚ã‚Šã¾ã›ã‚“</div>`;
return;
}

list.forEach((it) => {
const row = document.createElement('div');
row.className = 'layout-row';
row.innerHTML = `
<input type="text" value="${escapeHtml(it.title || "MORIYASUğŸ ")}" maxlength="24" data-id="${it.id}">
<button class="layout-btn" type="button" data-act="open" data-id="${it.id}">é–‹ã</button>
<button class="layout-btn" type="button" data-act="newtab" data-id="${it.id}">æ–°è¦ã‚¿ãƒ–</button>
<button class="layout-del" type="button" data-act="del" data-id="${it.id}">Ã—</button>
<div style="grid-column:1 / -1; font-size:11px; color:#999; margin-top:-4px; text-align:right;">
${formatDate(it.updatedAt || Date.now())}
</div>
`;
box.appendChild(row);
});

box.querySelectorAll('input[type="text"]').forEach(inp => {
inp.addEventListener('input', () => {
const id = inp.dataset.id;
upsertLayoutMeta(id, { title: (inp.value||"").trim().slice(0,24) || "é–“å–ã‚Š" });
});
});

box.querySelectorAll('button').forEach(btn => {
const act = btn.dataset.act;
const id = btn.dataset.id;
if(!act || !id) return;

btn.addEventListener('click', () => {
const url = `${window.location.origin}${window.location.pathname}?id=${id}`;
if(act === 'open') window.location.href = url;
if(act === 'newtab') window.open(url, "_blank");
if(act === 'del'){
const list = loadLayouts().filter(x => x.id !== id);
saveLayouts(list);
renderLayoutList();
}
});
});
}

/* ui helpers */
function resizeCanvas(){
  // è¡¨ç¤ºä¸Šã®ã‚µã‚¤ã‚ºï¼ˆCSS pxï¼‰
  VIEW_W = container.clientWidth;
  VIEW_H = container.clientHeight;

  // ç«¯æœ«ã®DPRï¼ˆé‡ããªã‚Šã™ããªã„ã‚ˆã†ä¸Šé™3ã«ã‚¯ãƒ©ãƒ³ãƒ—ï¼‰
  const dpr = window.devicePixelRatio || 1;
  RENDER_DPR = Math.max(1, Math.min(3, dpr));

  // CSSã‚µã‚¤ã‚ºã‚’å›ºå®šã—ã€å†…éƒ¨è§£åƒåº¦ã ã‘ä¸Šã’ã‚‹ï¼ˆRetinaå¯¾ç­–ï¼‰
  canvas.style.width = VIEW_W + "px";
  canvas.style.height = VIEW_H + "px";

  canvas.width  = Math.round(VIEW_W * RENDER_DPR);
  canvas.height = Math.round(VIEW_H * RENDER_DPR);

  draw();
}
function updateSegmentUI(){
el('segEdit').classList.toggle('active', !isMerged);
el('segMerge').classList.toggle('active', isMerged);
}

function setMergedMode(val){
  // æ—¢ã«åŒã˜ãªã‚‰ä½•ã‚‚ã—ãªã„
  if(isMerged === val) return;

  // â–¼ ãƒ¢ãƒ¼ãƒ‰æ›´æ–°
  isMerged = val;

  // ãƒ¢ãƒ¼ãƒ‰åˆ‡æ›¿æ™‚ã«ã€é¸æŠãŒä¸æ•´åˆã ã¨UIãŒè¿·ã†ã®ã§è§£é™¤
  if(isMerged){
    if(selectedItem && selectedItem.type === 'frame') selectedItem = null;
  }else{
    if(selectedItem && selectedItem.type !== 'frame') selectedItem = null;
  }

  // é€²è¡Œä¸­ã®ã‚¿ãƒƒãƒæ“ä½œã‚’ãƒªã‚»ãƒƒãƒˆï¼ˆåˆ‡æ›¿ç›´å¾Œã®æŒ™å‹•ãŒå®‰å®šã™ã‚‹ï¼‰
  try{ clearTouchState(); }catch(_){}

  updateSegmentUI();
  updateModeAvailability();
  updateWorkHint();
  syncViewBtn();

  // âœ… é‡è¦ï¼šãƒ¢ãƒ¼ãƒ‰åˆ‡æ›¿ã¯ã€Œå³ã€åæ˜ ã™ã‚‹
  // iOS Safariã§ requestAnimationFrame ãŒé…å»¶ã™ã‚‹ã“ã¨ãŒã‚ã‚Šã€
  // ãã®å ´åˆã€Œæ¬¡ã«ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’è§¦ã‚‹ã¾ã§åæ˜ ã•ã‚Œãªã„ã€ã‚ˆã†ã«è¦‹ãˆã‚‹ãŸã‚
  draw();
}




/* --- UX helpers: mode hint + toast --- */
let toastTimer = null;
/* âœ… ä¿®æ­£ç‰ˆ: ç¬¬3å¼•æ•°ã§ã€Œå¤§ãã„ãƒ¢ãƒ¼ãƒ‰ã€ã‚’é¸ã¹ã‚‹ã‚ˆã†ã«ã™ã‚‹ */
function showToast(msg, ms=1800, isLarge=false){
const t = el('toast');
if(!t) return;

t.textContent = msg;

// å¤§ãã„ãƒ¢ãƒ¼ãƒ‰ãªã‚‰ã‚¯ãƒ©ã‚¹ã‚’è¿½åŠ ã€é•ãˆã°å‰Šé™¤
if(isLarge) t.classList.add('large');
else t.classList.remove('large');

t.classList.add('show');
clearTimeout(toastTimer);

// å¤§ãã„æ™‚ã¯å°‘ã—é•·ãè¡¨ç¤ºã™ã‚‹ï¼ˆ2.5ç§’ï¼‰
const duration = isLarge ? 2500 : ms;
toastTimer = setTimeout(() => t.classList.remove('show'), duration);
}


function updateModeAvailability(){
// å¤–å£ãƒ¢ãƒ¼ãƒ‰ = ç·¨é›†(!isMerged): å¤–æ ã®ã¿ã‚’è§¦ã‚‹æƒ³å®š
const outer = !isMerged;
const btnRoom = el('addGenericRoomBtn2');
const btnWall = el('addInnerWallBtn2');
const btnFrame = el('addFrameBtn2');

if(btnRoom) btnRoom.disabled = outer;
if(btnWall) btnWall.disabled = outer;
if(btnFrame) btnFrame.disabled = !outer;

// å¤–å£ãƒ¢ãƒ¼ãƒ‰ã«åˆ‡ã‚Šæ›¿ãˆãŸã‚‰å£è¨­ç½®ã¯è§£é™¤
if(outer){
isWallPlaceMode = false;
wallPlaceStart = null;
updateWorkHint();
const wb = el('addInnerWallBtn2');
if(wb) wb.classList.remove('active');
}
}

function updateWorkHint(){
const h = el('workHint');
if(!h) return;

if(isViewMode){
h.innerHTML = "<b>é–²è¦§ãƒ¢ãƒ¼ãƒ‰</b>ï¼šãƒ‰ãƒ©ãƒƒã‚°ã§ç§»å‹•ï¼ãƒ”ãƒ³ãƒã§ã‚ºãƒ¼ãƒ ï¼ˆè§£é™¤ï¼šé–²è¦§ãƒœã‚¿ãƒ³ï¼‰";
return;
}

if(isMeasureMode){
h.innerHTML = "<b>è¨ˆæ¸¬</b>ï¼š2ç‚¹ã‚’ã‚¿ãƒƒãƒ—ï¼ˆè§£é™¤ï¼šè¨ˆæ¸¬ãƒœã‚¿ãƒ³ï¼‰";
return;
}
if(isWallPlaceMode){
if(!wallPlaceStart){
h.innerHTML = "<b>å†…å£</b>ï¼šå§‹ç‚¹ã‚’ã‚¿ãƒƒãƒ— â†’ æ¬¡ã«çµ‚ç‚¹ã‚’ã‚¿ãƒƒãƒ—ï¼ˆè§£é™¤ï¼šå†…å£ãƒœã‚¿ãƒ³ï¼‰";
}else{
h.innerHTML = "<b>å†…å£</b>ï¼šçµ‚ç‚¹ã‚’ã‚¿ãƒƒãƒ—ï¼ˆè§£é™¤ï¼šå†…å£ãƒœã‚¿ãƒ³ï¼‰";
}
return;
}

if(!isMerged){
h.innerHTML = "<b>å¤–å£è¨­å®šãƒ¢ãƒ¼ãƒ‰</b>ï¼šå¤–æ ã‚’ãƒ‰ãƒ©ãƒƒã‚°ã§ç§»å‹•ï¼è§’ã§ã‚µã‚¤ã‚ºèª¿æ•´ï¼ˆå®Œäº†ã—ãŸã‚‰ã€Œéƒ¨å±‹ã€ã¸ï¼‰";
}else{
h.innerHTML = "<b>éƒ¨å±‹è¨­å®šãƒ¢ãƒ¼ãƒ‰</b>ï¼šéƒ¨å±‹ã‚’è¿½åŠ  â†’ é…ç½®ï¼å†…å£ï¼š2ç‚¹ã‚¿ãƒƒãƒ—ã§è¨­ç½®";
}
}

/* ä¿®æ­£ç‰ˆ: éƒ¨å±‹(room)ã¯ç„¡è¦–ã—ã€ã€Œå¤–æ (frame)ã€ã®é¢ç©ã ã‘ã‚’åˆè¨ˆã™ã‚‹ï¼ˆå»ºç¯‰å›³é¢æ–¹å¼ï¼‰ */
function updateSummary(){
let tm = 0;

items.forEach(i => {
// å¤–æ (frame)ã ã‘ã‚’è¶³ã™
// â€»Lå­—ã®å®¶ã«ã™ã‚‹å ´åˆã¯ã€ã€Œå¤–æ ã€ãƒœã‚¿ãƒ³ã§æ ã‚’2ã¤è¿½åŠ ã—ã¦ä¸¦ã¹ã¦ãã ã•ã„
if(i.type === 'frame') {
tm += (i.w/GRID_SIZE) * (i.h/GRID_SIZE);
}
});

const tsubo = tm/4;
const jou = tm/2;
const m2 = tsubo * TSUBO_TO_M2;

el('totalTsubo').innerText = tsubo.toFixed(2);
el('totalJou').innerText = jou.toFixed(1);
el('totalM2').innerText = m2.toFixed(1);

el('jouWrap').style.display = (el('showJou')?.checked ?? true) ? "" : "none";
el('m2Wrap').style.display = (el('showM2')?.checked ?? true) ? "" : "none";
}


/* âœ… ä¿®æ­£ç‰ˆ: é¸æŠçŠ¶æ…‹ã«å¿œã˜ã¦ãƒœãƒˆãƒ ãƒãƒ¼ã‚’åˆ‡ã‚Šæ›¿ãˆã‚‹ */
function syncBottomBarState(){
const defBar = el('defaultBar');
if(!defBar) return;

// âœ… æç”»é ˜åŸŸã¯ã€Œ1æ®µãƒãƒ¼ã€åˆ†ã®ä½™ç™½ã§å›ºå®šï¼ˆã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’ç‹­ã‚ãªã„ï¼‰
const baseMB = "calc(96px + env(safe-area-inset-bottom))";
if(container) container.style.marginBottom = baseMB;

// ãƒœãƒˆãƒ ãƒãƒ¼ã¯å¸¸ã«è¡¨ç¤ºï¼ˆé€£ç¶šè¿½åŠ ã§ãã‚‹ï¼‰
defBar.style.display = 'grid';

// ãƒ¢ãƒ¼ãƒ‰åæ˜ ï¼ˆå¤–æ /éƒ¨å±‹ï¼‰
const outer = !isMerged;
defBar.classList.toggle('mode-outer', outer);

// è¦ç´ å‚ç…§
const btnRoom  = el('addGenericRoomBtn2');
const btnWall  = el('addInnerWallBtn2');
const btnFrame = el('addFrameBtn2');

const nameBtn  = el('editNameBtn');
const nameDisp = el('selectedNameDisplay');

const colorLabel = el('selectedColorLabel');
const colorInp = el('selectedColorInput');
const colorDot = el('selectedColorDot');

const dupBtn = el('dupSelectedBtn');
const delBtn = el('delSelectedBtn');

// === å¤–æ ãƒ¢ãƒ¼ãƒ‰ï¼šå¤–å£è¿½åŠ ï¼‹å‰Šé™¤ã®ã¿ ===
if(outer){
if(btnFrame) btnFrame.style.display = '';
if(btnRoom) btnRoom.style.display = 'none';
if(btnWall) btnWall.style.display = 'none';
if(nameBtn) nameBtn.style.display = 'none';
if(colorLabel) colorLabel.style.display = 'none';
if(dupBtn) dupBtn.style.display = 'none';

if(delBtn) delBtn.style.display = '';

const isFrameSel = !!(selectedItem && selectedItem.type === 'frame');
const canAdd = !isReadOnly;
const canDel = isFrameSel && !isReadOnly && !selectedItem.locked;

if(btnFrame) btnFrame.disabled = !canAdd;

if(delBtn){
if(isFrameSel){
delBtn.textContent = "å‰Šé™¤";
delBtn.dataset.sub = "å¤–å£";
delBtn.disabled = !canDel;
}else{
delBtn.textContent = "å…¨æ¶ˆå»";
delBtn.dataset.sub = "å¤–å£";
delBtn.disabled = isReadOnly;
}
}
return;
}

// === éƒ¨å±‹ãƒ¢ãƒ¼ãƒ‰ï¼šéƒ¨å±‹/å†…å£ + åå‰/è‰² + è¤‡è£½/å‰Šé™¤ ===
if(btnFrame) btnFrame.style.display = 'none';
if(btnRoom) btnRoom.style.display = '';
if(btnWall) btnWall.style.display = '';
if(nameBtn) nameBtn.style.display = '';
if(colorLabel) colorLabel.style.display = '';
if(dupBtn) dupBtn.style.display = '';
if(delBtn) delBtn.style.display = '';

const hasSel = !!selectedItem;

if(nameDisp){
nameDisp.textContent = hasSel ? (selectedItem.label || "ï¼ˆç„¡åï¼‰") : "æœªé¸æŠ";
}

const canEdit = hasSel && !isReadOnly && !selectedItem.locked;

if(nameBtn) nameBtn.disabled = !canEdit;

if(colorInp){
const c = hasSel ? (selectedItem.color || "#FFF3E0") : "#ffffff";
colorInp.value = c;
colorInp.disabled = !canEdit;
}
if(colorDot){
colorDot.style.background = hasSel ? (selectedItem.color || "#FFF3E0") : "#ffffff";
}

if(dupBtn){
dupBtn.disabled = !canEdit;
}

if(delBtn){
if(hasSel){
delBtn.textContent = "å‰Šé™¤";
delBtn.dataset.sub = "é¸æŠ";
delBtn.disabled = (isReadOnly || selectedItem.locked);
}else{
delBtn.textContent = "å…¨æ¶ˆå»";
delBtn.dataset.sub = "ç¢ºèª";
delBtn.disabled = isReadOnly;
}
}
}







/* âœ… è‰²UIåŒæœŸ */
function syncColorUI(){
const btn = el('quickColorBtn');
const inp = el('quickColorInput');

if(!selectedItem || isReadOnly || selectedItem.locked){
btn.dataset.disabled = "1";
btn.style.setProperty('--swatch', '#ffffff');
return;
}

btn.dataset.disabled = "0";
const c = selectedItem.color || "#FFF3E0";
inp.value = c;
btn.style.setProperty('--swatch', c);
}


/* âœ… å£å¤ªã•UIåŒæœŸï¼ˆã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã¯ã€Œå…¨ã¦ã®å†…å£ã€ã«é©ç”¨ï¼‰ */
function syncWallThickUI(){
const slider = el('wallThickSlider');
const val = el('wallThickVal');
if(!slider || !val) return;

slider.disabled = isReadOnly;

// å£ã‚’é¸æŠã—ã¦ã„ã‚‹æ™‚ã¯ãã®å£ã®å¤ªã•ã‚’ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã«åˆã‚ã›ã‚‹ï¼ˆé•ã†å€¤ã®ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆèª­ã¿è¾¼ã¿å¯¾ç­–ï¼‰
if(selectedItem && selectedItem.type === 'wallLine'){
const t = Number(selectedItem.thick ?? WALL_DEFAULT_THICK);
if(Number.isFinite(t)){
slider.value = String(t);
val.textContent = String(t);
WALL_DEFAULT_THICK = t;
}
}else{
slider.value = String(WALL_DEFAULT_THICK);
val.textContent = String(WALL_DEFAULT_THICK);
}
}

function applyWallThicknessToAll(newThick, {respectLock=true} = {}){
const t = Number(newThick);
if(!Number.isFinite(t)) return;

WALL_DEFAULT_THICK = t;

items.forEach(it => {
if(it.type !== 'wallLine') return;
if(respectLock && it.locked) return;
it.thick = t;
if(!it.color) it.color = "#111";
});

// UI
const slider = el('wallThickSlider');
const val = el('wallThickVal');
if(slider) slider.value = String(t);
if(val) val.textContent = String(t);

try{ localStorage.setItem(WALL_THICK_KEY, String(t)); }catch(_){}
draw();
}


function addRect(label, w, h, color, type='room'){
if(isReadOnly) return;

// frame(å¤–æ )ã®å ´åˆã¯ã€è¿½åŠ ä½ç½®ã‚’æ¢ã‚‹ãƒ­ã‚¸ãƒƒã‚¯ãªã©ãŒå¿…è¦ã§ã™ãŒ
// ä»Šå›ã¯ã€Œéƒ¨å±‹ã€ã®UXæ”¹å–„ãªã®ã§ã€frameã®å³å¯†ãªãƒªã‚¸ã‚§ã‚¯ãƒˆå‡¦ç†ã¯ãã®ã¾ã¾ã«ã—ã¾ã™
const prev = (type === 'frame') ? snapshot() : null;
if(type !== 'frame') pushHistory();

// ç”»é¢ä¸­å¤®ä»˜è¿‘ã€ã¾ãŸã¯å·¦ä¸Šã«é…ç½®
const targetX = getSnapped((-camera.x + VIEW_W/2/scale) - (w*GRID_SIZE/2), GRID_SIZE);
const targetY = getSnapped((-camera.y + VIEW_H/2/scale) - (h*GRID_SIZE/2), GRID_SIZE);

// ã‚‚ã—è¨ˆç®—ãŒå¤‰ãªã‚‰å…ƒã®ãƒ­ã‚¸ãƒƒã‚¯ï¼ˆå·¦ä¸Šï¼‰ã¸
// const targetX = getSnapped((-camera.x)/scale, GRID_SIZE);
// const targetY = getSnapped((-camera.y)/scale, GRID_SIZE);

const i = { id: uid(), locked:false, type, x: targetX, y: targetY, w: w*GRID_SIZE, h: h*GRID_SIZE, label, color };
if(type === 'frame') items.unshift(i); else items.push(i);

ensureIds();
normalizeZ();
selectedItem = i;

// frame è¿½åŠ ç›´å¾Œã®é‡ãªã‚Šãƒã‚§ãƒƒã‚¯ï¼ˆframeã¯å¾“æ¥é€šã‚Šå³ã—ãå¼¾ãï¼‰
if(type === 'frame' && frameOverlapsAny(i)){
restore(prev);
showToast("å¤–æ ãŒé‡ãªã£ã¦ã„ã¾ã™ã€‚å ´æ‰€ã‚’ãšã‚‰ã—ã¦è¿½åŠ ã—ã¦ãã ã•ã„");
return;
}

// frame è¿½åŠ æˆåŠŸæ™‚ã®å±¥æ­´å‡¦ç†
if(type === 'frame'){
undoStack.push(prev);
if (undoStack.length > HISTORY_MAX) undoStack.shift();
redoStack = [];
syncHistoryButtons();
}

draw();

// âœ… éƒ¨å±‹ã®é‡ãªã‚Šãƒã‚§ãƒƒã‚¯ï¼ˆè­¦å‘Šã®ã¿ã§ã€å–ã‚Šæ¶ˆã—ã¯ã—ãªã„ï¼‰
if(type === 'room' && checkRoomOverlaps()){
showToast("âš  éƒ¨å±‹ãŒé‡ãªã£ã¦ã„ã¾ã™", 2000);
} else if(type === 'room') {
showToast('ä¸­å¤®ãƒãƒ³ãƒ‰ãƒ«ã§ç§»å‹• / å³ä¸‹ãƒãƒ³ãƒ‰ãƒ«ã§ã‚µã‚¤ã‚º / è‰²ã¯å³ä¸Š');
}

scheduleAutoSave();
}



function addWallBetween(p1, p2){
if(isReadOnly) return;
const x1 = p1.x, y1 = p1.y, x2 = p2.x, y2 = p2.y;
if(x1 === x2 && y1 === y2) return;

pushHistory();
const w = {
type: 'wallLine',
x1, y1, x2, y2,
thick: WALL_DEFAULT_THICK,
color: '#111'
};
items.push(w);
ensureIds();
normalizeZ();
selectedItem = w;
draw();
scheduleAutoSave();
}

function setWallPlaceMode(on){
isWallPlaceMode = !!on;
wallPlaceStart = null;

const btn = el('addInnerWallBtn2');
if(btn){
btn.classList.toggle('active', isWallPlaceMode);
}

// å£è¨­ç½®ä¸­ã¯è¨ˆæ¸¬ã¨æ’ä»–
if(isWallPlaceMode){
isMeasureMode = false;
measurePoints = [];
const mb = el('measureBtn');
if(mb){
mb.classList.remove('active');
mb.classList.add('gray');
}
selectedItem = null;
}
draw();
}

function toggleWallPlaceMode(){
if(isReadOnly) return;
setWallPlaceMode(!isWallPlaceMode);
}

/* menu actions */

function openMenu(item){
if(!item) return;
menuItem = item;
const lockedText = item.locked ? "ï¼ˆãƒ­ãƒƒã‚¯ï¼‰" : "";
el('menuTitle').innerText = `${item.label || "ï¼ˆç„¡åï¼‰"} / ${item.type}${lockedText}`;

// è‰²å…¥åŠ›ã®åˆæœŸå€¤
el('menuColorInput').value = item.color || "#FFF3E0";
el('menuColorBtn').style.setProperty('--swatch', el('menuColorInput').value);

el('menuModal').style.display = 'flex';
}
function closeMenu(){
el('menuModal').style.display = 'none';
menuItem = null;
}
function duplicateItem(it){
if(isReadOnly) return;
if(!it) return;
pushHistory();
let n;
if(it.type === 'wallLine'){
n = { ...it, id: uid(), x1: it.x1 + GRID_SIZE, y1: it.y1 + GRID_SIZE, x2: it.x2 + GRID_SIZE, y2: it.y2 + GRID_SIZE };
}else{
n = { ...it, id: uid(), x: it.x + GRID_SIZE, y: it.y + GRID_SIZE };
}
items.push(n);
normalizeZ();
selectedItem = n;
draw();
scheduleAutoSave();
}
function deleteItem(it){
if(isReadOnly) return;
if(!it) return;
pushHistory();
items = items.filter(x => x !== it);
selectedItem = null;
normalizeZ();
draw();
scheduleAutoSave();
}
function bringFront(it){
if(isReadOnly) return;
if(!it) return;
pushHistory();
items = items.filter(x => x !== it);
items.push(it);
normalizeZ();
draw();
scheduleAutoSave();
}
function bringBack(it){
if(isReadOnly) return;
if(!it) return;
pushHistory();
const frames = items.filter(i => i.type === 'frame');
const others = items.filter(i => i.type !== 'frame' && i !== it);
items = [...frames, it, ...others];
normalizeZ();
draw();
scheduleAutoSave();
}
function toggleLock(it){
if(isReadOnly) return;
if(!it) return;
pushHistory();
it.locked = !it.locked;
draw();
scheduleAutoSave();
}

/* label modal */
function openLabelModal(mode){
if(isReadOnly) return;

// å¤–æ ãƒ¢ãƒ¼ãƒ‰ã§ã¯éƒ¨å±‹è¿½åŠ ã—ãªã„ï¼ˆå‘¼ã³å‡ºã—çµŒè·¯ãŒå¢—ãˆã¦ã‚‚æ­¢ã‚ã‚‹ï¼‰
if(mode === "add" && !isMerged){
showToast("å¤–æ ãƒ¢ãƒ¼ãƒ‰ã§ã¯éƒ¨å±‹ã‚’è¿½åŠ ã§ãã¾ã›ã‚“ï¼ˆã€Œéƒ¨å±‹ã€ãƒ¢ãƒ¼ãƒ‰ã«åˆ‡ã‚Šæ›¿ãˆã¦ãã ã•ã„ï¼‰");
return;
}

labelModalMode = mode;
el('labelModal').style.display = 'flex';

if(mode === "add"){
el('labelModalTitle').innerText = "éƒ¨å±‹ã‚’è¿½åŠ ";
el('labelModalSub').innerText = "ãƒ—ãƒªã‚»ãƒƒãƒˆã‚’ã‚¿ãƒƒãƒ—ã§å³è¿½åŠ  / å…¥åŠ›ã—ã¦OKã§ã‚‚è¿½åŠ ";
el('addHint').style.display = "block";
el('labelInput').placeholder = "éƒ¨å±‹åï¼ˆå…¥åŠ›è¿½åŠ ï¼‰";
el('labelInput').value = "";
el('addColorInput').value = addPendingColor || "#FFF3E0";
el('addColorBtn').style.display = "";
}else{
el('labelModalTitle').innerText = "éƒ¨å±‹åã‚’å¤‰æ›´";
el('labelModalSub').innerText = "å€™è£œã‚’ã‚¿ãƒƒãƒ—ï¼ˆåå‰ï¼‹è‰²ï¼‰ / å…¥åŠ›ã—ã¦OK";
el('addHint').style.display = "none";
el('labelInput').placeholder = "éƒ¨å±‹å";
el('addColorBtn').style.display = "none";
}

setTimeout(() => el('labelInput').focus(), 50);
}

function closeLabelModal(){
el('labelModal').style.display = 'none';
labelModalMode = "edit";
editingItem = null;
}

function openLabelEditor(item){
if(isReadOnly) return;
if(!item) return;
editingItem = item;
el('labelInput').value = item.label || "";
openLabelModal("edit");
}

function applyLabel(applyColor=false, colorValue=null){
if(isReadOnly) return;
if (!editingItem) return;
const v = el('labelInput').value.trim();
if (!v) return;

pushHistory();
editingItem.label = v;
if(applyColor && colorValue) editingItem.color = colorValue;

closeLabelModal();
draw();
scheduleAutoSave();
}

/* wall helpers */
function distPointToSegment(px, py, x1, y1, x2, y2){
const vx = x2 - x1, vy = y2 - y1;
const wx = px - x1, wy = py - y1;
const c1 = vx*wx + vy*wy;
if (c1 <= 0) return Math.hypot(px - x1, py - y1);
const c2 = vx*vx + vy*vy;
if (c2 <= c1) return Math.hypot(px - x2, py - y2);
const t = c1 / c2;
const bx = x1 + t*vx;
const by = y1 + t*vy;
return Math.hypot(px - bx, py - by);
}
function wallHitTest(worldP, wall){
const handleRWorld = WALL_HANDLE_R / scale;
const padWorld = WALL_HIT_PAD / scale;
const d1 = Math.hypot(worldP.x - wall.x1, worldP.y - wall.y1);
if(d1 <= handleRWorld) return {hit:true, handle:"p1"};
const d2 = Math.hypot(worldP.x - wall.x2, worldP.y - wall.y2);
if(d2 <= handleRWorld) return {hit:true, handle:"p2"};
const dSeg = distPointToSegment(worldP.x, worldP.y, wall.x1, wall.y1, wall.x2, wall.y2);
const thickWorld = (wall.thick || WALL_DEFAULT_THICK) / scale;
if(dSeg <= (thickWorld/2 + padWorld)) return {hit:true, handle:null};
return {hit:false, handle:null};
}
function applyRightAngleSnap(wall, movingHandle){
const ax = (movingHandle === "p1") ? wall.x2 : wall.x1;
const ay = (movingHandle === "p1") ? wall.y2 : wall.y1;
const bx = (movingHandle === "p1") ? wall.x1 : wall.x2;
const by = (movingHandle === "p1") ? wall.y1 : wall.y2;

const dx = bx - ax;
const dy = by - ay;
const adx = Math.abs(dx), ady = Math.abs(dy);
if(adx < 1e-6 && ady < 1e-6) return;

const tan = Math.tan(SNAP_ANGLE_DEG * Math.PI/180);
if(ady <= adx * tan){
if(movingHandle === "p1") wall.y1 = wall.y2;
else wall.y2 = wall.y1;
return;
}
if(adx <= ady * tan){
if(movingHandle === "p1") wall.x1 = wall.x2;
else wall.x2 = wall.x1;
}
}

/* rect helpers */
function isSmallRoom(it){
if(!it || it.type !== 'room') return false;
const masu = (it.w/GRID_SIZE) * (it.h/GRID_SIZE);
return masu <= SMALL_ROOM_MAX_MASU;
}
function rectMoveHandleCenter(it){
return { x: it.x + it.w/2, y: it.y + it.h/2 };
}
function rectMoveHandleHit(worldP, it){
const c = rectMoveHandleCenter(it);
const r = MOVE_HANDLE_HIT / scale;
return Math.hypot(worldP.x - c.x, worldP.y - c.y) <= r;
}

function getResizeHandleRadiusPx(it){
if(!it) return 18;
// å°ã•ã„éƒ¨å±‹ãƒ»å¤–æ ã¯ã‚¿ãƒƒãƒ—ã—ã‚„ã™ãå°‘ã—å¤§ãã‚
if(it.type === 'frame') return 26;
if(it.type === 'room' && isSmallRoom(it)) return 24;
return 18;
}
function rectResizeHandleHit(worldP, it){
if(!it || (it.type !== 'room' && it.type !== 'frame')) return false;
const hx = it.x + it.w;
const hy = it.y + it.h;
const rad = getResizeHandleRadiusPx(it);
const dx = worldP.x - hx;
const dy = worldP.y - hy;
return (dx*dx + dy*dy) <= (rad/scale) * (rad/scale);
}

// çŸ©å½¢ã®é‡ãªã‚Šï¼ˆé¢ç©ãŒæ­£ã«é‡ãªã‚‹æ™‚ã ã‘ trueã€‚è¾ºãŒæ¥ã™ã‚‹ã ã‘ã¯ falseï¼‰
function rectOverlap(a, b){
return (a.x < b.x + b.w) && (a.x + a.w > b.x) &&
(a.y < b.y + b.h) && (a.y + a.h > b.y);
}
function frameOverlapsAny(target){
if(!target || target.type !== 'frame') return false;
for(const f of items){
if(f.type !== 'frame') continue;
if(f.id === target.id) continue;
if(rectOverlap(target, f)) return true;
}
return false;
}
function anyFrameOverlap(){
const frames = items.filter(i => i.type === 'frame');
for(let i=0;i<frames.length;i++){
for(let j=i+1;j<frames.length;j++){
if(rectOverlap(frames[i], frames[j])) return true;
}
}
return false;
}

/* draw */
function drawGrid(){
ctx.strokeStyle = "#e5e5ea";
ctx.lineWidth = 0.5 / scale;
const range = 1600;
for (let x = -range; x <= range; x += GRID_SIZE) {
ctx.beginPath();
ctx.moveTo(x, -range); ctx.lineTo(x, range); ctx.stroke();
}
for (let y = -range; y <= range; y += GRID_SIZE) {
ctx.beginPath();
ctx.moveTo(-range, y); ctx.lineTo(range, y); ctx.stroke();
}
}

/* âœ… ä¿®æ­£ç‰ˆ: å¡—ã‚Šã¤ã¶ã—å°‚ç”¨ï¼ˆã‚°ãƒªãƒƒãƒ‰ã®ä¸‹ã«æãï¼‰ */
function drawRectFill() {
const rects = items.filter(i => i.type !== 'wallLine');
rects.forEach(item => {
ctx.fillStyle = item.color;
// éƒ¨å±‹ã¯å°‘ã—è–„ãã€å¤–æ ãªã©ã¯æ¿ƒã
ctx.globalAlpha = item.type === 'room' ? 0.35 : 1.0;
ctx.fillRect(item.x, item.y, item.w, item.h);
ctx.globalAlpha = 1.0;

if (item.locked) {
ctx.fillStyle = "rgba(0,0,0,0.08)";
ctx.fillRect(item.x, item.y, item.w, item.h);
}
});
}

/* âœ… ä¿®æ­£ç‰ˆ: å¤–å£ãƒ¢ãƒ¼ãƒ‰æ™‚ã¯éƒ¨å±‹ã®æ ç·šãƒ»ãƒ©ãƒ™ãƒ«ã‚’éè¡¨ç¤ºã«ã™ã‚‹ï¼ˆå®Œå…¨ç‰ˆï¼‰ */
function drawRectStroke() {
const rects = items.filter(i => i.type !== 'wallLine');
const mag = isExporting ? 1.8 : 1.0;

// 1. æ ç·šï¼ˆStrokeï¼‰ã®æç”»
rects.forEach(item => {
// â˜…è¿½åŠ : å¤–å£ãƒ¢ãƒ¼ãƒ‰(!isMerged) ã‹ã¤ éƒ¨å±‹(room) ã®å ´åˆã¯æ ç·šã‚’æã‹ãªã„
if (!isMerged && item.type === 'room') return;

const isFrame = item.type === 'frame';
const baseStroke = "#333"; 

if (isSmallRoom(item)) {
ctx.strokeStyle = "rgba(255,255,255,0.95)"; ctx.lineWidth = 4 / scale;
ctx.strokeRect(item.x, item.y, item.w, item.h);
ctx.strokeStyle = baseStroke; ctx.lineWidth = 2 / scale;
ctx.strokeRect(item.x, item.y, item.w, item.h);
} else {
ctx.strokeStyle = baseStroke; ctx.lineWidth = isFrame ? 2 / scale : 1 / scale;
ctx.strokeRect(item.x, item.y, item.w, item.h);
}
});

// 2. ãƒ©ãƒ™ãƒ«ï¼ˆæ–‡å­—ï¼‰ã®æç”»
rects.forEach(item => {
// â˜…è¿½åŠ : å¤–å£ãƒ¢ãƒ¼ãƒ‰(!isMerged) ã‹ã¤ éƒ¨å±‹(room) ã®å ´åˆã¯ãƒ©ãƒ™ãƒ«ã‚’æã‹ãªã„
if (!isMerged && item.type === 'room') return;

const label = item.locked ? `${item.label} ğŸ”’` : (item.label || "");
if (!label) return;

const baseSize = isSmallRoom(item) ? 11 : 13;
const fontSize = (baseSize * mag) / scale;
const x = item.x + item.w / 2;
const y = item.y + item.h / 2;

ctx.save();
ctx.textAlign = "center";
ctx.textBaseline = "middle";
ctx.font = `900 ${fontSize}px sans-serif`;
ctx.lineJoin = "round";
ctx.lineWidth = 4 / scale;
ctx.strokeStyle = "rgba(255,255,255,0.95)";
ctx.strokeText(label, x, y);
ctx.fillStyle = "#111";
ctx.fillText(label, x, y);
ctx.restore();
});

// 3. é¸æŠæ ã®æç”»ï¼ˆã“ã®ãƒ–ãƒ­ãƒƒã‚¯ãŒãªã„ã¨æ“ä½œä¸­ã«å›ºã¾ã£ã¦è¦‹ãˆã¾ã™ï¼‰
if(selectedItem && !isMerged && selectedItem.type !== 'wallLine'){
ctx.strokeStyle = "#007AFF";
ctx.lineWidth = 3 / scale;
ctx.strokeRect(selectedItem.x, selectedItem.y, selectedItem.w, selectedItem.h);

if(!selectedItem.locked && !isReadOnly){
drawMoveHandleRect(selectedItem);
ctx.fillStyle = "#fff";
ctx.strokeStyle = "#007AFF";
ctx.lineWidth = 2/scale;
ctx.beginPath();
ctx.arc(selectedItem.x + selectedItem.w, selectedItem.y + selectedItem.h, getResizeHandleRadiusPx(selectedItem)/scale, 0, Math.PI*2);
ctx.fill();
ctx.stroke();
}
if(dragActive && pendingItem === selectedItem){
drawSizeBadge(selectedItem);
}
}
}




function drawWallLine(wall){
const thick = wall.thick ?? WALL_DEFAULT_THICK;

ctx.save();
// å›³é¢ãƒ©ã‚¤ã‚¯ï¼šè§’ã°ã£ãŸç«¯
ctx.lineCap = "butt";
ctx.strokeStyle = wall.color || "#111";
ctx.lineWidth = thick / scale;

ctx.beginPath();
ctx.moveTo(wall.x1, wall.y1);
ctx.lineTo(wall.x2, wall.y2);
ctx.stroke();

ctx.restore();
}

function drawWallSelection(wall){
ctx.save();
ctx.lineCap = "round";
ctx.strokeStyle = "#007AFF";
ctx.lineWidth = ((wall.thick || WALL_DEFAULT_THICK) + 4) / scale;
ctx.globalAlpha = 0.25;
ctx.beginPath();
ctx.moveTo(wall.x1, wall.y1);
ctx.lineTo(wall.x2, wall.y2);
ctx.stroke();
ctx.globalAlpha = 1;

if(!wall.locked && !isReadOnly){
const r = WALL_HANDLE_R / scale;
ctx.fillStyle = "#fff";
ctx.strokeStyle = "#007AFF";
ctx.lineWidth = 2/scale;
ctx.beginPath(); ctx.arc(wall.x1, wall.y1, r, 0, Math.PI*2); ctx.fill(); ctx.stroke();
ctx.beginPath(); ctx.arc(wall.x2, wall.y2, r, 0, Math.PI*2); ctx.fill(); ctx.stroke();
}
ctx.restore();
}

function drawMoveHandleRect(it){
const c = rectMoveHandleCenter(it);
const r = MOVE_HANDLE_R / scale;

ctx.save();
ctx.fillStyle = "#fff";
ctx.strokeStyle = "#007AFF";
ctx.lineWidth = 2/scale;

ctx.beginPath();
ctx.arc(c.x, c.y, r, 0, Math.PI*2); ctx.fill(); ctx.stroke();

ctx.beginPath();
ctx.moveTo(c.x - r*0.55, c.y);
ctx.lineTo(c.x + r*0.55, c.y);
ctx.moveTo(c.x, c.y - r*0.55);
ctx.lineTo(c.x, c.y + r*0.55);
ctx.stroke();

ctx.restore();
}

function drawSizeBadge(it){
const mw = (it.w / GRID_SIZE).toFixed(1).replace('.0','');
const mh = (it.h / GRID_SIZE).toFixed(1).replace('.0','');
const text = (it.type === 'frame') ? `å¤–æ : ${mw}Ã—${mh}ãƒã‚¹` : `${mw}Ã—${mh}ãƒã‚¹`;
const pad = 8/scale;
ctx.save();
ctx.font = `900 ${12/scale}px sans-serif`;
const w = ctx.measureText(text).width + pad*2;
const h = 22/scale;
const x = it.x;
const y = it.y - (h + 8/scale);

ctx.fillStyle = "rgba(0,122,255,0.92)";
ctx.roundRect(x, y, w, h, 10/scale);
ctx.fill();

ctx.fillStyle = "#fff";
ctx.fillText(text, x + pad, y + 15/scale);
ctx.restore();
}

/* âœ… éƒ¨å±‹ã®é‡ãªã‚Šãƒã‚§ãƒƒã‚¯é–¢æ•° */
function checkRoomOverlaps() {
const rooms = items.filter(i => i.type === 'room');
let hasOverlap = false;

for (let i = 0; i < rooms.length; i++) {
for (let j = i + 1; j < rooms.length; j++) {
// rectOverlap ã¯æ—¢å­˜ã®é–¢æ•°ã‚’ä½¿ç”¨
if (rectOverlap(rooms[i], rooms[j])) {
hasOverlap = true;
break;
}
}
if (hasOverlap) break;
}
return hasOverlap;
}


/* âœ… ä¿®æ­£ç‰ˆ: 0ã‚¹ã‚¿ãƒ¼ãƒˆã€å¤–æ åŸºæº–ã€æ•°å­—ä½ç½®ã‚’å…ƒã«æˆ»ã™ */
function drawBlueprintGrid(targetItems) {
// 1. å¤–æ (frame)ã¾ãŸã¯å…¨ä½“ã®ç¯„å›²ã‚’å–å¾—
const frames = targetItems.filter(i => i.type === 'frame');
const targets = frames.length ? frames : targetItems.filter(i => i.type !== 'wallLine');
if (!targets.length) return;

let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
targets.forEach(it => {
minX = Math.min(minX, it.x);
minY = Math.min(minY, it.y);
maxX = Math.max(maxX, it.x + it.w);
maxY = Math.max(maxY, it.y + it.h);
});

// â˜…ä¿®æ­£: ä½™ç™½ã‚°ãƒªãƒƒãƒ‰ã¯ä½œã‚‰ãšã€å»ºç‰©ã®ç«¯(minX, minY)ã‚’ãã®ã¾ã¾é–‹å§‹ä½ç½®ã«ã™ã‚‹
const startX = Math.floor(minX / GRID_SIZE) * GRID_SIZE;
const startY = Math.floor(minY / GRID_SIZE) * GRID_SIZE;
const endX = Math.ceil(maxX / GRID_SIZE) * GRID_SIZE;
const endY = Math.ceil(maxY / GRID_SIZE) * GRID_SIZE;

ctx.save();
const lw = isExporting ? 1 / scale : 0.5 / scale;
ctx.lineWidth = lw;
ctx.strokeStyle = "#888"; 

// ç‚¹ç·šè¨­å®š
ctx.setLineDash([2 / scale, 3 / scale]); 

// æ–‡å­—è¨­å®š
const fontSize = (isExporting ? 20 : 11) / scale;
ctx.font = `normal ${fontSize}px sans-serif`;
ctx.textAlign = "center";
ctx.textBaseline = "middle";
ctx.fillStyle = "#555";

// â˜…ä¿®æ­£: æ•°å­—ã¨ç·šã®è·é›¢ã‚’å…ƒã®ã€Œè¿‘ã‚ã€ã«æˆ»ã™
const padding = (isExporting ? 20 : 12) / scale; 

// â–  ç¸¦ç·šã¨Xåº§æ¨™ç•ªå·
// â˜…ä¿®æ­£: startXã‚’ã€Œ0ã€ã¨ã—ã¦ã‚«ã‚¦ãƒ³ãƒˆã™ã‚‹
for (let x = startX; x <= endX; x += GRID_SIZE) {
ctx.beginPath();
ctx.moveTo(x, startY - padding); 
ctx.lineTo(x, endY + padding); 
ctx.stroke();

if (isExporting || scale > 0.5) {
// å·¦ç«¯(startX)ã‹ã‚‰ã®è·é›¢ã‚’ãƒã‚¹æ•°(910mmå˜ä½)ã«æ›ç®—ã—ã¦è¡¨ç¤º
const val = Math.round((x - startX) / GRID_SIZE);
const label = String(val);
ctx.fillText(label, x, startY - (padding * 1.5));
ctx.fillText(label, x, endY + (padding * 1.5));
}
}

// â–  æ¨ªç·šã¨Yåº§æ¨™ç•ªå·
for (let y = startY; y <= endY; y += GRID_SIZE) {
ctx.beginPath();
ctx.moveTo(startX - padding, y);
ctx.lineTo(endX + padding, y);
ctx.stroke();

if (isExporting || scale > 0.5) {
// ä¸Šç«¯(startY)ã‹ã‚‰ã®è·é›¢ã‚’ãƒã‚¹æ•°ã«æ›ç®—
const val = Math.round((y - startY) / GRID_SIZE);
const label = String(val);
ctx.fillText(label, startX - (padding * 1.5), y);
ctx.fillText(label, endX + (padding * 1.5), y);
}
}

ctx.restore();

return { maxX, maxY, endX, endY };
}




/* âœ… ä¿®æ­£ç‰ˆ: çµåˆå¾Œã®å½¢çŠ¶ã‚’ã‚¹ã‚­ãƒ£ãƒ³ã—ã¦ã€æœ¬å½“ã«ä¸€ç•ªåºƒã„å ´æ‰€ã«æ–‡å­—ã‚’ç½®ã drawMerged */
function drawMerged(){
  const roomMap = {};
  const frameMap = {};
  const groups = {};
  const sub = 16; // ã‚°ãƒªãƒƒãƒ‰è§£åƒåº¦
  const mag = isExporting ? 1.8 : 1.0;

  // 1. ãƒ‡ãƒ¼ã‚¿æ•´ç†ï¼ˆã‚°ãƒ«ãƒ¼ãƒ—åŒ–ï¼‰
  items.forEach((item) => {
    if(item.type === 'wallLine') return;
    
    // ã‚°ãƒ«ãƒ¼ãƒ—æƒ…å ±ã®ä½œæˆ
    if (item.type !== 'frame') {
      if (!groups[item.label]) {
        groups[item.label] = {
          label: item.label, 
          totalMasu: 0,
          minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity
        };
      }
      const g = groups[item.label];
      g.totalMasu += (item.w / GRID_SIZE) * (item.h / GRID_SIZE);
      g.minX = Math.min(g.minX, item.x); 
      g.minY = Math.min(g.minY, item.y);
      g.maxX = Math.max(g.maxX, item.x + item.w); 
      g.maxY = Math.max(g.maxY, item.y + item.h);
    }

    // çµåˆæç”»ç”¨ã®ãƒãƒƒãƒ—ä½œæˆï¼ˆã“ã‚ŒãŒé‡è¦ï¼‰
    for (let x = item.x; x < item.x + item.w; x += sub) {
      for (let y = item.y; y < item.y + item.h; y += sub) {
        const pos = `${x},${y}`;
        if (item.type === 'frame') frameMap[pos] = item.label;
        else roomMap[pos] = { label: item.label, color: item.color };
      }
    }
  });

  // 2. å…ˆã«å¡—ã‚Šã¤ã¶ã—ï¼ˆåºŠï¼‰
  items.forEach(item => {
    if(item.type === 'wallLine') return;
    if(item.type === 'frame'){
      ctx.globalAlpha = 1.0; ctx.fillStyle = "#ffffff";
    }else{
      ctx.globalAlpha = 0.22; ctx.fillStyle = item.color;
    }
    ctx.fillRect(item.x, item.y, item.w, item.h);
    ctx.globalAlpha = 1.0;
  });

  // 3. ã‚°ãƒªãƒƒãƒ‰ç·š
  const gridBounds = drawBlueprintGrid(items); 

  // 4. æ ç·šæç”»
  const drawEdge = (map, color, width) => {
    ctx.strokeStyle = color;
    ctx.lineWidth = width / scale;
    for (const pos in map) {
      const [x, y] = pos.split(',').map(Number);
      const label = map[pos].label || map[pos];
      [{dx:0, dy:-sub}, {dx:0, dy:sub}, {dx:-sub, dy:0}, {dx:sub, dy:0}].forEach(d => {
        const nb = map[`${x+d.dx},${y+d.dy}`];
        const nbLabel = nb?.label || nb;
        if (nbLabel !== label) {
          ctx.beginPath();
          if(d.dy!==0){ ctx.moveTo(x, y+(d.dy>0?sub:0)); ctx.lineTo(x+sub, y+(d.dy>0?sub:0)); } 
          else { ctx.moveTo(x+(d.dx>0?sub:0), y); ctx.lineTo(x+(d.dx>0?sub:0), y+sub); }
          ctx.stroke();
        }
      });
    }
  };
  drawEdge(roomMap, "#111", 2);
  drawEdge(frameMap, "#111", 10);

  // 5. æ–‡å­—æç”»ï¼ˆâ˜…ã“ã“ãŒæ–°ãƒ­ã‚¸ãƒƒã‚¯ï¼‰
  for (const key in groups) {
    const g = groups[key];

    // --- çµåˆå½¢çŠ¶ã‚¹ã‚­ãƒ£ãƒ³ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ  ---
    // éƒ¨å±‹ã®ç¯„å›²(BoundingBox)ã‚’1è¡Œãšã¤èµ°æŸ»ã—ã¦ã€
    // ã€Œä¸€ç•ªé•·ãé€£ç¶šã—ã¦ã„ã‚‹æ¨ªå¹…ã®ãƒ–ãƒ­ãƒƒã‚¯ã€ã‚’è¦‹ã¤ã‘å‡ºã™
    
    let bestRect = null; // {x, y, w, h}
    let currentRects = []; // å€™è£œãƒªã‚¹ãƒˆ

    // Yè»¸æ–¹å‘ã«ã‚¹ã‚­ãƒ£ãƒ³
    for (let y = g.minY; y < g.maxY; y += sub) {
      let startX = -1;
      let length = 0;
      
      // Xè»¸æ–¹å‘ã«ã‚¹ã‚­ãƒ£ãƒ³ã—ã¦ã€ã“ã®è¡Œã®æœ€é•·ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã‚’è¦‹ã¤ã‘ã‚‹
      for (let x = g.minX; x <= g.maxX; x += sub) { // <= ã¯çµ‚äº†åˆ¤å®šã®ãŸã‚
        const cell = roomMap[`${x},${y}`];
        const isMyRoom = (cell && cell.label === g.label);

        if (isMyRoom) {
          if (startX === -1) startX = x;
          length += sub;
        } else {
          if (startX !== -1) {
            // ã‚»ã‚°ãƒ¡ãƒ³ãƒˆçµ‚äº†ã€‚ãƒªã‚¹ãƒˆã«è¿½åŠ ã¾ãŸã¯çµ±åˆ
            // ç›´å‰ã®è¡Œã¨åŒã˜Xç¯„å›²ãªã‚‰ã€é«˜ã•ã‚’è¶³ã—ã¦çµ±åˆã™ã‚‹ï¼ˆå¤§ããªçŸ©å½¢ã¨ã—ã¦èªè­˜ã•ã›ã‚‹ï¼‰
            let merged = false;
            for(let r of currentRects) {
              // ã»ã¼åŒã˜Xç¯„å›²ã§ã€ã‹ã¤YãŒã¤ãªãŒã£ã¦ã„ã‚‹ãªã‚‰çµ±åˆ
              if (Math.abs(r.x - startX) < 1 && Math.abs(r.w - length) < 1 && Math.abs((r.y + r.h) - y) < 1) {
                r.h += sub;
                merged = true;
                break;
              }
            }
            if(!merged){
              currentRects.push({ x: startX, y: y, w: length, h: sub });
            }
            startX = -1;
            length = 0;
          }
        }
      }
    }

    // å€™è£œã®ä¸­ã‹ã‚‰ã€Œæœ€ã‚‚æ¨ªå¹…ãŒåºƒã„ã‚‚ã®ã€ã‚’é¸ã¶
    // â€»æ¨ªå¹…ãŒåŒã˜ãªã‚‰ã€é¢ç©ï¼ˆé«˜ã•ï¼‰ãŒå¤§ãã„æ–¹ã‚’é¸ã¶
    currentRects.forEach(r => {
      if(!bestRect) {
        bestRect = r;
      } else {
        if (r.w > bestRect.w) {
           bestRect = r; // å¹…å„ªå…ˆ
        } else if (r.w === bestRect.w) {
           if (r.h > bestRect.h) bestRect = r; // å¹…ãŒåŒã˜ãªã‚‰é¢ç©å„ªå…ˆ
        }
      }
    });

    // æ±ºå®šã—ãŸåº§æ¨™ï¼ˆè¦‹ã¤ã‹ã‚‰ãªã‘ã‚Œã°é‡å¿ƒï¼‰
    let textX, textY;
    if (bestRect) {
      textX = bestRect.x + bestRect.w / 2;
      textY = bestRect.y + bestRect.h / 2;
    } else {
      textX = (g.minX + g.maxX) / 2;
      textY = (g.minY + g.maxY) / 2;
    }

    // --- æ–‡å­—æç”»å‡¦ç†ï¼ˆä»¥ä¸‹ã¯å¤‰æ›´ãªã—ï¼‰ ---
    const isPhysicallyTiny = (g.totalMasu / 2) <= 1.5;
    const visualHeight = (g.maxY - g.minY) * scale;
    const useTinyMode = !isExporting && isPhysicallyTiny && (visualHeight < 45);

    ctx.fillStyle = "#111"; 
    ctx.lineJoin = "round";
    ctx.lineWidth = 4 / scale;
    ctx.strokeStyle = "rgba(255,255,255, 0.95)";

    if (useTinyMode) {
      ctx.textAlign = "center"; ctx.textBaseline = "top";
      const labelSize = 10 / scale;
      ctx.font = `bold ${labelSize}px sans-serif`;
      const labelY = g.minY + (2 / scale);
      ctx.strokeText(g.label, textX, labelY);
      ctx.fillText(g.label, textX, labelY);
      if (el('showJou').checked) {
        const subSize = 8 / scale;
        ctx.font = `${subSize}px sans-serif`;
        const subY = labelY + labelSize + (1 / scale);
        const subText = `${(g.totalMasu / 2).toFixed(1)}ç•³`;
        ctx.strokeText(subText, textX, subY);
        ctx.fillText(subText, textX, subY);
      }
    } else {
      ctx.textAlign = "center"; ctx.textBaseline = "middle"; 
      const mainFontSize = (14 * mag) / scale;
      ctx.font = `bold ${mainFontSize}px sans-serif`;
      const labelY = textY - (mainFontSize * 0.4); 
      
      ctx.strokeText(g.label, textX, labelY);
      ctx.fillText(g.label, textX, labelY);
      
      let subText = "";
      if (el('showJou').checked) subText += `${(g.totalMasu / 2).toFixed(1)}ç•³ `;
      if (el('showTsubo').checked) subText += `${(g.totalMasu / 4).toFixed(2)}åª`;
      
      if (subText) {
        const subFontSize = (11 * mag) / scale;
        ctx.font = `${subFontSize}px sans-serif`;
        const subY = textY + (mainFontSize * 0.7);
        ctx.strokeText(subText, textX, subY);
        ctx.fillText(subText, textX, subY);
      }
    }
    ctx.textAlign = "left";
  }

  // å£æç”»
  items.forEach(it => { if(it.type === 'wallLine') drawWallLine(it); });

  // ç”»åƒå‡ºåŠ›æ™‚ã®å³ä¸‹æƒ…å ±
  if (isExporting && gridBounds) {
    let totalMasu = 0;
    items.forEach(i => { if(i.type === 'frame') totalMasu += (i.w/GRID_SIZE) * (i.h/GRID_SIZE); });
    const tsubo = totalMasu / 4;
    const jou = totalMasu / 2;
    const m2 = tsubo * 3.305785;
    ctx.save();
    const infoFontSize = 24 / scale;
    ctx.font = `bold ${infoFontSize}px sans-serif`;
    ctx.textAlign = "right"; ctx.textBaseline = "bottom"; ctx.fillStyle = "#111";
    const anchorX = gridBounds.endX; 
    const anchorY = gridBounds.endY + (140 / scale); 
    const lineH = infoFontSize * 1.5;
    ctx.fillText(`æ–½å·¥é¢ç©: ${jou.toFixed(1)} ç•³`, anchorX, anchorY);
    ctx.fillText(`(${tsubo.toFixed(2)} åª)`, anchorX, anchorY - lineH);
    ctx.fillText(`å»¶åºŠé¢ç©: ${m2.toFixed(2)} mÂ²`, anchorX, anchorY - (lineH * 2));
    ctx.restore();
  }
}




function drawWallPlaceGuide(){
// å£è¨­ç½®ãƒ¢ãƒ¼ãƒ‰ï¼š1ç‚¹ç›®ãŒç¢ºå®šã—ã¦ã„ã‚‹æ™‚ã ã‘ãƒãƒ¼ã‚«ãƒ¼ã‚’è¡¨ç¤º
if(!isWallPlaceMode || !wallPlaceStart) return;

ctx.save();
ctx.fillStyle = "#007AFF";
ctx.strokeStyle = "rgba(255,255,255,0.95)";
ctx.lineWidth = 4/scale;

const r = 6/scale;
ctx.beginPath();
ctx.arc(wallPlaceStart.x, wallPlaceStart.y, r, 0, Math.PI*2);
ctx.fill();
ctx.stroke();
ctx.restore();
}

function drawMeasurement(){
if(!measurePoints.length) return;

// â˜…è¿½åŠ 
const mag = isExporting ? 1.8 : 1.0;

ctx.save();
ctx.fillStyle = "#FF2D55";
ctx.strokeStyle = "#FF2D55";
ctx.lineWidth = 2/scale;

const r = 5/scale;
measurePoints.forEach(p => {
ctx.beginPath(); ctx.arc(p.x, p.y, r, 0, Math.PI*2); ctx.fill();
});

if(measurePoints.length === 2){
const [p1, p2] = measurePoints;
ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.stroke();

const dist = Math.hypot(p2.x - p1.x, p2.y - p1.y);
const masVal = dist / GRID_SIZE;
const meters = (masVal * 0.91).toFixed(2);

const midX = (p1.x + p2.x)/2;
const midY = (p1.y + p2.y)/2;

// â˜…å¤‰æ›´: æ–‡å­—ã‚µã‚¤ã‚ºã« mag ã‚’æ›ã‘ã‚‹
ctx.font = `bold ${(16 * mag) / scale}px sans-serif`;
ctx.textAlign = "center";
ctx.textBaseline = "bottom";

const txt = `${meters}m`;

ctx.lineWidth = 4/scale;
ctx.lineJoin = "round";
ctx.strokeStyle = "rgba(255,255,255,0.9)";
ctx.strokeText(txt, midX, midY - 6/scale);
ctx.fillText(txt, midX, midY - 6/scale);
}
ctx.restore();
}



function draw() {

if(ctx) ctx.setTransform(RENDER_DPR, 0, 0, RENDER_DPR, 0, 0);


ctx.save();

// 1. èƒŒæ™¯ã‚¯ãƒªã‚¢
if (isExporting) {
ctx.fillStyle = "#ffffff";
ctx.fillRect(0, 0, VIEW_W, VIEW_H);
} else {
ctx.clearRect(0, 0, VIEW_W, VIEW_H);
}

// ã‚«ãƒ¡ãƒ©ä½ç½®ã¨ã‚¹ã‚±ãƒ¼ãƒ«ã®é©ç”¨
ctx.translate(VIEW_W / 2 + camera.x, VIEW_H / 2 + camera.y);
ctx.scale(scale, scale);

// 2. ãƒ¢ãƒ¼ãƒ‰ã«ã‚ˆã£ã¦æç”»ã‚’å®Œå…¨ã«åˆ†ã‘ã‚‹
if (isMerged) {
// --- éƒ¨å±‹ãƒ¢ãƒ¼ãƒ‰ï¼ˆçµåˆè¡¨ç¤ºï¼‰ ---
drawMerged();

if (selectedItem && !selectedItem.locked && !isReadOnly) {
if (selectedItem.type === 'wallLine') {
drawWallSelection(selectedItem);
} else if (selectedItem.type !== 'frame') {
ctx.strokeStyle = "#007AFF";
ctx.lineWidth = 3 / scale;
ctx.strokeRect(selectedItem.x, selectedItem.y, selectedItem.w, selectedItem.h);
drawMoveHandleRect(selectedItem);

ctx.fillStyle = "#fff";
ctx.strokeStyle = "#007AFF";
ctx.lineWidth = 2 / scale;
ctx.beginPath();
ctx.arc(selectedItem.x + selectedItem.w, selectedItem.y + selectedItem.h, getResizeHandleRadiusPx(selectedItem) / scale, 0, Math.PI * 2);
ctx.fill(); ctx.stroke();
}
}
} else {
// --- å¤–æ ãƒ¢ãƒ¼ãƒ‰ï¼ˆç·¨é›†è¡¨ç¤ºï¼‰ ---
drawRectFill();
drawBlueprintGrid(items);
drawRectStroke();

items.forEach(it => { if (it.type === 'wallLine') drawWallLine(it); });
if (selectedItem && selectedItem.type === 'wallLine') drawWallSelection(selectedItem);
}

// 3. ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤æç”»
if (isMeasureMode) drawMeasurement();
if (isWallPlaceMode) drawWallPlaceGuide();

ctx.restore();

// UIãƒ‘ãƒ¼ãƒ„ã®åŒæœŸ
updateSummary();
syncBottomBarState();
syncHistoryButtons();
syncColorUI();
syncWallThickUI();
}
window.draw = draw;



function fitToFrame() {
  // 1. å¿µã®ãŸã‚æœ€æ–°ã®ç”»é¢ã‚µã‚¤ã‚ºã‚’å–å¾—
  resizeCanvas();

  const frames = items.filter(i => i.type === 'frame');
  const targets = frames.length ? frames : items.filter(i => i.type !== 'wallLine');

  if (!targets.length) {
    camera = { x: 0, y: 0 };
    scale = 1.0;
    draw();
    return;
  }

  // 2. ç¯„å›²è¨ˆç®—
  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
  
  targets.forEach(it => {
    minX = Math.min(minX, it.x);
    minY = Math.min(minY, it.y);
    maxX = Math.max(maxX, it.x + it.w);
    maxY = Math.max(maxY, it.y + it.h);
  });
  
  items.filter(i => i.type === 'wallLine').forEach(w => {
    minX = Math.min(minX, w.x1, w.x2);
    minY = Math.min(minY, w.y1, w.y2);
    maxX = Math.max(maxX, w.x1, w.x2);
    maxY = Math.max(maxY, w.y1, w.y2);
  });

  // 3. ã‚°ãƒªãƒƒãƒ‰ç«¯ï¼‹ä½™ç™½ï¼ˆæ•°å­—ç”¨ï¼‰
  const gridStartX = Math.floor(minX / GRID_SIZE) * GRID_SIZE;
  const gridStartY = Math.floor(minY / GRID_SIZE) * GRID_SIZE;
  const gridEndX = Math.ceil(maxX / GRID_SIZE) * GRID_SIZE;
  const gridEndY = Math.ceil(maxY / GRID_SIZE) * GRID_SIZE;

  // å‘¨å›²ã®ä½™ç™½ï¼ˆ64px = ã‚°ãƒªãƒƒãƒ‰2ãƒã‚¹åˆ†ç¨‹åº¦ï¼‰
  const marginWorld = 3; 

  const contentMinX = gridStartX - marginWorld;
  const contentMinY = gridStartY - marginWorld;
  const contentMaxX = gridEndX + marginWorld;
  const contentMaxY = gridEndY + marginWorld;

  const contentW = contentMaxX - contentMinX;
  const contentH = contentMaxY - contentMinY;
  const cx = (contentMinX + contentMaxX) / 2;
  const cy = (contentMinY + contentMaxY) / 2;

  // 4. å€ç‡è¨ˆç®—
  // â˜…ä¿®æ­£ãƒã‚¤ãƒ³ãƒˆ: CSSã§ã™ã§ã«ãƒœãƒˆãƒ ãƒãƒ¼åˆ†ã®ä½™ç™½ã¯ç¢ºä¿ã•ã‚Œã¦ã„ã‚‹ã®ã§ã€
  // ã“ã“ã§ã¯ç´”ç²‹ãªã€Œè¦‹ãŸç›®ã®ã‚†ã¨ã‚Šã€åˆ†ã ã‘å¼•ã‘ã°OKã§ã™ã€‚
  const screenPadH = 40;  // å·¦å³
  const screenPadV = 60;  // ä¸Šä¸‹ï¼ˆä»¥å‰ã®160ã‹ã‚‰å¤§å¹…ã«æ¸›ã‚‰ã™ï¼‰

  const availW = VIEW_W - screenPadH;
  const availH = VIEW_H - screenPadV;

  if (contentW > 0 && contentH > 0) {
    const scaleW = availW / contentW;
    const scaleH = availH / contentH;
    let newScale = Math.min(scaleW, scaleH);
    newScale = Math.max(0.3, Math.min(2.0, newScale));
    scale = newScale;
  }

  // 5. ä¸­å¿ƒåˆã‚ã›
  camera = { x: -cx * scale, y: -cy * scale };

  draw();
}



function syncViewBtn(){
const vb = el('viewBtn');
if(!vb) return;
if(isViewMode){
vb.classList.add('view-active');
vb.classList.remove('gray');
}else{
vb.classList.remove('view-active');
vb.classList.add('gray');
}
}


// âœ… ã€Œé–²è¦§ã€ãƒœã‚¿ãƒ³ï¼ˆãƒ€ãƒ–ãƒ«ã‚¿ãƒƒãƒ—ã§å…¨ä½“è¡¨ç¤ºãƒ»é€šçŸ¥ãªã—ï¼‰
if(document.getElementById('viewBtn')){
  let lastTap = 0;
  document.getElementById('viewBtn').onclick = (e) => {
    const now = Date.now();
    if (now - lastTap < 300) {
      fitToFrame(); // ãƒ€ãƒ–ãƒ«ã‚¿ãƒƒãƒ—ã§å…¨ä½“è¡¨ç¤º
    } else {
      setViewMode(!isViewMode); // ã‚·ãƒ³ã‚°ãƒ«ã‚¿ãƒƒãƒ—ã§ãƒ¢ãƒ¼ãƒ‰åˆ‡æ›¿
    }
    lastTap = now;
  };
}

// âœ… ã€Œå…¨ä½“ã€ãƒœã‚¿ãƒ³ï¼ˆã‚¯ãƒªãƒƒã‚¯ã§å³å®Ÿè¡Œãƒ»é€šçŸ¥ãªã—ï¼‰
if(document.getElementById('fitBtn')){
  document.getElementById('fitBtn').onclick = () => {
    fitToFrame();
  };
}




/* init */
async function init(){
presets = loadPresets();
renderPresetChips();
// è‰²ã‚¹ã‚¦ã‚©ãƒƒãƒåˆæœŸåŒ–
el('quickColorBtn').style.setProperty('--swatch', '#ffffff');
el('addColorBtn').style.setProperty('--swatch', addPendingColor);
el('menuColorBtn').style.setProperty('--swatch', '#FFF3E0');


// âœ… å£å¤ªã•ï¼ˆã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ï¼‰ï¼šå…¨ã¦ã®å†…å£ã«é©ç”¨
try{
const savedThick = Number(localStorage.getItem(WALL_THICK_KEY));
if(Number.isFinite(savedThick)) WALL_DEFAULT_THICK = clamp(savedThick, 4, 24);
}catch(_){}

// åˆæœŸUIåæ˜ 
if(el('wallThickSlider')){
el('wallThickSlider').value = String(WALL_DEFAULT_THICK);
el('wallThickVal').textContent = String(WALL_DEFAULT_THICK);

let armed = false;
const armHistory = () => {
if(isReadOnly) return;
if(armed) return;
pushHistory(); // å¤‰æ›´å‰ã‚’ä¿å­˜ï¼ˆUndoå¯¾å¿œï¼‰
armed = true;
};

// å¤‰æ›´é–‹å§‹æ™‚ã«ä¸€åº¦ã ã‘å±¥æ­´ã‚’ç©ã‚€
el('wallThickSlider').addEventListener('pointerdown', armHistory);
el('wallThickSlider').addEventListener('mousedown', armHistory);
el('wallThickSlider').addEventListener('touchstart', armHistory, {passive:true});

// ã‚¹ãƒ©ã‚¤ãƒ‰ä¸­ã¯å³åæ˜ ï¼ˆå±¥æ­´ã¯ç©ã¾ãªã„ï¼‰
el('wallThickSlider').addEventListener('input', (e) => {
if(isReadOnly) return;
const v = clamp(Number(e.target.value), 4, 24);
el('wallThickVal').textContent = String(v);
applyWallThicknessToAll(v, {respectLock:true});
});

// æŒ‡ã‚’é›¢ã—ãŸã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§ä¿å­˜
el('wallThickSlider').addEventListener('change', (e) => {
if(isReadOnly) return;
const v = clamp(Number(e.target.value), 4, 24);
el('wallThickVal').textContent = String(v);
applyWallThicknessToAll(v, {respectLock:true});
armed = false;
scheduleAutoSave();
});
}


resizeCanvas();
window.addEventListener('resize', resizeCanvas);



// âœ… ãƒ¢ãƒ¼ãƒ‰åˆ‡æ›¿ï¼šãƒ¢ãƒã‚¤ãƒ«ã§ç¢ºå®Ÿã«åå¿œã•ã›ã‚‹ãŸã‚ click ã§ã¯ãªã pointerdown ã‚’å„ªå…ˆ
(function bindModeButtons(){
  const bind = (id, val) => {
    const b = el(id);
    if(!b) return;

    // äºŒé‡ç™ºç«ï¼ˆpointerdown + clickï¼‰ã‚’é¿ã‘ã‚‹
    let armed = false;

    b.addEventListener('pointerdown', (e) => {
      // iOSã§ã‚‚å³åå¿œã•ã›ã‚‹
      try{ e.preventDefault(); }catch(_){}
      armed = true;
      setMergedMode(val);
    }, {passive:false});

    b.addEventListener('click', () => {
      // pointerdown ãŒåŠ¹ã‹ãªã„ç’°å¢ƒå‘ã‘ã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
      if(armed){
        armed = false;
        return;
      }
      setMergedMode(val);
    });
  };

  bind('segEdit', false);
  bind('segMerge', true);
})();




updateModeAvailability();
updateWorkHint();

el('measureBtn').onclick = () => {
isMeasureMode = !isMeasureMode;
// è¨ˆæ¸¬ä¸­ã¯å£è¨­ç½®ã¨æ’ä»–
isWallPlaceMode = false;
wallPlaceStart = null;
updateWorkHint();
const wb = el('addInnerWallBtn2');
if(wb) wb.classList.remove('active');
measurePoints = [];
selectedItem = null;

if(isMeasureMode){
el('measureBtn').classList.add('active');
el('measureBtn').classList.remove('gray');
}else{
el('measureBtn').classList.remove('active');
el('measureBtn').classList.add('gray');
}
draw();
};


function setViewMode(on){
isViewMode = !!on;

// é–²è¦§ä¸­ã¯èª¤æ“ä½œé˜²æ­¢ã§é¸æŠè§£é™¤
if(isViewMode){
selectedItem = null;
clearTouchState();

// è¨ˆæ¸¬/å†…å£è¨­ç½®ã¯è§£é™¤ï¼ˆã‚¿ãƒƒãƒ—å‹•ä½œãŒè¡çªã™ã‚‹ãŸã‚ï¼‰
if(isMeasureMode){
isMeasureMode = false;
measurePoints = [];
const mb = el('measureBtn');
if(mb){
mb.classList.remove('active');
mb.classList.add('gray');
}
}
if(isWallPlaceMode){
isWallPlaceMode = false;
wallPlaceStart = null;
const wb = el('addInnerWallBtn2');
if(wb) wb.classList.remove('active');
}
}

syncViewBtn();
updateWorkHint();
draw();
}

// é–²è¦§ãƒ¢ãƒ¼ãƒ‰åˆ‡æ›¿
if(el('viewBtn')){
el('viewBtn').onclick = () => {
setViewMode(!isViewMode);
};
}

el('undoBtn').onclick = undo;
el('redoBtn').onclick = redo;
syncHistoryButtons();

const params = new URLSearchParams(window.location.search);
layoutId = params.get('id') || null;

if(layoutId){
const snap = await getDoc(doc(db, "layouts", layoutId));
if(snap.exists()){
const data = snap.data();
items = (data.items || []).map(i => ({...i}));
currentTitle = data.title || DEFAULT_TITLE;
isReadOnly = !!data.readonly;

setTitle(currentTitle, {silent:true});

ensureIds();
normalizeZ();

// âœ… æ—¢å­˜ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã«å£ãŒã‚ã‚‹å ´åˆã¯ã€ãã®å¤ªã•ã‚’ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼åˆæœŸå€¤ã«åˆã‚ã›ã‚‹ï¼ˆè¡¨ç¤ºã ã‘ï¼‰
const firstWall = items.find(i => i.type === 'wallLine' && typeof i.thick === 'number');
if(firstWall && Number.isFinite(firstWall.thick)){
WALL_DEFAULT_THICK = clamp(firstWall.thick, 4, 24);
if(el('wallThickSlider')){
el('wallThickSlider').value = String(WALL_DEFAULT_THICK);
el('wallThickVal').textContent = String(WALL_DEFAULT_THICK);
}
}
isMerged = !!data.isMerged;
updateSegmentUI();

// é–²è¦§ãƒ¢ãƒ¼ãƒ‰UI
el('modeBanner').style.display = isReadOnly ? "flex" : "none";
el('shareBtn').innerText = isReadOnly ? "ã‚³ãƒ”ãƒ¼ã—ã¦ç·¨é›†" : "å…±æœ‰";

if(!isReadOnly){
upsertLayoutMeta(layoutId, { title: currentTitle, updatedAt: Date.now() });
}

draw();

setTimeout(() => fitToFrame(), 100);


}else{
// idãŒå­˜åœ¨ã—ãªã„/è¦‹ã¤ã‹ã‚‰ãªã„å ´åˆï¼šãƒ‰ãƒ©ãƒ•ãƒˆå¾©å…ƒã‚’è©¦ã™
const restored = await maybeRestoreDraftOnBoot();
if(!restored){
items = [];
addRect('å¤–æ ', 2, 2, '#ffffff', 'frame');
updateSegmentUI();
draw();

setTimeout(() => fitToFrame(), 100);

}
}
}else{
// idç„¡ã—ï¼šãƒ‰ãƒ©ãƒ•ãƒˆå¾©å…ƒã‚’è©¦ã™
const restored = await maybeRestoreDraftOnBoot();
if(!restored){
addRect('å¤–æ ', 2, 2, '#ffffff', 'frame');
updateSegmentUI();
draw();
}
}
}

/* help */
/* title inline edit */
(() => {
const tt = el('topTitle');
if(!tt) return;

const stopIfReadOnly = () => {
if(isReadOnly){
tt.blur();
tt.innerText = currentTitle;
showToast("é–²è¦§ãƒ¢ãƒ¼ãƒ‰ã§ã¯åå‰ã¯å¤‰æ›´ã§ãã¾ã›ã‚“");
return true;
}
return false;
};

tt.addEventListener('focus', () => { stopIfReadOnly(); });
tt.addEventListener('keydown', (e) => {
if(e.key === 'Enter'){
e.preventDefault();
tt.blur();
}
});
tt.addEventListener('blur', () => {
if(stopIfReadOnly()) return;
const v = tt.innerText.replace(/\n/g,' ').trim();
setTitle(v);
});
})();



// âœ… ãƒãƒ‹ãƒ¥ã‚¢ãƒ«é–‹é–‰ï¼ˆèƒŒæ™¯ã‚¯ãƒªãƒƒã‚¯ or é–‰ã˜ã‚‹ãƒœã‚¿ãƒ³ï¼‰
el('openHelpBtn').onclick = () => el('helpModal').style.display = 'flex';
// é–‰ã˜ã‚‹ãƒœã‚¿ãƒ³ï¼ˆIDãŒå¤‰ã‚ã£ãŸã®ã§å¯¾å¿œï¼‰
const closeHelp = () => el('helpModal').style.display = 'none';
const helpCloseBtn = el('helpCloseBtn');
if(helpCloseBtn) helpCloseBtn.onclick = closeHelp;
// èƒŒæ™¯ã‚¿ãƒƒãƒ—ã§ã‚‚é–‰ã˜ã‚‹
el('helpModal').onclick = (e) => {
    if(e.target.id === 'helpModal') closeHelp();
};




/* share / copy-to-edit */
async function copyThisLayoutToEditable(){
// ç¾åœ¨ã®çŠ¶æ…‹ã‚’æ–°ã—ã„ç·¨é›†IDã«è¤‡è£½
const r = await addDoc(collection(db, "layouts"), {
items,
isMerged,
title: currentTitle,
readonly: false,
createdAt: new Date(),
updatedAt: new Date()
});
layoutId = r.id;
isReadOnly = false;

const newUrl = `${window.location.origin}${window.location.pathname}?id=${layoutId}`;
history.replaceState(null, "", newUrl);

el('modeBanner').style.display = "none";
el('shareBtn').innerText = "å…±æœ‰";
upsertLayoutMeta(layoutId, { title: currentTitle, updatedAt: Date.now() });

draw();
alert("ã‚³ãƒ”ãƒ¼ã—ã¦ç·¨é›†ã‚’é–‹å§‹ã—ã¾ã—ãŸï¼ˆæ–°ã—ã„URLã«ãªã‚Šã¾ã—ãŸï¼‰");
}

el('copyToEditBtn').onclick = async () => {
await copyThisLayoutToEditable();
};

el('shareBtn').onclick = async () => {
if(isReadOnly){
await copyThisLayoutToEditable();
return;
}

// ç·¨é›†ç”¨IDã‚’ç¢ºä¿ï¼ˆè‡ªåˆ†ã®ç·¨é›†ã¯è‡ªåˆ†ã®IDã«ä¿å­˜ï¼‰
await ensureEditableLayoutId();
await saveLayoutToFirestore();

// å…±æœ‰ã¯ã€Œèª­ã¿å–ã‚Šå°‚ç”¨ã‚³ãƒ”ãƒ¼ã€ã‚’ç™ºè¡Œ
const shareId = await createReadOnlyShareSnapshot();
const shareUrl = `${window.location.origin}${window.location.pathname}?id=${shareId}`;
el('shareUrlInput').value = shareUrl;

el('layoutTitleInput').value = currentTitle;
el('shareModal').style.display = 'flex';
};

el('layoutTitleInput').addEventListener('input', (e) => {
setTitle(e.target.value);
});

el('copyUrlBtn').onclick = () => {
navigator.clipboard.writeText(el('shareUrlInput').value);
alert("ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ");
};
el('closeShareModalBtn').onclick = () => el('shareModal').style.display = 'none';
el('shareModal').onclick = (e) => { if(e.target.id === 'shareModal') el('shareModal').style.display = 'none'; };

el('openLayoutsBtn').onclick = () => {
renderLayoutList();
el('layoutsModal').style.display = 'flex';
};
el('layoutsCloseBtn').onclick = () => el('layoutsModal').style.display = 'none';
el('layoutsModal').onclick = (e) => { if(e.target.id === 'layoutsModal') el('layoutsModal').style.display = 'none'; };

el('saveAsBtn').onclick = async () => {
if(isReadOnly){
await copyThisLayoutToEditable();
return;
}
// åˆ¥åä¿å­˜ï¼ˆæ–°ã—ã„ç·¨é›†IDï¼‰
const r = await addDoc(collection(db, "layouts"), {
items,
isMerged,
title: currentTitle,
readonly: false,
createdAt: new Date(),
updatedAt: new Date()
});
layoutId = r.id;
const newUrl = `${window.location.origin}${window.location.pathname}?id=${layoutId}`;
history.replaceState(null, "", newUrl);

upsertLayoutMeta(layoutId, { title: currentTitle, updatedAt: Date.now() });
alert("åˆ¥åã§ä¿å­˜ã—ã¾ã—ãŸï¼ˆæ–°ã—ã„URLã«ãªã‚Šã¾ã—ãŸï¼‰");
};


/* âœ… è‰²å¤‰æ›´ï¼ˆåŒåã®éƒ¨å±‹ã‚’ã¾ã¨ã‚ã¦å¤‰æ›´ç‰ˆãƒ»é€šçŸ¥ãªã—ï¼‰ */
function applyColorToSelected(color, targetOverride = null){
if(isReadOnly) return;
const it = targetOverride || selectedItem;
if(!it || it.locked) return;

pushHistory();

const name = it.label;

// éƒ¨å±‹(room)ã‹ã¤åå‰ãŒã‚ã‚‹å ´åˆã€åŒã˜åå‰ã®éƒ¨å±‹ã‚’å…¨ã¦å¡—ã‚‹
if(it.type === 'room' && name){
items.forEach(item => {
// ã‚¿ã‚¤ãƒ—ãŒéƒ¨å±‹ã§ã€åå‰ãŒä¸€ç·’ã§ã€ãƒ­ãƒƒã‚¯ã•ã‚Œã¦ã„ãªã‘ã‚Œã°å¡—ã‚‹
if(item.type === 'room' && item.label === name && !item.locked){
item.color = color;
}
});
// â€»é€šçŸ¥å‡¦ç†ã¯å‰Šé™¤ã—ã¾ã—ãŸ

} else {
// ãã‚Œä»¥å¤–ï¼ˆå£ã‚„å¤–æ ã€ç„¡åï¼‰ã¯å˜ä½“ã®ã¿å¤‰æ›´
it.color = color;
}

addPendingColor = color; // æ¬¡ã«è¿½åŠ ã™ã‚‹éƒ¨å±‹ã®è‰²ã«ã‚‚åæ˜ 

// ãƒ¡ãƒ‹ãƒ¥ãƒ¼è¡¨ç¤ºä¸­ãªã‚‰ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã®ã‚¢ã‚¤ã‚³ãƒ³è‰²ã‚‚æ›´æ–°
if(menuItem) el('menuColorBtn').style.setProperty('--swatch', color);

draw();
scheduleAutoSave();
}

// ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ï¼ˆã“ã“ã‚‚ã‚»ãƒƒãƒˆã§è²¼ã‚Šä»˜ã‘ã¦ãŠãã¨ç¢ºå®Ÿã§ã™ï¼‰
el('quickColorInput').addEventListener('input', (e) => applyColorToSelected(e.target.value));
el('quickColorInput').addEventListener('change', (e) => applyColorToSelected(e.target.value));

const handleMenuColor = (e) => {
applyColorToSelected(e.target.value, menuItem || selectedItem);
};
el('menuColorInput').addEventListener('input', handleMenuColor);
el('menuColorInput').addEventListener('change', handleMenuColor);

el('addColorInput').addEventListener('input', () => {
addPendingColor = el('addColorInput').value || "#FFF3E0";
el('addColorBtn').style.setProperty('--swatch', addPendingColor);
});
el('addColorInput').addEventListener('change', () => {
addPendingColor = el('addColorInput').value || "#FFF3E0";
el('addColorBtn').style.setProperty('--swatch', addPendingColor);
});



/* fit/center */

// checkboxes update
document.querySelectorAll('input[type="checkbox"]').forEach(c => c.onchange = draw);

/* label modal ok/cancel */
el('labelCancelBtn').onclick = closeLabelModal;
el('labelOkBtn').onclick = () => {
if(isReadOnly) return;
const name = el('labelInput').value.trim();
if(!name) return;

if(labelModalMode === "add"){
closeLabelModal();
addRect(name, 4, 4, addPendingColor || "#FFF3E0", 'room');
return;
}
applyLabel(false, null);
};
el('labelModal').onclick = (e) => { if (e.target.id === 'labelModal') closeLabelModal(); };
el('labelInput').addEventListener('keydown', (e) => {
if (e.key === 'Enter') el('labelOkBtn').click();
});

/* preset editor */
el('openPresetBtn').onclick = () => {
el('presetModal').style.display = 'flex';
presetSearchQuery = "";
el('presetSearch').value = "";
renderPresetEditorList();
};
el('presetSearch').addEventListener('input', (e) => {
presetSearchQuery = (e.target.value || "").trim();
renderPresetEditorList();
});
el('presetCloseBtn').onclick = () => el('presetModal').style.display = 'none';
el('presetModal').onclick = (e) => { if(e.target.id === 'presetModal') el('presetModal').style.display = 'none'; };
el('presetAddBtn').onclick = () => {
// è¿½åŠ ã—ãŸè¡Œã‚’è¦‹å¤±ã‚ãªã„ï¼šæ¤œç´¢ã‚’è§£é™¤ã—ã€è¿½åŠ è¡Œã¸ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ï¼†è‡ªå‹•ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
presetSearchQuery = "";
el('presetSearch').value = "";
presets.push({ name: "éƒ¨å±‹", color: "#FFF3E0" });
renderPresetEditorList();

// renderå¾Œã«è©²å½“inputã¸ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ï¼ˆfocusinã§scrollIntoViewãŒèµ°ã‚‹ï¼‰
const idx = presets.length - 1;
setTimeout(() => {
const inp = el('presetList')?.querySelector?.(`input[data-idx="${idx}"][data-k="name"]`);
if(inp){
inp.focus();
try{ inp.select(); }catch(_){}
}
}, 0);
};
el('presetSaveBtn').onclick = () => {
presets = presets
.map(p => ({ name: (p.name||"éƒ¨å±‹").trim().slice(0,12) || "éƒ¨å±‹", color: p.color || "#FFF3E0" }))
.filter(p => p.name.length > 0);
savePresets();
renderPresetChips();
el('presetModal').style.display = 'none';
};

/* menu modal */
el('menuCloseBtn').onclick = closeMenu;
el('menuModal').onclick = (e) => { if (e.target.id === 'menuModal') closeMenu(); };
el('menuEditBtn').onclick = () => { const it = menuItem; closeMenu(); if(it) openLabelEditor(it); };
el('menuDupBtn').onclick = () => { const it = menuItem; closeMenu(); if(it) duplicateItem(it); };
el('menuDelBtn').onclick = () => { const it = menuItem; closeMenu(); if(it) deleteItem(it); };

/* bottom actions */
el('addGenericRoomBtn2').onclick = () => {
if(isReadOnly) return;

// å¤–æ ãƒ¢ãƒ¼ãƒ‰ã§ã¯éƒ¨å±‹è¿½åŠ ã—ãªã„
if(!isMerged){
showToast("å¤–æ ãƒ¢ãƒ¼ãƒ‰ã§ã¯éƒ¨å±‹ã‚’è¿½åŠ ã§ãã¾ã›ã‚“ï¼ˆã€Œéƒ¨å±‹ã€ãƒ¢ãƒ¼ãƒ‰ã«åˆ‡ã‚Šæ›¿ãˆã¦ãã ã•ã„ï¼‰");
return;
}

editingItem = null;
addPendingColor = addPendingColor || "#FFF3E0";
openLabelModal("add");
};
const addFrameBtn2 = el('addFrameBtn2');
if(addFrameBtn2){
addFrameBtn2.onclick = () => addRect('å¤–æ ', 2, 2, '#ffffff', 'frame');
}
el('addInnerWallBtn2').onclick = () => toggleWallPlaceMode();

const dupSelectedBtn = el('dupSelectedBtn');
if(dupSelectedBtn){
dupSelectedBtn.onclick = () => { if(selectedItem) duplicateItem(selectedItem); };
}

const delSelectedBtn = el('delSelectedBtn');
if(delSelectedBtn){
delSelectedBtn.onclick = () => {
if(isReadOnly) return;

// å¤–æ ãƒ¢ãƒ¼ãƒ‰ï¼šé¸æŠä¸­ã®å¤–å£ã ã‘å‰Šé™¤ / æœªé¸æŠã¯å…¨æ¶ˆå»
if(!isMerged){
if(selectedItem && selectedItem.type === 'frame'){
deleteItem(selectedItem);
return;
}
if(confirm("å¤–å£ã‚’å…¨æ¶ˆå»ã—ã¾ã™ã‹ï¼Ÿ")){
pushHistory();
// å¤–å£ï¼ˆframeï¼‰ã ã‘æ¶ˆã™ï¼šéƒ¨å±‹/å†…å£ã¯æ®‹ã™
items = items.filter(x => x.type !== 'frame');
selectedItem = null;

// æœ€ä½1ã¤ã¯å¤–æ ã‚’æ®‹ã™ï¼ˆé¢ç©è¨ˆç®—ãƒ»ç·¨é›†ã®èµ·ç‚¹ï¼‰
addRect('å¤–æ ', 2, 2, '#ffffff', 'frame');
}
return;
}

// éƒ¨å±‹ãƒ¢ãƒ¼ãƒ‰ï¼šé¸æŠä¸­ã¯å‰Šé™¤ / æœªé¸æŠã¯å…¨æ¶ˆå»
if(selectedItem){
deleteItem(selectedItem);
return;
}
if(confirm("å…¨æ¶ˆå»ã—ã¾ã™ã‹ï¼Ÿ")){
pushHistory();
items = [];
selectedItem = null;
addRect('å¤–æ ', 2, 2, '#ffffff', 'frame');
}
};
}


// âœ… 1åˆ—ãƒœãƒˆãƒ ãƒãƒ¼ï¼šå³ç«¯ã€Œâ‹¯ã€
// - é¸æŠä¸­ï¼šãƒ¡ãƒ‹ãƒ¥ãƒ¼ï¼ˆè¤‡è£½/å‰Šé™¤/è‰²å¤‰æ›´ï¼‰
// - æœªé¸æŠï¼šå…¨æ¶ˆå»ï¼ˆæ—§ã€Œå‰Šé™¤ã€ãƒœã‚¿ãƒ³ã®ä»£æ›¿ï¼‰
const openSelectedMenuBtn = el('openSelectedMenuBtn');
if(openSelectedMenuBtn){
openSelectedMenuBtn.onclick = () => {
if(isReadOnly) return;

if(selectedItem){
openMenu(selectedItem);
return;
}

if(confirm("å…¨æ¶ˆå»ã—ã¾ã™ã‹ï¼Ÿ")) {
pushHistory();
items = [];
selectedItem = null;
addRect('å¤–æ ', 2, 2, '#ffffff', 'frame');
}
};
}

// copyBtn2 ã¯UIã‹ã‚‰å‰Šé™¤ã•ã‚Œã¦ã„ã‚‹ã“ã¨ãŒã‚ã‚‹ãŸã‚ã€å­˜åœ¨ãƒã‚§ãƒƒã‚¯ã—ã¦ã‹ã‚‰ãƒã‚¤ãƒ³ãƒ‰ï¼ˆGitHub Pagesç­‰ã§ã®JSåœæ­¢é˜²æ­¢ï¼‰
const copyBtn2 = el('copyBtn2');
if(copyBtn2){
copyBtn2.onclick = () => { if(selectedItem) duplicateItem(selectedItem); };
}

const resetBtn2 = el('resetBtn2');
if(resetBtn2){
resetBtn2.onclick = () => {
if(isReadOnly) return;
if(selectedItem) deleteItem(selectedItem);
else if(confirm("å…¨æ¶ˆå»ã—ã¾ã™ã‹ï¼Ÿ")) {
pushHistory();
items = [];
selectedItem = null;
addRect('å¤–æ ', 2, 2, '#ffffff', 'frame');
}
};
}

/* --- â–¼ è¿½åŠ : é¸æŠæ™‚ãƒœãƒˆãƒ ãƒãƒ¼ã®ã‚¤ãƒ™ãƒ³ãƒˆ --- */

// âœ… 1æ®µãƒãƒ¼é‹ç”¨: é¸æŠä¸­ã®ã€Œç·¨é›†ã€ãƒœã‚¿ãƒ³ï¼ˆãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚’é–‹ãï¼‰
if(el('editSelectedBtn')){
el('editSelectedBtn').onclick = () => {
if(selectedItem) openMenu(selectedItem);
};
}


// åå‰å¤‰æ›´ãƒœã‚¿ãƒ³
if(el('editNameBtn')){
el('editNameBtn').onclick = () => {
if(selectedItem) openLabelEditor(selectedItem);
};
}

// è‰²å¤‰æ›´
if(el('selectedColorInput')){
el('selectedColorInput').addEventListener('input', (e) => {
applyColorToSelected(e.target.value);
if(el('selectedColorDot')) el('selectedColorDot').style.background = e.target.value;
});
el('selectedColorInput').addEventListener('change', (e) => {
applyColorToSelected(e.target.value);
});
}

// è¤‡è£½
if(el('copyBtnSelected')){
el('copyBtnSelected').onclick = () => {
if(selectedItem) duplicateItem(selectedItem);
};
}

// å‰Šé™¤
if(el('deleteBtnSelected')){
el('deleteBtnSelected').onclick = () => {
if(selectedItem) deleteItem(selectedItem);
};
}

// é¸æŠè§£é™¤ï¼ˆÃ—ãƒœã‚¿ãƒ³ï¼‰
if(el('closeSelectionBtn')){
el('closeSelectionBtn').onclick = () => {
selectedItem = null;
draw(); 
};
}



/* touch handling */
function clearTouchState(){
if(longPressTimer) clearTimeout(longPressTimer);
longPressTimer = null;

pressStart = null;
pressStartWorld = null;
pendingItem = null;
pendingWallHandle = null;
pendingAction = null;
dragActive = false;
rectDragOffset = null;
wallMoveOffset = null;
emptyTapCandidate = false;
}

function startLongPress(item){
return;
}

// é–²è¦§ãƒœã‚¿ãƒ³ã®è¦‹ãŸç›®ã‚’åŒæœŸã™ã‚‹é–¢æ•°ï¼ˆã“ã‚ŒãŒæ¶ˆãˆã¦ã„ã¾ã—ãŸï¼ï¼‰


function getPinchInfo(touches){
const a = touches[0], b = touches[1];
const dx = b.clientX - a.clientX;
const dy = b.clientY - a.clientY;
const dist = Math.hypot(dx, dy);
const mid = { x: (a.clientX + b.clientX)/2, y: (a.clientY + b.clientY)/2 };
return { dist, mid };
}

canvas.addEventListener('touchstart', (e) => {
if(e.touches.length === 2){
pinchActive = true;
clearTouchState();
gestureSnapshot = (isReadOnly || isViewMode) ? null : snapshot();

const { dist, mid } = getPinchInfo(e.touches);
pinchStartDist = dist;
pinchStartScale = scale;
pinchWorldMid = screenToWorld(mid.x, mid.y);
return;
}

if(e.touches.length !== 1) return;
const t = e.touches[0];

// é–²è¦§ãƒ¢ãƒ¼ãƒ‰ï¼šé¸æŠã›ãšã«ãƒ‘ãƒ³/ã‚ºãƒ¼ãƒ ã ã‘
if(isViewMode){
clearTouchState();
pressStart = { clientX: t.clientX, clientY: t.clientY };
pressStartWorld = screenToWorld(t.clientX, t.clientY);
emptyTapCandidate = true;
pendingAction = "pan";
pendingItem = null;
draw();
return;
}

const now = Date.now();
if(!isReadOnly && now - lastTapTime < 300 && selectedItem && !isMerged){
openLabelEditor(selectedItem);
return;
}
lastTapTime = now;

clearTouchState();

pressStart = { clientX: t.clientX, clientY: t.clientY };
pressStartWorld = screenToWorld(t.clientX, t.clientY);
const worldP = pressStartWorld;

// ã™ã§ã«é¸æŠä¸­ã®è¦ç´ ã®ãƒãƒ³ãƒ‰ãƒ«ã‚’æ´ã¿ã«è¡Œã£ãŸå ´åˆã¯ã€é‡ãªã£ã¦ã„ã‚‹åˆ¥è¦ç´ ã‚ˆã‚Šã‚‚å„ªå…ˆã™ã‚‹ï¼ˆèª¤é¸æŠé˜²æ­¢ï¼‰
let found = null;
let wallHandle = null;

if(selectedItem && !selectedItem.locked){
const s = selectedItem;

// å¤–å£ãƒ¢ãƒ¼ãƒ‰ï¼ˆç·¨é›†è¡¨ç¤ºï¼‰ã¯å¤–æ (frame)ã®ã¿ã€éƒ¨å±‹ãƒ¢ãƒ¼ãƒ‰ï¼ˆçµåˆè¡¨ç¤ºï¼‰ã¯å¤–æ (frame)ä»¥å¤–
const selectable =
(!isMerged && s.type === 'frame') ||
(isMerged && s.type !== 'frame');

if(selectable){
if(s.type === 'wallLine'){
const r = wallHitTest(worldP, s);
if(r && r.hit){ found = s; wallHandle = r.handle; }
}else{
if(rectMoveHandleHit(worldP, s) || rectResizeHandleHit(worldP, s)){
found = s;
}
}
}
}

// measure mode
if(isMeasureMode){
const snap = getSnapStep();
const mx = getSnapped(worldP.x, snap);
const my = getSnapped(worldP.y, snap);

if(measurePoints.length >= 2) measurePoints = [];
measurePoints.push({x:mx, y:my});
updateWorkHint();
draw();
return;
}

// wall place mode (2 taps like measurement)
if(isWallPlaceMode){
const snap = getSnapStep();
let wx = getSnapped(worldP.x, snap);
let wy = getSnapped(worldP.y, snap);

if(!wallPlaceStart){
wallPlaceStart = {x:wx, y:wy};
updateWorkHint();
draw();
return;
}else{
const s = wallPlaceStart;
let x2 = wx, y2 = wy;
const dx = x2 - s.x;
const dy = y2 - s.y;

// ç›´äº¤å¸ç€ï¼ˆè·é›¢ãŒè¿‘ã„æ–¹ã‚’æƒãˆã‚‹ï¼‰
const orthoThresh = snap * 0.75;
if(Math.abs(dx) < orthoThresh) x2 = s.x;
if(Math.abs(dy) < orthoThresh) y2 = s.y;

addWallBetween({x:s.x, y:s.y}, {x:x2, y:y2});
wallPlaceStart = null; // æ¬¡ã®å£ã¯ã¾ãŸ1ç‚¹ç›®ã‹ã‚‰
updateWorkHint();
return;
}
}

if(!found){
const hits = [];
for (let i = items.length-1; i >= 0; i--) {
const it = items[i];

// å¤–å£ãƒ¢ãƒ¼ãƒ‰ï¼ˆç·¨é›†è¡¨ç¤ºï¼‰ã¯å¤–æ (frame)ã®ã¿é¸æŠå¯èƒ½
if(!isMerged && it.type !== 'frame') continue;

// éƒ¨å±‹ãƒ¢ãƒ¼ãƒ‰ï¼ˆçµåˆè¡¨ç¤ºï¼‰ã¯å¤–æ (frame)ã¯é¸æŠã—ãªã„
if(isMerged && it.type === 'frame') continue;

if(it.type === 'wallLine'){
const r = wallHitTest(worldP, it);
if(r.hit) hits.push({ it, wallHandle: r.handle });
} else {
if (worldP.x >= it.x && worldP.x <= it.x+it.w && worldP.y >= it.y && worldP.y <= it.y+it.h) {
hits.push({ it, wallHandle: null });
}
}
}

if(hits.length === 1){
found = hits[0].it;
wallHandle = hits[0].wallHandle;
}else if(hits.length > 1){
const posKey = `${Math.round(worldP.x/8)}_${Math.round(worldP.y/8)}`;
const idsKey = hits.map(h => h.it.id).join("|");
const key = `${isMerged?1:0}|${posKey}|${idsKey}`;
const within = (overlapPick.key === key) && (now - overlapPick.ts < 450);

overlapPick.key = key;
overlapPick.ts = now;
overlapPick.idx = within ? (overlapPick.idx + 1) % hits.length : 0;

const chosen = hits[overlapPick.idx];
found = chosen.it;
wallHandle = chosen.wallHandle;

showToast(`é‡ãªã‚Šï¼š${overlapPick.idx+1}/${hits.length}ï¼ˆ${found.label || found.type}ï¼‰`);
}
}


if(found){
selectedItem = found;
pendingItem = found;

if(!isReadOnly) startLongPress(found);

if(isReadOnly){
pendingAction = "pan"; // é–²è¦§ãƒ¢ãƒ¼ãƒ‰ã¯ãƒ‰ãƒ©ãƒƒã‚°=ãƒ‘ãƒ³
draw();
return;
}

if(found.locked){
pendingAction = null;
draw();
return;
}

if(found.type === 'wallLine'){
pendingWallHandle = wallHandle;
if(wallHandle === "p1" || wallHandle === "p2") pendingAction = wallHandle;
else pendingAction = "moveWall";
}else{
if(rectMoveHandleHit(worldP, found)){
pendingAction = "moveRect";
}else if(rectResizeHandleHit(worldP, found)){
pendingAction = "resizeRect";
}else{
pendingAction = "pan";
}
}
}else{
emptyTapCandidate = true;
pendingAction = "pan";
pendingItem = null;
}

draw();
}, { passive: false });

canvas.addEventListener('touchmove', (e) => {
e.preventDefault();

if(pinchActive && e.touches.length === 2){
const { dist, mid } = getPinchInfo(e.touches);

const factor = dist / pinchStartDist;
scale = clamp(pinchStartScale * factor, 0.5, 3.0);

const rect = canvas.getBoundingClientRect();
const cx = rect.width/2;
const cy = rect.height/2;
const mx = mid.x - rect.left;
const my = mid.y - rect.top;

camera.x = mx - cx - (pinchWorldMid.x * scale);
camera.y = my - cy - (pinchWorldMid.y * scale);

draw();
return;
}

if(e.touches.length !== 1) return;
const t = e.touches[0];
if(!pressStart) return;

const dx = t.clientX - pressStart.clientX;
const dy = t.clientY - pressStart.clientY;
const moved = Math.hypot(dx, dy);

const worldP = screenToWorld(t.clientX, t.clientY);
const snap = getSnapStep();

if(!dragActive && moved >= 6){
dragActive = true;
emptyTapCandidate = false;
if(longPressTimer) clearTimeout(longPressTimer);
longPressTimer = null;

gestureSnapshot = (isReadOnly || isViewMode) ? null : snapshot();

if(pendingItem && !isReadOnly){
items.splice(items.indexOf(pendingItem), 1);
items.push(pendingItem);
normalizeZ();
}

if(pendingAction === "moveRect" && pendingItem){
rectDragOffset = { dx: worldP.x - pendingItem.x, dy: worldP.y - pendingItem.y };
}
if(pendingAction === "moveWall" && pendingItem){
wallMoveOffset = { dx: worldP.x - pendingItem.x1, dy: worldP.y - pendingItem.y1 };
}
}

if(dragActive){
if(pendingAction === "pan"){
camera.x += dx;
camera.y += dy;
pressStart = { clientX: t.clientX, clientY: t.clientY };
draw();
return;
}

if(isReadOnly){
draw();
return;
}

if(pendingItem && !pendingItem.locked){
if(pendingItem.type === 'wallLine'){
const w = pendingItem;
if(pendingAction === "p1"){
w.x1 = getSnapped(worldP.x, snap);
w.y1 = getSnapped(worldP.y, snap);
applyRightAngleSnap(w, "p1");
} else if(pendingAction === "p2"){
w.x2 = getSnapped(worldP.x, snap);
w.y2 = getSnapped(worldP.y, snap);
applyRightAngleSnap(w, "p2");
} else if(pendingAction === "moveWall"){
const vx = w.x2 - w.x1;
const vy = w.y2 - w.y1;
const nx1 = getSnapped(worldP.x - (wallMoveOffset?.dx ?? 0), snap);
const ny1 = getSnapped(worldP.y - (wallMoveOffset?.dy ?? 0), snap);
w.x1 = nx1; w.y1 = ny1;
w.x2 = nx1 + vx;
w.y2 = ny1 + vy;
}
}else{
const it = pendingItem;
if(pendingAction === "resizeRect"){
it.w = Math.max(snap, getSnapped(worldP.x - it.x, snap));
it.h = Math.max(snap, getSnapped(worldP.y - it.y, snap));
}else if(pendingAction === "moveRect"){
it.x = getSnapped(worldP.x - (rectDragOffset?.dx ?? 0), snap);
it.y = getSnapped(worldP.y - (rectDragOffset?.dy ?? 0), snap);
}
}
}
}

draw();
}, { passive: false });

function commitGestureIfAny(){
if(isReadOnly || isViewMode){
gestureSnapshot = null;
return;
}
if(dragActive && gestureSnapshot){

// å¤–æ ï¼ˆå¤–å£ãƒ¢ãƒ¼ãƒ‰ï¼‰ã§å¤–æ åŒå£«ãŒé‡ãªã£ãŸã‚‰ç¢ºå®šã•ã›ãšå…ƒã«æˆ»ã™
if(!isMerged && pendingItem && pendingItem.type === 'frame' &&
(pendingAction === "moveRect" || pendingAction === "resizeRect")){
if(frameOverlapsAny(pendingItem)){
restore(gestureSnapshot);
gestureSnapshot = null;
showToast("å¤–æ ãŒé‡ãªã£ã¦ã„ã¾ã™ã€‚ä½ç½®/ã‚µã‚¤ã‚ºã‚’èª¿æ•´ã—ã¦ãã ã•ã„");
return;
}
}
undoStack.push(gestureSnapshot);
if (undoStack.length > HISTORY_MAX) undoStack.shift();
redoStack = [];
gestureSnapshot = null;
syncHistoryButtons();
scheduleAutoSave();
}else{
gestureSnapshot = null;
}
}

canvas.addEventListener('touchend', (e) => {
if(pinchActive){
if(e.touches.length < 2){
pinchActive = false;
commitGestureIfAny();
}
clearTouchState();
draw();
return;
}

if(longPressTimer) clearTimeout(longPressTimer);
longPressTimer = null;

if(emptyTapCandidate && !dragActive){
selectedItem = null;
}

// æ“ä½œç¢ºå®š
commitGestureIfAny();

// âœ… ã“ã“ã«è¿½åŠ : ç§»å‹•ãŒçµ‚ã‚ã£ãŸã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§é‡ãªã‚Šã‚’ãƒã‚§ãƒƒã‚¯
// å¤–å£ãƒ¢ãƒ¼ãƒ‰(!isMerged)ã§ã¯ãªãã€ã‹ã¤éƒ¨å±‹æ“ä½œæ™‚ã®ã¿
if(!isReadOnly && isMerged && dragActive){
if(checkRoomOverlaps()){
showToast("âš  éƒ¨å±‹ãŒé‡ãªã£ã¦ã„ã¾ã™", 1500);
}
}

clearTouchState();
draw();
});


canvas.addEventListener('touchcancel', () => {
pinchActive = false;
if(longPressTimer) clearTimeout(longPressTimer);
longPressTimer = null;
gestureSnapshot = null;
clearTouchState();
draw();
});


/* âœ… æœ€çµ‚ç‰ˆ: ä»®æƒ³ã‚­ãƒ£ãƒ³ãƒã‚¹ãƒ»ä½™ç™½150pxãƒ»æˆåŠŸæ™‚ãƒ‡ã‚«æ–‡å­—ãƒˆãƒ¼ã‚¹ãƒˆ */
async function downloadImage() {
// 1. ç¾åœ¨ã®çŠ¶æ…‹ï¼ˆã‚«ãƒ¡ãƒ©ã‚„é¸æŠçŠ¶æ…‹ï¼‰ã‚’é€€é¿
const prevScale = scale;
const prevCamera = { ...camera };
const prevSelected = selectedItem;
// ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã‚’é€€é¿ï¼ˆã™ã‚Šæ›¿ãˆç”¨ï¼‰
const originalCanvas = canvas;
const originalCtx = ctx;
// Retinaç”¨ã®æç”»ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚‚é€€é¿
const prevViewW = VIEW_W;
const prevViewH = VIEW_H;
const prevRenderDpr = RENDER_DPR;

selectedItem = null;
isExporting = true;

try {
const targets = items.filter(i => i.type !== 'wallLine');
if (targets.length === 0) {
showToast("å‡ºåŠ›ã™ã‚‹éƒ¨å±‹ãŒã‚ã‚Šã¾ã›ã‚“"); // é€šå¸¸ãƒˆãƒ¼ã‚¹ãƒˆ
return;
}

// 1. éƒ¨å±‹ã¨å£ã®ç¯„å›²ã‚’è¨ˆç®—
let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
targets.forEach(it => {
minX = Math.min(minX, it.x);
minY = Math.min(minY, it.y);
maxX = Math.max(maxX, it.x + it.w);
maxY = Math.max(maxY, it.y + it.h);
});
items.filter(i => i.type === 'wallLine').forEach(w => {
minX = Math.min(minX, w.x1, w.x2);
minY = Math.min(minY, w.y1, w.y2);
maxX = Math.max(maxX, w.x1, w.x2);
maxY = Math.max(maxY, w.y1, w.y2);
});

// 2. ã‚°ãƒªãƒƒãƒ‰åŸºæº–ã§ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚µã‚¤ã‚ºã‚’æ±ºå®šï¼ˆç«¯ã®æ•°å­—ãŒè¦‹åˆ‡ã‚Œãªã„ã‚ˆã†ã«ï¼‰
const gridStartX = Math.floor(minX / GRID_SIZE) * GRID_SIZE;
const gridStartY = Math.floor(minY / GRID_SIZE) * GRID_SIZE;
const gridEndX = Math.ceil(maxX / GRID_SIZE) * GRID_SIZE;
const gridEndY = Math.ceil(maxY / GRID_SIZE) * GRID_SIZE;

const contentW = gridEndX - gridStartX;
const contentH = gridEndY - gridStartY;

const exportScale = 4.0; // é«˜ç”»è³ªè¨­å®š
const margin = 150; // ä½™ç™½ï¼ˆä¸Šä¸‹å·¦å³150pxç¢ºä¿ï¼‰

// ä»®æƒ³ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’ä½œæˆï¼ˆç”»é¢ã«ã¯è¡¨ç¤ºã•ã‚Œãªã„ï¼‰
const virtualCanvas = document.createElement('canvas');
virtualCanvas.width = (contentW * exportScale) + (margin * 2);
virtualCanvas.height = (contentH * exportScale) + (margin * 2);
const virtualCtx = virtualCanvas.getContext('2d');

// â˜…é­”æ³•ã®ã‚¹ãƒ†ãƒƒãƒ—: ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã‚’ä»®æƒ³ã‚­ãƒ£ãƒ³ãƒã‚¹ã«ã™ã‚Šæ›¿ãˆã‚‹
canvas = virtualCanvas;
ctx = virtualCtx;

// ä»®æƒ³ã‚­ãƒ£ãƒ³ãƒã‚¹ã¯ã€Œå†…éƒ¨pxã€ã‚’ãã®ã¾ã¾æç”»å˜ä½ã«ã™ã‚‹
VIEW_W = virtualCanvas.width;
VIEW_H = virtualCanvas.height;
RENDER_DPR = 1;

scale = exportScale;
// ã‚«ãƒ¡ãƒ©ä¸­å¿ƒã‚’ã€Œã‚°ãƒªãƒƒãƒ‰ã®ä¸­å¿ƒã€ã«åˆã‚ã›ã‚‹
camera.x = -((gridStartX + gridEndX) / 2 * scale);
camera.y = -((gridStartY + gridEndY) / 2 * scale);

// æç”»å®Ÿè¡Œï¼ˆä»®æƒ³ã‚­ãƒ£ãƒ³ãƒã‚¹ã«å¯¾ã—ã¦æã‹ã‚Œã‚‹ï¼‰
draw();

const blob = await new Promise(resolve => virtualCanvas.toBlob(resolve, "image/png"));
const file = new File([blob], `${currentTitle}.png`, { type: "image/png" });

// å…±æœ‰ã¾ãŸã¯ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰å‡¦ç†
if (navigator.share && navigator.canShare && navigator.canShare({ files: [file] })) {
await navigator.share({ files: [file], title: currentTitle });
// æˆåŠŸæ™‚ï¼šå¤§ããè¡¨ç¤º (isLarge=true)
showToast("ç”»åƒã‚’å…±æœ‰ã—ã¾ã—ãŸ", 2500, true); 
} else {
const dataUrl = virtualCanvas.toDataURL("image/png");
const a = document.createElement("a");
a.href = dataUrl;
a.download = `${currentTitle}.png`;
a.click();
// æˆåŠŸæ™‚ï¼šå¤§ããè¡¨ç¤º (isLarge=true)
showToast("ç”»åƒã‚’ä¿å­˜ã—ã¾ã—ãŸ", 2500, true);
}

} catch (e) {
console.error(e);
// ã‚¨ãƒ©ãƒ¼æ™‚ï¼šå¤§ããè¡¨ç¤º (isLarge=true)
showToast("ç”»åƒã®ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ", 2500, true);
} finally {
// --- å¾©å…ƒå‡¦ç† ---
canvas = originalCanvas;
ctx = originalCtx;

// Retinaæç”»ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’å¾©å…ƒ
VIEW_W = prevViewW;
VIEW_H = prevViewH;
RENDER_DPR = prevRenderDpr;

scale = prevScale;
camera = prevCamera;
selectedItem = prevSelected;
isExporting = false;

// ç”»é¢ã‚’å†æç”»ã—ã¦å…ƒé€šã‚Šã«ã™ã‚‹
draw();
}
}





// ãƒœã‚¿ãƒ³ã‚¤ãƒ™ãƒ³ãƒˆç™»éŒ²
el('downloadImageBtn').onclick = downloadImage;


init();
</script>

<div id="toast" class="toast" aria-live="polite"></div>

</body>
</html>
