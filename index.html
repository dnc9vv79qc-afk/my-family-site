<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<title>é–“å–ã‚Šæ¤œè¨ã‚µã‚¤ãƒˆ ï¼ˆä¸€æ¡å·¥å‹™åº—ver)</title>

<style>
:root{
  --accent:#007AFF;
  --danger:#ff3b30;
  --bg:#f2f2f7;
  --card: rgba(255,255,255,.72);
  --stroke: rgba(60,60,67,.18);
  --text:#111;
  --muted: rgba(60,60,67,.6);
  --shadow: 0 10px 30px rgba(0,0,0,.10);
  --radius2: 26px;
}

@media (prefers-color-scheme: dark){
  :root{
    --bg:#000;
    --card: rgba(28,28,30,.68);
    --stroke: rgba(84,84,88,.55);
    --text:#fff;
    --muted: rgba(235,235,245,.6);
    --shadow: 0 16px 50px rgba(0,0,0,.45);
  }
}

*{ box-sizing: border-box; }

body{
  font-family:
    -apple-system, BlinkMacSystemFont,
    "SF Pro Display", "SF Pro Text",
    "Hiragino Sans", "Hiragino Kaku Gothic ProN",
    "Noto Sans JP",
    "Yu Gothic", "YuGothic",
    "Meiryo",
    sans-serif;
  -webkit-font-smoothing: antialiased;
  text-rendering: optimizeLegibility;

  margin: 0;
  background: var(--bg);
  color: var(--text);
  touch-action: none;
  display: flex;
  flex-direction: column;
  height: 100vh;
  overflow: hidden;
}

.ver-label{
  position: fixed;
  top: 6px;
  right: 10px;
  font-size: 10px;
  color: var(--muted);
  z-index: 100;
  pointer-events: none;
  font-weight: 800;
  text-align: right;
  opacity: .85;
}

/* ===== Top bar ===== */
.toolbar{
  margin: 12px;
  border-radius: var(--radius2);
  background: var(--card);
  border: 1px solid var(--stroke);
  box-shadow: var(--shadow);
  backdrop-filter: blur(16px);
  -webkit-backdrop-filter: blur(16px);

  padding: 10px;
  display:flex;
  align-items:center;
  justify-content: space-between;
  gap: 10px;

  z-index: 10;
}
.top-left, .top-right{ display:flex; align-items:center; gap: 10px; }
.top-title{ font-weight: 900; font-size: 13px; letter-spacing: .3px; opacity: .9; user-select:none; }

button{
  height: 44px;
  font-size: 13px;
  border: none;
  border-radius: 16px;
  color: white;
  font-weight: 900;
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  padding: 0 14px;
  -webkit-tap-highlight-color: transparent;
  letter-spacing: .2px;
  transition: transform .08s ease, filter .08s ease, opacity .08s ease;
}
button:active { opacity: 0.85; transform: scale(0.98); }

.btn-primary{ background: rgba(255,149,0,.95); }
.btn-help{
  background: rgba(120,120,128,.18);
  color: var(--text);
  font-size: 18px;
  width: 44px;
  padding: 0;
}

.color-circle{
  background: rgba(120,120,128,.18);
  border: 1px solid var(--stroke);
  border-radius: 16px;
  width: 44px;
  height: 44px;
  display:flex;
  align-items:center;
  justify-content:center;
  overflow:hidden;
}
input[type="color"]{
  width: 70px;
  height: 70px;
  border: none;
  background: none;
  cursor: pointer;
  padding: 0;
}

/* ===== Config bar ===== */
.config-bar{
  margin: 0 12px 12px;
  border-radius: var(--radius2);
  background: var(--card);
  border: 1px solid var(--stroke);
  box-shadow: var(--shadow);
  backdrop-filter: blur(16px);
  -webkit-backdrop-filter: blur(16px);

  padding: 10px;
  display:flex;
  justify-content: space-between;
  align-items:center;
  gap: 10px;
}

.chip-group { display: flex; gap: 6px; flex-wrap: wrap; }
.chip{
  background: rgba(255,255,255,.55);
  border: 1px solid var(--stroke);
  padding: 8px 12px;
  border-radius: 999px;
  font-size: 13px;
  font-weight: 900;
  display:flex;
  align-items:center;
  gap: 6px;
  box-shadow: 0 1px 6px rgba(0,0,0,.06);
  cursor: pointer;
  color: var(--text);
}
@media (prefers-color-scheme: dark){
  .chip{ background: rgba(44,44,46,.65); }
}
.chip input { margin: 0; width: 18px; height: 18px; }

.right-actions{
  display:flex;
  align-items:center;
  gap: 10px;
  flex-wrap: wrap;
  justify-content: flex-end;
}

.segment{
  display:flex;
  align-items: center;
  border: 1px solid var(--stroke);
  border-radius: 14px;
  background: rgba(120,120,128,.12);
  padding: 2px;
  height: 36px;
}
.seg-btn{
  height: 32px;
  min-width: 56px;
  padding: 0 12px;
  border-radius: 12px;
  background: transparent;
  color: var(--text);
  font-size: 12px;
  font-weight: 900;
  line-height: 1;
  box-shadow:none;
  white-space: nowrap;
}
.seg-btn.active{ background: var(--accent); color: #fff; }
.seg-btn:active{ transform: none; }

.small-btn{
  height: 34px;
  border-radius: 999px;
  padding: 0 12px;
  background: var(--accent);
  color:#fff;
  font-size: 12px;
  font-weight: 900;
}
.small-btn.gray{
  background: rgba(120,120,128,.25);
  color: var(--text);
  border: 1px solid var(--stroke);
}
.small-btn:disabled{ opacity: .4; transform: none !important; cursor: default; }

/* ===== Summary ===== */
.summary{
  margin: 0 12px 12px;
  border-radius: 999px;
  background: var(--card);
  border: 1px solid var(--stroke);
  box-shadow: var(--shadow);
  backdrop-filter: blur(16px);
  -webkit-backdrop-filter: blur(16px);

  padding: 10px 14px;
  display:flex;
  justify-content: space-around;
  align-items:center;

  font-size: 14px;
  font-weight: 900;
}
.summary b{ color: var(--accent); }

/* ===== Canvas ===== */
#canvas-container{
  flex: 1;
  position: relative;
  margin: 0 12px 12px;
  border-radius: 24px;
  overflow: hidden;
  border: 1px solid var(--stroke);
  box-shadow: var(--shadow);
  background: #fff;
  touch-action: none;

  margin-bottom: 96px;
}
canvas{ display:block; }

/* ===== Bottom Bar ===== */
.bottom-bar{
  position: fixed;
  left: 12px; right: 12px;
  bottom: calc(12px + env(safe-area-inset-bottom));
  display: grid;
  grid-template-columns: repeat(5, 1fr);
  gap: 10px;
  padding: 10px;
  border-radius: 24px;
  background: var(--card);
  border: 1px solid var(--stroke);
  box-shadow: var(--shadow);
  backdrop-filter: blur(16px);
  -webkit-backdrop-filter: blur(16px);
  z-index: 60;
}

.pill{
  height: 48px;
  border-radius: 18px;
  background: rgba(120,120,128,.16);
  color: var(--text);
  box-shadow: none;
  font-weight: 900;
  font-size: 13px;
  letter-spacing: .2px;

  display:flex;
  align-items:center;
  justify-content:center;
  flex-direction: column;
  gap: 2px;
  padding: 6px 0;
}
.pill::after{
  content: attr(data-sub);
  font-size: 10px;
  font-weight: 800;
  color: var(--muted);
  letter-spacing: .1px;
}
.pill.primary{ background: var(--accent); color:#fff; }
.pill.primary::after{ color: rgba(255,255,255,.85); }
.pill.danger{
  background: rgba(255,59,48,.14);
  color: #ff3b30;
}
.pill:disabled{
  opacity: .35;
  filter: grayscale(1);
  transform: none !important;
  cursor: default;
}

/* ===== Modals ===== */
.modal-overlay{
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.6);
  z-index: 1000;
  align-items: center;
  justify-content: center;
}
.modal{
  background: #fff;
  padding: 25px;
  border-radius: 20px;
  width: 85%;
  max-width: 360px;
  text-align: center;
  box-shadow: 0 10px 30px rgba(0,0,0,0.3);
}
.modal input{
  width: 100%;
  padding: 12px;
  margin: 15px 0;
  border: 1px solid #ddd;
  border-radius: 10px;
  font-size: 14px;
  box-sizing: border-box;
}
#helpModal .modal{
  max-width: 420px;
  text-align: left;
  max-height: 80vh;
  overflow-y: auto;
}
#helpModal ul{ padding-left: 20px; font-size: 13px; line-height: 1.6; }
#helpModal h3{ text-align: center; margin-top: 0; }

.modal.sheet{ width: 92%; max-width: 520px; text-align: left; border-radius: 22px; }

#labelInput{
  width: 100%;
  padding: 12px 12px;
  border: 1px solid #ddd;
  border-radius: 14px;
  font-size: 16px;
  font-weight: 800;
  outline: none;
}

.chip-grid{
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 8px;
  margin-top: 12px;
}
.name-chip{
  height: 38px;
  border-radius: 14px;
  border: 1px solid var(--stroke);
  background: rgba(120,120,128,.14);
  color: var(--text);
  font-weight: 900;
  font-size: 13px;
  letter-spacing: .2px;
  padding: 0 8px;
  width: 100%;
  justify-content: center;
  box-shadow: none;
  gap: 8px;
  display:flex;
}
.name-chip .dot{
  width: 12px;
  height: 12px;
  border-radius: 999px;
  border: 1px solid rgba(0,0,0,.08);
}
.name-chip:active{ transform: scale(.98); opacity: .9; }

.menu-list{
  display:flex;
  flex-direction: column;
  gap: 10px;
  margin-top: 14px;
}
.menu-btn{
  height: 42px;
  border-radius: 16px;
  border: 1px solid var(--stroke);
  background: rgba(120,120,128,.14);
  color: var(--text);
  font-weight: 900;
  justify-content: center;
}
.menu-btn.danger{
  background: rgba(255,59,48,.14);
  color: #ff3b30;
}

.preset-list{ display:flex; flex-direction:column; gap:10px; margin-top: 10px; }
.preset-row{
  display:grid;
  grid-template-columns: 1fr 54px 54px;
  gap: 8px;
  align-items:center;
}
.preset-row input[type="text"]{
  margin: 0;
  padding: 10px 10px;
  border-radius: 14px;
  border: 1px solid #ddd;
  font-weight: 800;
}
.preset-row input[type="color"]{
  width: 54px;
  height: 42px;
  border-radius: 14px;
  padding: 0;
  border: 1px solid var(--stroke);
  background: transparent;
}
.preset-del{
  height: 42px;
  border-radius: 14px;
  background: rgba(255,59,48,.14);
  color:#ff3b30;
  border: 1px solid rgba(255,59,48,.25);
  font-weight: 900;
}

/* ===== Library modal ===== */
.library-head{
  display:flex;
  align-items:flex-start;
  justify-content: space-between;
  gap: 10px;
}
.library-sub{
  font-size:12px;
  color:#666;
  margin-top: 4px;
}
.lib-actions{
  display:flex;
  gap:10px;
  flex-wrap: wrap;
  justify-content:flex-end;
  margin-top: 10px;
}
.lib-list{
  display:flex;
  flex-direction: column;
  gap: 10px;
  margin-top: 12px;
  max-height: 40vh;
  overflow:auto;
  padding-right: 2px;
}
.lib-card{
  border: 1px solid var(--stroke);
  background: rgba(120,120,128,.10);
  border-radius: 18px;
  padding: 10px;
}
.lib-row{
  display:flex;
  align-items:center;
  justify-content: space-between;
  gap: 10px;
}
.lib-row input{
  margin: 0;
  border-radius: 14px;
  border: 1px solid rgba(0,0,0,.12);
  padding: 10px 10px;
  font-weight: 900;
}
.lib-meta{
  font-size: 12px;
  color: #666;
  margin-top: 6px;
  display:flex;
  gap: 10px;
  flex-wrap: wrap;
}
.lib-btns{
  display:flex;
  gap: 6px;
  flex-wrap: wrap;
  justify-content: flex-end;
}
.lib-mini{
  height: 34px;
  border-radius: 999px;
  padding: 0 10px;
  font-size: 12px;
  font-weight: 900;
  background: rgba(120,120,128,.22);
  border: 1px solid var(--stroke);
  color: var(--text);
}
.lib-mini.primary{
  background: var(--accent);
  border: none;
  color:#fff;
}
.lib-mini.danger{
  background: rgba(255,59,48,.14);
  color:#ff3b30;
  border: 1px solid rgba(255,59,48,.25);
}
.compare-wrap{
  margin-top: 14px;
  padding-top: 12px;
  border-top: 1px solid var(--stroke);
}
.compare-grid{
  display:grid;
  grid-template-columns: 1fr 1fr;
  gap: 10px;
  margin-top: 10px;
}
.compare-box{
  border: 1px solid var(--stroke);
  border-radius: 18px;
  padding: 10px;
  background: rgba(255,255,255,.50);
}
@media (prefers-color-scheme: dark){
  .compare-box{ background: rgba(44,44,46,.55); }
  .lib-meta{ color: rgba(235,235,245,.65); }
  .library-sub{ color: rgba(235,235,245,.65); }
}
.compare-title{
  font-weight: 900;
  font-size: 13px;
  margin: 0 0 8px;
}
.compare-img{
  width: 100%;
  height: 160px;
  border-radius: 14px;
  border: 1px solid var(--stroke);
  background: rgba(120,120,128,.10);
  object-fit: cover;
  display:block;
}
.compare-stats{
  margin-top: 8px;
  font-size: 12px;
  color: var(--muted);
  font-weight: 900;
  display:flex;
  flex-direction: column;
  gap: 4px;
}
.small-note{
  font-size: 12px;
  color: var(--muted);
  font-weight: 900;
}
</style>
</head>

<body>
<div class="ver-label">ver 6.00<br>by yuchiğŸ”</div>

<div class="toolbar">
  <div class="top-left">
    <button class="btn-help" id="openHelpBtn" aria-label="ãƒ˜ãƒ«ãƒ—">ï¼Ÿ</button>
    <div class="top-title">é–“å–ã‚Šã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼</div>
  </div>
  <div class="top-right">
    <button class="btn-primary" id="saveBtn">å…±æœ‰URL</button>
    <div class="color-circle" title="é¸æŠä¸­ãƒ‘ãƒ¼ãƒ„ã®è‰²">
      <input type="color" id="colorPicker" value="#ffffff" />
    </div>
  </div>
</div>

<div class="config-bar">
  <div class="chip-group">
    <label class="chip"><input type="checkbox" id="showJou" checked />ç•³</label>
    <label class="chip"><input type="checkbox" id="showTsubo" checked />åª</label>
    <label class="chip"><input type="checkbox" id="showM2" checked />mÂ²</label>
    <label class="chip"><input type="checkbox" id="measureMode" />è·é›¢</label>
    <label class="chip" style="background:rgba(120,120,128,.20);"><input type="checkbox" id="useHalfGrid" />åŠã¾ã™</label>
  </div>

  <div class="right-actions">
    <div class="segment" role="tablist" aria-label="è¡¨ç¤ºãƒ¢ãƒ¼ãƒ‰">
      <button class="seg-btn active" id="segEdit" type="button">ç·¨é›†</button>
      <button class="seg-btn" id="segMerge" type="button">çµåˆ</button>
    </div>

    <button id="undoBtn" class="small-btn gray" type="button">æˆ»ã‚‹</button>
    <button id="redoBtn" class="small-btn gray" type="button">é€²ã‚€</button>

    <button id="libraryBtn" class="small-btn gray" type="button">ä¸€è¦§/æ¯”è¼ƒ</button>

    <button id="fitBtn" class="small-btn" type="button">å¤–æ ã«ãƒ•ã‚£ãƒƒãƒˆ</button>
    <button id="centerBtn" class="small-btn" type="button">è¡¨ç¤ºãƒªã‚»ãƒƒãƒˆ</button>
  </div>
</div>

<div class="summary">
  <span>å»¶åºŠ: <b id="totalTsubo">0.00</b> åª</span>
  <span><b id="totalJou">0.0</b> ç•³</span>
  <span id="m2Wrap"><b id="totalM2">0.0</b> mÂ²</span>
</div>

<div id="canvas-container"><canvas id="canvas"></canvas></div>

<div class="bottom-bar" id="bottomBar">
  <button class="pill" id="addFrameBtn2" data-sub="æ ã‚’è¿½åŠ ">å¤–æ </button>
  <button class="pill primary" id="addGenericRoomBtn2" data-sub="ãƒ—ãƒªã‚»ãƒƒãƒˆé¸æŠ">éƒ¨å±‹</button>
  <button class="pill" id="addWallBtn2" data-sub="ç·šåˆ†å£ã‚’è¿½åŠ ">å£</button>
  <button class="pill" id="copyBtn2" data-sub="é¸æŠã‚’è¤‡è£½">è¤‡è£½</button>
  <button class="pill danger" id="resetBtn2" data-sub="é¸æŠ/å…¨æ¶ˆå»">å‰Šé™¤</button>
</div>

<!-- Save Modal -->
<div id="saveModal" class="modal-overlay">
  <div class="modal">
    <h3>å…±æœ‰URL</h3>
    <div style="font-size:12px;color:#666;margin-top:-6px;">ï¼ˆç™ºè¡Œå¾Œã¯è‡ªå‹•ã§ä¸Šæ›¸ãä¿å­˜ã•ã‚Œã¾ã™ï¼‰</div>
    <input type="text" id="shareUrlInput" readonly onclick="this.select()" />
    <div style="display:flex; gap:10px;">
      <button style="flex:1; background:var(--accent);" id="copyUrlBtn">ã‚³ãƒ”ãƒ¼</button>
      <button style="flex:1; background:rgba(120,120,128,.45); color:#fff;" id="closeSaveModalBtn">é–‰ã˜ã‚‹</button>
    </div>
  </div>
</div>

<!-- Help Modal -->
<div id="helpModal" class="modal-overlay">
  <div class="modal">
    <h3>ğŸ  æ“ä½œãƒãƒ‹ãƒ¥ã‚¢ãƒ«</h3>
    <ul>
      <li><b>ç§»å‹•:</b> ãƒ‘ãƒ¼ãƒ„ã‚’ãƒ‰ãƒ©ãƒƒã‚°ï¼ˆæŒ‡ã‚’å‹•ã‹ã—ãŸç¬é–“ã«ãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹ï¼‰ã€‚</li>
      <li><b>é•·æŠ¼ã—:</b> æŒ‡ã‚’å‹•ã‹ã•ãšæŠ¼ã—ç¶šã‘ã‚‹ã¨ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã€‚</li>
      <li><b>å£(ç·š):</b> ç«¯ç‚¹ãƒ‰ãƒ©ãƒƒã‚°ã§é•·ã•ã€ç·šãƒ‰ãƒ©ãƒƒã‚°ã§ç§»å‹•ã€‚</li>
      <li><b>ãƒ”ãƒ³ãƒ:</b> 2æœ¬æŒ‡ã§ã‚ºãƒ¼ãƒ ï¼†ç§»å‹•ã€‚</li>
      <li><b>åå‰ç·¨é›†:</b> 2å›ã‚¿ãƒƒãƒ—ï¼ˆç·¨é›†ãƒ¢ãƒ¼ãƒ‰ã®ã¿ï¼‰ã€‚</li>
      <li><b>è·é›¢:</b> ã€Œè·é›¢ã€ONã§2ç‚¹ã‚¿ãƒƒãƒ—ã€‚3å›ç›®ã‚¿ãƒƒãƒ—ã§èµ·ç‚¹ã‚’æ›´æ–°ã€‚</li>
      <li><b>ä¿å­˜:</b> å…±æœ‰URLã‚’ç™ºè¡Œã—ã¦ç¶šãã‚’ç·¨é›†å¯èƒ½ï¼ˆç™ºè¡Œå¾Œã¯è‡ªå‹•ä¸Šæ›¸ãä¿å­˜ï¼‰ã€‚</li>
      <li><b>ä¸€è¦§/æ¯”è¼ƒ:</b> ä¿å­˜ã—ãŸæ¡ˆã‚’ä¸€è¦§ã§ç®¡ç†ï¼†A/Bæ¯”è¼ƒã€‚</li>
    </ul>
    <p style="font-size:11px; color:#666; text-align:center;">ï¼ˆç”»é¢ã‚’ã‚¿ãƒƒãƒ—ã—ã¦é–‰ã˜ã‚‹ï¼‰</p>
  </div>
</div>

<!-- Label / Add Modal -->
<div id="labelModal" class="modal-overlay">
  <div class="modal sheet">
    <h3 id="labelModalTitle" style="margin:0 0 6px;">éƒ¨å±‹åã‚’å¤‰æ›´</h3>
    <div id="labelModalSub" style="font-size:12px;color:#666;margin-bottom:10px;">å€™è£œã‚’ã‚¿ãƒƒãƒ—ï¼ˆåå‰ï¼‹è‰²ï¼‰ / å…¥åŠ›ã—ã¦OK</div>

    <input type="text" id="labelInput" placeholder="éƒ¨å±‹å" maxlength="12" />

    <div style="display:flex; gap:10px; margin:12px 0 6px;">
      <button class="small-btn gray" id="openPresetBtn" type="button" style="height:36px;">ãƒ—ãƒªã‚»ãƒƒãƒˆç·¨é›†</button>
      <div id="addHint" style="font-size:12px;color:#666;align-self:center;">â€»ãƒãƒƒãƒ—ã¯å³è¿½åŠ </div>
    </div>

    <div class="chip-grid" id="labelChips"></div>

    <div style="display:flex; gap:10px; margin-top:14px;">
      <button style="flex:1; background:rgba(120,120,128,.45); color:#fff;" id="labelCancelBtn" type="button">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
      <button style="flex:1; background:var(--accent);" id="labelOkBtn" type="button">OK</button>
    </div>
  </div>
</div>

<!-- Context Menu -->
<div id="menuModal" class="modal-overlay">
  <div class="modal sheet">
    <h3 style="margin:0 0 6px;">ãƒ¡ãƒ‹ãƒ¥ãƒ¼</h3>
    <div id="menuTitle" style="font-size:12px;color:#666;margin-bottom:8px;">é¸æŠä¸­</div>

    <div class="menu-list">
      <button class="menu-btn" id="menuEditBtn" type="button">åå‰å¤‰æ›´</button>
      <button class="menu-btn" id="menuDupBtn" type="button">è¤‡è£½</button>
      <button class="menu-btn danger" id="menuDelBtn" type="button">å‰Šé™¤</button>
      <button class="menu-btn" id="menuFrontBtn" type="button">æœ€å‰é¢</button>
      <button class="menu-btn" id="menuBackBtn" type="button">æœ€èƒŒé¢</button>
      <button class="menu-btn" id="menuLockBtn" type="button">ãƒ­ãƒƒã‚¯/è§£é™¤</button>
    </div>

    <div style="display:flex; gap:10px; margin-top:14px;">
      <button style="flex:1; background:rgba(120,120,128,.45); color:#fff;" id="menuCloseBtn" type="button">é–‰ã˜ã‚‹</button>
    </div>
  </div>
</div>

<!-- Preset Manager -->
<div id="presetModal" class="modal-overlay">
  <div class="modal sheet">
    <h3 style="margin:0 0 6px;">ãƒ—ãƒªã‚»ãƒƒãƒˆç·¨é›†</h3>
    <div style="font-size:12px;color:#666;margin-bottom:10px;">éƒ¨å±‹åã¨è‰²ã‚’è¿½åŠ /å¤‰æ›´ã§ãã¾ã™</div>

    <div class="preset-list" id="presetList"></div>

    <div style="display:flex; gap:10px; margin-top:14px;">
      <button class="small-btn gray" id="presetAddBtn" type="button" style="height:42px;">ï¼‹è¿½åŠ </button>
      <button class="small-btn" id="presetSaveBtn" type="button" style="height:42px;">ä¿å­˜</button>
    </div>

    <div style="display:flex; gap:10px; margin-top:10px;">
      <button style="flex:1; background:rgba(120,120,128,.45); color:#fff;" id="presetCloseBtn" type="button">é–‰ã˜ã‚‹</button>
    </div>
  </div>
</div>

<!-- Library (multi save / compare) -->
<div id="libraryModal" class="modal-overlay">
  <div class="modal sheet">
    <div class="library-head">
      <div>
        <h3 style="margin:0 0 4px;">ä¿å­˜ä¸€è¦§ / æ¯”è¼ƒ</h3>
        <div class="library-sub">ä¿å­˜ã—ãŸæ¡ˆã‚’ãƒ­ãƒ¼ã‚«ãƒ«ã«ä¸€è¦§è¡¨ç¤ºï¼ˆã“ã®ç«¯æœ«ã®ãƒ–ãƒ©ã‚¦ã‚¶ï¼‰ã€‚A/Bã§æ¯”è¼ƒã§ãã¾ã™ã€‚</div>
      </div>
      <button class="btn-help" id="libraryCloseX" type="button" aria-label="é–‰ã˜ã‚‹">Ã—</button>
    </div>

    <div class="lib-actions">
      <button class="small-btn gray" id="libUpdateBtn" type="button" style="height:40px;">ã“ã®æ¡ˆã‚’è¿½åŠ /æ›´æ–°</button>
      <button class="small-btn" id="libSaveAsBtn" type="button" style="height:40px;">åˆ¥æ¡ˆã¨ã—ã¦ä¿å­˜</button>
      <button class="small-btn gray" id="libClearCompareBtn" type="button" style="height:40px;">æ¯”è¼ƒã‚¯ãƒªã‚¢</button>
    </div>

    <div class="small-note" style="margin-top:8px;">
      â€»ã€Œåˆ¥æ¡ˆã¨ã—ã¦ä¿å­˜ã€ã¯æ–°ã—ã„URL(id)ã‚’ç™ºè¡Œã—ã¦è¤‡è£½ã—ã¾ã™ï¼ˆå…ƒã®æ¡ˆã¯ãã®ã¾ã¾ï¼‰ã€‚
    </div>

    <div class="lib-list" id="libList"></div>

    <div class="compare-wrap">
      <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;">
        <div style="font-weight:900;">A/Bæ¯”è¼ƒ</div>
        <button class="lib-mini" id="swapCompareBtn" type="button">Aâ†”B å…¥æ›¿</button>
      </div>

      <div class="compare-grid">
        <div class="compare-box">
          <div class="compare-title">A</div>
          <img class="compare-img" id="cmpImgA" alt="Aãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼" />
          <div class="compare-stats" id="cmpStatsA"></div>
        </div>
        <div class="compare-box">
          <div class="compare-title">B</div>
          <img class="compare-img" id="cmpImgB" alt="Bãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼" />
          <div class="compare-stats" id="cmpStatsB"></div>
        </div>
      </div>
    </div>

    <div style="display:flex; gap:10px; margin-top:14px;">
      <button style="flex:1; background:rgba(120,120,128,.45); color:#fff;" id="libraryCloseBtn" type="button">é–‰ã˜ã‚‹</button>
    </div>
  </div>
</div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
import { getFirestore, collection, addDoc, getDoc, doc, setDoc } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

const firebaseConfig = {
  apiKey: "AIzaSyBH4zoH5ZnfPcZmmXNvfeGOJz9__KkSMrg",
  authDomain: "test-55430.firebaseapp.com",
  projectId: "test-55430",
  storageBucket: "test-55430.firebasestorage.app",
  messagingSenderId: "742726212885",
  appId: "1:742726212885:web:597a48fc1ce0cb7f529d1c",
  measurementId: "G-PW24JY2LBP"
};

const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

const el = (id) => document.getElementById(id);

const canvas = el('canvas');
const ctx = canvas.getContext('2d');
const container = el('canvas-container');

const GRID_SIZE = 32;
const HISTORY_MAX = 50;

const PRESET_KEY = "floorplan_presets_v1";

/* â˜…ä¿å­˜ä¸€è¦§ï¼ˆè¤‡æ•°æ¡ˆï¼‰ */
const LIB_KEY = "floorplan_library_v1";

/* å£ */
const WALL_DEFAULT_THICK = 12;
const WALL_HANDLE_R = 18;      // screen px
const WALL_HIT_PAD = 12;       // screen px
const SNAP_ANGLE_DEG = 15;

/* Autosave */
const AUTOSAVE_DELAY = 1500;

/* â˜… mÂ²æ›ç®—ï¼ˆåªâ†’mÂ²ï¼‰ */
const TSUBO_TO_M2 = 3.305785;

/* â˜… è·é›¢æ›ç®—ï¼š1ãƒã‚¹ã®è¾ºé•·[m]ï¼ˆåª=4ãƒã‚¹ã®é¢ç©ã€ã‹ã‚‰å°å‡ºï¼‰ */
const MASU_SIDE_M = Math.sqrt(TSUBO_TO_M2 / 4);

/* â˜… å¤–æ ã®åˆæœŸå€¤ï¼ˆ2Ã—2ï¼‰ */
const DEFAULT_FRAME_W = 2;
const DEFAULT_FRAME_H = 2;

let items = [];
let selectedItem = null;

let isMerged = false;

let camera = { x: 0, y: 0 };   // screen px
let scale = 1.0;               // zoom

let lastTapTime = 0;
let layoutId = null;

let editingItem = null;
let menuItem = null;

/* è¿½åŠ /ç·¨é›†ãƒ¢ãƒ¼ãƒ‰ */
let labelModalMode = "edit";  // "edit" | "add"
let addPendingColor = "#FFF3E0"; // å…¥åŠ›è¿½åŠ æ™‚ã®è‰²ï¼ˆç›´å‰é¸æŠã‚’ä¿æŒï¼‰

/* Undo/Redo */
let undoStack = [];
let redoStack = [];
let gestureSnapshot = null;

/* Auto-save */
let autosaveTimer = null;

/* Presets */
let presets = [];

/* Touch states */
let longPressTimer = null;
let pressStart = null;            // {clientX, clientY}
let pressStartWorld = null;       // {x,y}
let pendingItem = null;           // hit item
let pendingWallHandle = null;     // "p1"|"p2"|null
let pendingAction = null;         // "moveRect"|"resizeRect"|"moveWall"|"p1"|"p2"|"pan"|null
let dragActive = false;
let rectDragOffset = null;        // {dx,dy} in world
let wallMoveOffset = null;        // {dx,dy} in world
let movedDist = 0;
let tapNoHit = false;

/* Pinch */
let pinchActive = false;
let pinchStartDist = 0;
let pinchStartScale = 1;
let pinchWorldMid = null;

/* â˜… è·é›¢æ¸¬å®š */
let measureA = null; // {x,y} world
let measureB = null; // {x,y} world

/* â˜… ãƒ©ã‚¤ãƒ–ãƒ©ãƒªï¼ˆè¤‡æ•°ä¿å­˜/æ¯”è¼ƒï¼‰ */
let library = []; // local list
let compareAId = null;
let compareBId = null;

function uid(){
  return Math.random().toString(36).slice(2, 10) + Date.now().toString(36).slice(-4);
}

function ensureIds(){
  items.forEach(it => {
    if(!it.id) it.id = uid();
    if(typeof it.locked !== "boolean") it.locked = false;
    if(it.type === 'wallLine'){
      if(typeof it.thick !== "number") it.thick = WALL_DEFAULT_THICK;
      if(!it.color) it.color = "#616161";
      if(!it.label) it.label = "å£";
    }
  });
}

function normalizeZ(){
  const frames = items.filter(i => i.type === 'frame');
  const others = items.filter(i => i.type !== 'frame');
  items = [...frames, ...others];
}

function getSnapStep(){
  return el('useHalfGrid').checked ? 16 : 32;
}
function getSnapped(val, step){
  return Math.round(val / step) * step;
}
function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

/* ===== coordinate ===== */
function screenToWorld(screenX, screenY){
  const rect = canvas.getBoundingClientRect();
  const cx = canvas.width/2;
  const cy = canvas.height/2;
  const x = (screenX - rect.left - cx - camera.x) / scale;
  const y = (screenY - rect.top  - cy - camera.y) / scale;
  return {x,y};
}

/* ===== autosave ===== */
function scheduleAutoSave(){
  if(!layoutId) return;
  if(autosaveTimer) clearTimeout(autosaveTimer);
  autosaveTimer = setTimeout(async () => {
    try{
      await setDoc(doc(db, "layouts", layoutId), { items, isMerged, updatedAt: new Date() }, { merge: true });
    }catch(e){
      console.warn("autosave failed", e);
    }
  }, AUTOSAVE_DELAY);
}

/* ===== history ===== */
function snapshot(){
  ensureIds();
  return {
    items: items.map(i => ({...i})),
    selectedId: selectedItem?.id || null,
    isMerged,
    camera: {...camera},
    scale,
    layoutId,
    measureA: measureA ? {...measureA} : null,
    measureB: measureB ? {...measureB} : null
  };
}

function restore(s){
  items = (s.items || []).map(i => ({...i}));
  ensureIds();
  normalizeZ();
  isMerged = !!s.isMerged;
  camera = s.camera ? {...s.camera} : {x:0,y:0};
  scale = typeof s.scale === "number" ? s.scale : 1.0;
  layoutId = s.layoutId ?? layoutId;
  selectedItem = s.selectedId ? items.find(i => i.id === s.selectedId) || null : null;
  measureA = s.measureA ? {...s.measureA} : null;
  measureB = s.measureB ? {...s.measureB} : null;
  updateSegmentUI();
  draw();
}

function pushHistory(){
  undoStack.push(snapshot());
  if (undoStack.length > HISTORY_MAX) undoStack.shift();
  redoStack = [];
  syncHistoryButtons();
}

function undo(){
  if (!undoStack.length) return;
  redoStack.push(snapshot());
  restore(undoStack.pop());
  syncHistoryButtons();
  scheduleAutoSave();
}

function redo(){
  if (!redoStack.length) return;
  undoStack.push(snapshot());
  restore(redoStack.pop());
  syncHistoryButtons();
  scheduleAutoSave();
}

function syncHistoryButtons(){
  el('undoBtn').disabled = undoStack.length === 0;
  el('redoBtn').disabled = redoStack.length === 0;
}

/* ===== presets ===== */
function defaultPresets(){
  return [
    { name: "LDK", color: "#FFF3E0" },
    { name: "æ´‹å®¤", color: "#E3F2FD" },
    { name: "å¯å®¤", color: "#E8F5E9" },
    { name: "åœŸé–“", color: "#ECEFF1" },
    { name: "åç´", color: "#F3E5F5" },
    { name: "æ´—é¢", color: "#E0F7FA" },
    { name: "ãƒˆã‚¤ãƒ¬", color: "#FFFDE7" },
    { name: "ç„é–¢", color: "#FBE9E7" },
  ];
}
function loadPresets(){
  try{
    const raw = localStorage.getItem(PRESET_KEY);
    if(raw){
      const arr = JSON.parse(raw);
      if(Array.isArray(arr) && arr.length){
        return arr.map(p => ({
          name: String(p.name||"").trim() || "éƒ¨å±‹",
          color: String(p.color||"#FFF3E0")
        }));
      }
    }
  }catch(_){}
  return defaultPresets();
}
function savePresets(){
  localStorage.setItem(PRESET_KEY, JSON.stringify(presets));
}
function escapeHtml(s){
  return String(s).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'}[m]));
}

function onPresetPicked(name, color){
  // è¿½åŠ ãƒ¢ãƒ¼ãƒ‰ï¼šãƒãƒƒãƒ—ã¯å³è¿½åŠ 
  if(labelModalMode === "add"){
    addPendingColor = color || "#FFF3E0";
    closeLabelModal();
    addRect(name, 4, 4, addPendingColor, 'room');
    return;
  }
  // ç·¨é›†ãƒ¢ãƒ¼ãƒ‰ï¼šåå‰ï¼‹è‰²ã‚’é©ç”¨
  el('labelInput').value = name;
  applyLabel(true, color);
}

function renderPresetChips(){
  const box = el('labelChips');
  box.innerHTML = "";
  presets.forEach(p => {
    const b = document.createElement("button");
    b.type = "button";
    b.className = "name-chip";
    b.innerHTML = `<span class="dot" style="background:${p.color}"></span><span>${escapeHtml(p.name)}</span>`;
    b.addEventListener("click", () => onPresetPicked(p.name, p.color));
    box.appendChild(b);
  });
}

function renderPresetEditorList(){
  const list = el('presetList');
  list.innerHTML = "";
  presets.forEach((p, idx) => {
    const row = document.createElement("div");
    row.className = "preset-row";
    row.innerHTML = `
      <input type="text" value="${escapeHtml(p.name)}" maxlength="12" data-idx="${idx}" data-k="name">
      <input type="color" value="${p.color}" data-idx="${idx}" data-k="color">
      <button class="preset-del" type="button" data-idx="${idx}">å‰Šé™¤</button>
    `;
    list.appendChild(row);
  });

  list.querySelectorAll('input').forEach(inp => {
    inp.addEventListener('input', () => {
      const i = Number(inp.dataset.idx);
      const k = inp.dataset.k;
      if(!presets[i]) return;
      if(k === 'name') presets[i].name = (inp.value || "").trim().slice(0,12) || "éƒ¨å±‹";
      if(k === 'color') presets[i].color = inp.value || "#FFF3E0";
    });
  });

  list.querySelectorAll('.preset-del').forEach(btn => {
    btn.addEventListener('click', () => {
      const i = Number(btn.dataset.idx);
      presets.splice(i, 1);
      renderPresetEditorList();
    });
  });
}

/* ===== UI helpers ===== */
function resizeCanvas(){
  canvas.width = container.clientWidth;
  canvas.height = container.clientHeight;
  draw();
}
function updateSegmentUI(){
  el('segEdit').classList.toggle('active', !isMerged);
  el('segMerge').classList.toggle('active', isMerged);
}
function setMergedMode(val){
  isMerged = val;
  updateSegmentUI();
  draw();
}

function isAnyModalOpen(){
  const ids = ["saveModal","helpModal","labelModal","menuModal","presetModal","libraryModal"];
  return ids.some(id => el(id)?.style.display === 'flex');
}

/* ===== summary calc ===== */
function totalMasuFromFrames(){
  let tm = 0;
  items.forEach(i => {
    if(i.type === 'frame'){
      tm += (i.w/GRID_SIZE)*(i.h/GRID_SIZE);
    }
  });
  return tm; // in "masu area units"
}

/* mÂ²è¡¨ç¤ºON/OFFå¯¾å¿œ */
function updateSummary(){
  const tm = totalMasuFromFrames();
  const tsubo = tm/4;
  const jou = tm/2;
  const m2 = tsubo * TSUBO_TO_M2;

  el('totalTsubo').innerText = tsubo.toFixed(2);
  el('totalJou').innerText = jou.toFixed(1);
  el('totalM2').innerText = m2.toFixed(1);

  const showM2 = el('showM2')?.checked ?? true;
  const wrap = el('m2Wrap');
  if(wrap) wrap.style.display = showM2 ? "" : "none";
}

function syncBottomBarState(){
  el('copyBtn2').disabled = !selectedItem;
}

function formatDate(ts){
  try{
    const d = new Date(ts);
    const mm = String(d.getMonth()+1).padStart(2,'0');
    const dd = String(d.getDate()).padStart(2,'0');
    const hh = String(d.getHours()).padStart(2,'0');
    const mi = String(d.getMinutes()).padStart(2,'0');
    return `${d.getFullYear()}/${mm}/${dd} ${hh}:${mi}`;
  }catch(_){
    return "";
  }
}

/* ===== library ===== */
function loadLibrary(){
  try{
    const raw = localStorage.getItem(LIB_KEY);
    if(!raw) return [];
    const arr = JSON.parse(raw);
    if(!Array.isArray(arr)) return [];
    return arr
      .map(x => ({
        id: String(x.id||""),
        name: String(x.name||"æœªå‘½å").slice(0,30),
        updatedAt: Number(x.updatedAt||0),
        snapshot: typeof x.snapshot === "string" ? x.snapshot : "",
        stats: x.stats || null
      }))
      .filter(x => x.id);
  }catch(_){
    return [];
  }
}
function saveLibrary(){
  localStorage.setItem(LIB_KEY, JSON.stringify(library));
}
function calcStats(){
  const tm = totalMasuFromFrames();
  const tsubo = tm/4;
  const jou = tm/2;
  const m2 = tsubo * TSUBO_TO_M2;
  return { tsubo: +tsubo.toFixed(2), jou: +jou.toFixed(1), m2: +m2.toFixed(1) };
}
function captureSnapshot(){
  // ãªã‚‹ã¹ãè»½ãï¼ˆJPEGï¼‰
  try{
    return canvas.toDataURL("image/jpeg", 0.75);
  }catch(_){
    return "";
  }
}
function upsertLibraryEntry(id, patch){
  if(!id) return;
  const idx = library.findIndex(x => x.id === id);
  if(idx >= 0){
    library[idx] = { ...library[idx], ...patch, id };
  }else{
    library.unshift({
      id,
      name: patch?.name || "æœªå‘½å",
      updatedAt: patch?.updatedAt || Date.now(),
      snapshot: patch?.snapshot || "",
      stats: patch?.stats || null
    });
  }
  // updatedAt é™é †
  library.sort((a,b) => (b.updatedAt||0) - (a.updatedAt||0));
  // ä¿å­˜æ•°ãŒå¢—ãˆã™ããªã„ã‚ˆã†ã«è»½ãåˆ¶é™ï¼ˆå¿…è¦ãªã‚‰å¤‰ãˆã¦OKï¼‰
  if(library.length > 30) library = library.slice(0, 30);
  saveLibrary();
}
function setCompare(which, id){
  if(which === "A") compareAId = id;
  if(which === "B") compareBId = id;
  renderCompare();
  renderLibraryList();
}
function clearCompare(){
  compareAId = null;
  compareBId = null;
  renderCompare();
  renderLibraryList();
}
function swapCompare(){
  const t = compareAId;
  compareAId = compareBId;
  compareBId = t;
  renderCompare();
  renderLibraryList();
}
function renderCompare(){
  const a = compareAId ? library.find(x => x.id === compareAId) : null;
  const b = compareBId ? library.find(x => x.id === compareBId) : null;

  const imgA = el("cmpImgA");
  const imgB = el("cmpImgB");
  const stA = el("cmpStatsA");
  const stB = el("cmpStatsB");

  imgA.src = a?.snapshot || "";
  imgB.src = b?.snapshot || "";

  stA.innerHTML = a
    ? `<div>${escapeHtml(a.name)} (${escapeHtml(a.id.slice(0,6))}â€¦)</div>
       <div>${a.stats ? `å»¶åºŠ: ${a.stats.tsubo}åª / ${a.stats.jou}ç•³ / ${a.stats.m2}mÂ²` : "å»¶åºŠ: -"} </div>
       <div>${a.updatedAt ? `æ›´æ–°: ${formatDate(a.updatedAt)}` : ""}</div>`
    : `<div style="opacity:.7;">Aæœªé¸æŠ</div>`;

  stB.innerHTML = b
    ? `<div>${escapeHtml(b.name)} (${escapeHtml(b.id.slice(0,6))}â€¦)</div>
       <div>${b.stats ? `å»¶åºŠ: ${b.stats.tsubo}åª / ${b.stats.jou}ç•³ / ${b.stats.m2}mÂ²` : "å»¶åºŠ: -"} </div>
       <div>${b.updatedAt ? `æ›´æ–°: ${formatDate(b.updatedAt)}` : ""}</div>`
    : `<div style="opacity:.7;">Bæœªé¸æŠ</div>`;
}
function renderLibraryList(){
  const box = el("libList");
  box.innerHTML = "";

  if(!library.length){
    const div = document.createElement("div");
    div.className = "small-note";
    div.style.marginTop = "10px";
    div.innerText = "ã¾ã ä¿å­˜ä¸€è¦§ãŒã‚ã‚Šã¾ã›ã‚“ã€‚ã€Œã“ã®æ¡ˆã‚’è¿½åŠ /æ›´æ–°ã€ã¾ãŸã¯ã€Œåˆ¥æ¡ˆã¨ã—ã¦ä¿å­˜ã€ã‚’ä½¿ã£ã¦ãã ã•ã„ã€‚";
    box.appendChild(div);
    renderCompare();
    return;
  }

  library.forEach(entry => {
    const card = document.createElement("div");
    card.className = "lib-card";

    const row = document.createElement("div");
    row.className = "lib-row";

    const nameInput = document.createElement("input");
    nameInput.type = "text";
    nameInput.value = entry.name || "æœªå‘½å";
    nameInput.maxLength = 30;
    nameInput.style.flex = "1";

    nameInput.addEventListener("change", () => {
      entry.name = (nameInput.value || "æœªå‘½å").trim().slice(0,30) || "æœªå‘½å";
      entry.updatedAt = entry.updatedAt || Date.now();
      saveLibrary();
      renderCompare();
    });

    const btns = document.createElement("div");
    btns.className = "lib-btns";

    const openBtn = document.createElement("button");
    openBtn.className = "lib-mini primary";
    openBtn.type = "button";
    openBtn.innerText = "é–‹ã";
    openBtn.addEventListener("click", () => {
      const url = `${window.location.origin}${window.location.pathname}?id=${entry.id}`;
      window.location.href = url;
    });

    const aBtn = document.createElement("button");
    aBtn.className = "lib-mini";
    aBtn.type = "button";
    aBtn.innerText = (compareAId === entry.id) ? "Aâœ“" : "Aã«ã™ã‚‹";
    aBtn.addEventListener("click", () => setCompare("A", entry.id));

    const bBtn = document.createElement("button");
    bBtn.className = "lib-mini";
    bBtn.type = "button";
    bBtn.innerText = (compareBId === entry.id) ? "Bâœ“" : "Bã«ã™ã‚‹";
    bBtn.addEventListener("click", () => setCompare("B", entry.id));

    const delBtn = document.createElement("button");
    delBtn.className = "lib-mini danger";
    delBtn.type = "button";
    delBtn.innerText = "ä¸€è¦§ã‹ã‚‰å‰Šé™¤";
    delBtn.addEventListener("click", () => {
      library = library.filter(x => x.id !== entry.id);
      if(compareAId === entry.id) compareAId = null;
      if(compareBId === entry.id) compareBId = null;
      saveLibrary();
      renderLibraryList();
      renderCompare();
    });

    btns.appendChild(openBtn);
    btns.appendChild(aBtn);
    btns.appendChild(bBtn);
    btns.appendChild(delBtn);

    row.appendChild(nameInput);
    row.appendChild(btns);

    const meta = document.createElement("div");
    meta.className = "lib-meta";
    const current = (layoutId && entry.id === layoutId) ? "ï¼ˆã„ã¾é–‹ã„ã¦ã‚‹æ¡ˆï¼‰" : "";
    const stats = entry.stats ? `å»¶åºŠ: ${entry.stats.tsubo}åª / ${entry.stats.jou}ç•³ / ${entry.stats.m2}mÂ²` : "å»¶åºŠ: -";
    meta.innerHTML = `<span>${escapeHtml(entry.id)}</span><span>${escapeHtml(stats)}</span><span>${escapeHtml(entry.updatedAt ? formatDate(entry.updatedAt) : "")}</span><span>${escapeHtml(current)}</span>`;

    card.appendChild(row);
    card.appendChild(meta);

    box.appendChild(card);
  });

  renderCompare();
}

async function ensureLayoutId(){
  if(layoutId) return layoutId;
  const r = await addDoc(collection(db, "layouts"), { items, isMerged, updatedAt: new Date() });
  layoutId = r.id;
  const newUrl = `${window.location.origin}${window.location.pathname}?id=${layoutId}`;
  history.replaceState(null, "", newUrl);
  return layoutId;
}

async function updateLibraryFromCurrent(){
  const id = await ensureLayoutId();
  // ä¿å­˜ã‚‚ã—ã¦ãŠãï¼ˆå®‰å¿ƒï¼‰
  await setDoc(doc(db, "layouts", id), { items, isMerged, updatedAt: new Date() }, { merge: true });

  upsertLibraryEntry(id, {
    name: library.find(x => x.id === id)?.name || "æœªå‘½å",
    updatedAt: Date.now(),
    snapshot: captureSnapshot(),
    stats: calcStats()
  });

  renderLibraryList();
}

async function saveAsNewLayout(){
  // ç¾åœ¨ã®çŠ¶æ…‹ã‚’æ–°ã—ã„layoutã¨ã—ã¦ä¿å­˜ï¼ˆè¤‡è£½ï¼‰
  const r = await addDoc(collection(db, "layouts"), { items, isMerged, updatedAt: new Date() });
  const newId = r.id;

  upsertLibraryEntry(newId, {
    name: `åˆ¥æ¡ˆ ${newId.slice(0,6)}`,
    updatedAt: Date.now(),
    snapshot: captureSnapshot(),
    stats: calcStats()
  });

  const newUrl = `${window.location.origin}${window.location.pathname}?id=${newId}`;
  window.location.href = newUrl;
}

/* ===== add items ===== */
function addRect(label, w, h, color, type='room'){
  pushHistory();
  const targetX = getSnapped((-camera.x)/scale, GRID_SIZE);
  const targetY = getSnapped((-camera.y)/scale, GRID_SIZE);
  const i = { id: uid(), locked:false, type, x: targetX, y: targetY, w: w*GRID_SIZE, h: h*GRID_SIZE, label, color };
  if(type === 'frame') items.unshift(i); else items.push(i);
  ensureIds();
  normalizeZ();
  selectedItem = i;
  draw();
  scheduleAutoSave();
}
function addWallLine(){
  pushHistory();
  const targetX = getSnapped((-camera.x)/scale, GRID_SIZE);
  const targetY = getSnapped((-camera.y)/scale, GRID_SIZE);
  const len = 4 * GRID_SIZE;
  const wall = {
    id: uid(),
    locked:false,
    type: 'wallLine',
    label: 'å£',
    color: '#616161',
    thick: WALL_DEFAULT_THICK,
    x1: targetX,
    y1: targetY,
    x2: targetX + len,
    y2: targetY
  };
  items.push(wall);
  ensureIds();
  normalizeZ();
  selectedItem = wall;
  draw();
  scheduleAutoSave();
}

/* ===== menu actions ===== */
function openMenu(item){
  if(!item) return;
  menuItem = item;
  const lockedText = item.locked ? "ï¼ˆãƒ­ãƒƒã‚¯ï¼‰" : "";
  el('menuTitle').innerText = `${item.label || "ï¼ˆç„¡åï¼‰"} / ${item.type}${lockedText}`;
  el('menuModal').style.display = 'flex';
}
function closeMenu(){
  el('menuModal').style.display = 'none';
  menuItem = null;
}
function duplicateItem(it){
  if(!it) return;
  pushHistory();
  let n;
  if(it.type === 'wallLine'){
    n = { ...it, id: uid(), x1: it.x1 + GRID_SIZE, y1: it.y1 + GRID_SIZE, x2: it.x2 + GRID_SIZE, y2: it.y2 + GRID_SIZE };
  }else{
    n = { ...it, id: uid(), x: it.x + GRID_SIZE, y: it.y + GRID_SIZE };
  }
  items.push(n);
  normalizeZ();
  selectedItem = n;
  draw();
  scheduleAutoSave();
}
function deleteItem(it){
  if(!it) return;
  pushHistory();
  items = items.filter(x => x !== it);
  selectedItem = null;
  normalizeZ();
  draw();
  scheduleAutoSave();
}
function bringFront(it){
  if(!it) return;
  pushHistory();
  items = items.filter(x => x !== it);
  items.push(it);
  normalizeZ();
  draw();
  scheduleAutoSave();
}
function bringBack(it){
  if(!it) return;
  pushHistory();
  const frames = items.filter(i => i.type === 'frame');
  const others = items.filter(i => i.type !== 'frame' && i !== it);
  items = [...frames, it, ...others];
  normalizeZ();
  draw();
  scheduleAutoSave();
}
function toggleLock(it){
  if(!it) return;
  pushHistory();
  it.locked = !it.locked;
  draw();
  scheduleAutoSave();
}

/* ===== label modal (edit/add) ===== */
function openLabelModal(mode){
  labelModalMode = mode; // "add" or "edit"
  el('labelModal').style.display = 'flex';

  if(mode === "add"){
    el('labelModalTitle').innerText = "éƒ¨å±‹ã‚’è¿½åŠ ";
    el('labelModalSub').innerText = "ãƒ—ãƒªã‚»ãƒƒãƒˆã‚’ã‚¿ãƒƒãƒ—ã§å³è¿½åŠ  / å…¥åŠ›ã—ã¦OKã§ã‚‚è¿½åŠ ";
    el('addHint').style.display = "block";
    el('labelInput').placeholder = "éƒ¨å±‹åï¼ˆå…¥åŠ›è¿½åŠ ï¼‰";
    el('labelInput').value = "";
  }else{
    el('labelModalTitle').innerText = "éƒ¨å±‹åã‚’å¤‰æ›´";
    el('labelModalSub').innerText = "å€™è£œã‚’ã‚¿ãƒƒãƒ—ï¼ˆåå‰ï¼‹è‰²ï¼‰ / å…¥åŠ›ã—ã¦OK";
    el('addHint').style.display = "none";
    el('labelInput').placeholder = "éƒ¨å±‹å";
  }

  setTimeout(() => el('labelInput').focus(), 50);
}

function closeLabelModal(){
  el('labelModal').style.display = 'none';
  labelModalMode = "edit";
  editingItem = null;
}

function openLabelEditor(item){
  if(!item) return;
  editingItem = item;
  el('labelInput').value = item.label || "";
  openLabelModal("edit");
}

function applyLabel(applyColor=false, colorValue=null){
  if (!editingItem) return;
  const v = el('labelInput').value.trim();
  if (!v) return;

  pushHistory();
  editingItem.label = v;
  if(applyColor && colorValue) editingItem.color = colorValue;

  closeLabelModal();
  draw();
  scheduleAutoSave();
}

/* ===== wall helpers ===== */
function distPointToSegment(px, py, x1, y1, x2, y2){
  const vx = x2 - x1, vy = y2 - y1;
  const wx = px - x1, wy = py - y1;
  const c1 = vx*wx + vy*wy;
  if (c1 <= 0) return Math.hypot(px - x1, py - y1);
  const c2 = vx*vx + vy*vy;
  if (c2 <= c1) return Math.hypot(px - x2, py - y2);
  const t = c1 / c2;
  const bx = x1 + t*vx;
  const by = y1 + t*vy;
  return Math.hypot(px - bx, py - by);
}
function wallHitTest(worldP, wall){
  const handleRWorld = WALL_HANDLE_R / scale;
  const padWorld = WALL_HIT_PAD / scale;

  const d1 = Math.hypot(worldP.x - wall.x1, worldP.y - wall.y1);
  if(d1 <= handleRWorld) return {hit:true, handle:"p1"};

  const d2 = Math.hypot(worldP.x - wall.x2, worldP.y - wall.y2);
  if(d2 <= handleRWorld) return {hit:true, handle:"p2"};

  const dSeg = distPointToSegment(worldP.x, worldP.y, wall.x1, wall.y1, wall.x2, wall.y2);
  const thickWorld = (wall.thick || WALL_DEFAULT_THICK) / scale;
  if(dSeg <= (thickWorld/2 + padWorld)) return {hit:true, handle:null};

  return {hit:false, handle:null};
}
function applyRightAngleSnap(wall, movingHandle){
  const ax = (movingHandle === "p1") ? wall.x2 : wall.x1;
  const ay = (movingHandle === "p1") ? wall.y2 : wall.y1;
  const bx = (movingHandle === "p1") ? wall.x1 : wall.x2;
  const by = (movingHandle === "p1") ? wall.y1 : wall.y2;

  const dx = bx - ax;
  const dy = by - ay;
  const adx = Math.abs(dx), ady = Math.abs(dy);
  if(adx < 1e-6 && ady < 1e-6) return;

  const tan = Math.tan(SNAP_ANGLE_DEG * Math.PI/180);

  if(ady <= adx * tan){
    if(movingHandle === "p1") wall.y1 = wall.y2;
    else wall.y2 = wall.y1;
    return;
  }
  if(adx <= ady * tan){
    if(movingHandle === "p1") wall.x1 = wall.x2;
    else wall.x2 = wall.x1;
  }
}

/* ===== measure helpers ===== */
function isMeasureOn(){
  return !!el("measureMode")?.checked;
}
function snapPoint(worldP){
  const snap = getSnapStep();
  return { x: getSnapped(worldP.x, snap), y: getSnapped(worldP.y, snap) };
}
function measureDistance(){
  if(!measureA || !measureB) return null;
  const dWorld = Math.hypot(measureB.x - measureA.x, measureB.y - measureA.y); // world px
  const masuLen = dWorld / GRID_SIZE;
  const meters = masuLen * MASU_SIDE_M;
  return { dWorld, masuLen, meters };
}

/* ===== draw ===== */
function drawGrid(){
  ctx.strokeStyle = "#e5e5ea";
  ctx.lineWidth = 0.5 / scale;
  const range = 1600;
  for (let x = -range; x <= range; x += GRID_SIZE) {
    ctx.beginPath(); ctx.moveTo(x, -range); ctx.lineTo(x, range); ctx.stroke();
  }
  for (let y = -range; y <= range; y += GRID_SIZE) {
    ctx.beginPath(); ctx.moveTo(-range, y); ctx.lineTo(range, y); ctx.stroke();
  }
}
function drawRectItems(){
  items.forEach(item => {
    if(item.type === 'wallLine') return;
    ctx.fillStyle = item.color;
    ctx.globalAlpha = item.type==='room' ? 0.82 : 1.0;
    ctx.fillRect(item.x, item.y, item.w, item.h);
    ctx.globalAlpha = 1.0;

    ctx.strokeStyle = item.type === 'frame' ? "#cfcfd6" : "#333";
    ctx.lineWidth = 1 / scale;
    ctx.strokeRect(item.x, item.y, item.w, item.h);

    if(item.locked){
      ctx.fillStyle = "rgba(0,0,0,0.08)";
      ctx.fillRect(item.x, item.y, item.w, item.h);
    }

    ctx.fillStyle = "#111";
    ctx.font = `bold ${13/scale}px sans-serif`;
    const label = item.locked ? `${item.label} ğŸ”’` : item.label;
    ctx.fillText(label, item.x + 6/scale, item.y + 18/scale);
  });
}
function drawWallLine(wall){
  const thick = wall.thick || WALL_DEFAULT_THICK;
  ctx.save();
  ctx.lineCap = "round";
  ctx.strokeStyle = wall.color || "#616161";
  ctx.lineWidth = thick / scale;
  ctx.beginPath();
  ctx.moveTo(wall.x1, wall.y1);
  ctx.lineTo(wall.x2, wall.y2);
  ctx.stroke();

  const mx = (wall.x1 + wall.x2)/2;
  const my = (wall.y1 + wall.y2)/2;
  ctx.fillStyle = "#111";
  ctx.font = `bold ${12/scale}px sans-serif`;
  const text = wall.locked ? `${wall.label} ğŸ”’` : wall.label;
  ctx.fillText(text, mx + 8/scale, my - 8/scale);
  ctx.restore();
}
function drawWallSelection(wall){
  ctx.save();
  ctx.lineCap = "round";
  ctx.strokeStyle = "#007AFF";
  ctx.lineWidth = ((wall.thick || WALL_DEFAULT_THICK) + 4) / scale;
  ctx.globalAlpha = 0.25;
  ctx.beginPath();
  ctx.moveTo(wall.x1, wall.y1);
  ctx.lineTo(wall.x2, wall.y2);
  ctx.stroke();
  ctx.globalAlpha = 1;

  if(!wall.locked){
    const r = WALL_HANDLE_R / scale;
    ctx.fillStyle = "#fff";
    ctx.strokeStyle = "#007AFF";
    ctx.lineWidth = 2/scale;
    ctx.beginPath(); ctx.arc(wall.x1, wall.y1, r, 0, Math.PI*2); ctx.fill(); ctx.stroke();
    ctx.beginPath(); ctx.arc(wall.x2, wall.y2, r, 0, Math.PI*2); ctx.fill(); ctx.stroke();
  }
  ctx.restore();
}

function drawMerged(){
  const roomMap = {};
  const frameMap = {};
  const groups = {};
  const sub = 16;

  items.forEach((item, index) => {
    if(item.type === 'wallLine') return;

    if (item.type !== 'frame') {
      if (!groups[item.label]) groups[item.label] = { label: item.label, totalMasu: 0, textX: 0, textY: 0, lastIdx: -1 };
      groups[item.label].totalMasu += (item.w / GRID_SIZE) * (item.h / GRID_SIZE);
      if (index > groups[item.label].lastIdx) {
        groups[item.label].textX = item.x + item.w/2;
        groups[item.label].textY = item.y + item.h/2;
        groups[item.label].lastIdx = index;
      }
    }

    for (let x = item.x; x < item.x + item.w; x += sub) {
      for (let y = item.y; y < item.y + item.h; y += sub) {
        const pos = `${x},${y}`;
        if (item.type === 'frame') frameMap[pos] = item.label;
        else roomMap[pos] = { label: item.label, color: item.color };
      }
    }
  });

  items.forEach(item => {
    if(item.type === 'wallLine') return;
    ctx.fillStyle = item.type === 'frame' ? "#f8f8f8" : item.color;
    ctx.fillRect(item.x, item.y, item.w, item.h);
  });

  const drawEdge = (map, color, width) => {
    ctx.strokeStyle = color;
    ctx.lineWidth = width / scale;
    for (const pos in map) {
      const [x, y] = pos.split(',').map(Number);
      const label = map[pos].label || map[pos];
      [{dx:0, dy:-sub}, {dx:0, dy:sub}, {dx:-sub, dy:0}, {dx:sub, dy:0}].forEach(d => {
        if ((map[`${x+d.dx},${y+d.dy}`]?.label || map[`${x+d.dx},${y+d.dy}`]) !== label) {
          ctx.beginPath();
          if(d.dy!==0){
            ctx.moveTo(x, y+(d.dy>0?sub:0));
            ctx.lineTo(x+sub, y+(d.dy>0?sub:0));
          } else {
            ctx.moveTo(x+(d.dx>0?sub:0), y);
            ctx.lineTo(x+(d.dx>0?sub:0), y+sub);
          }
          ctx.stroke();
        }
      });
    }
  };

  drawEdge(roomMap, "#333", 2);
  drawEdge(frameMap, "#111", 6);

  for (const key in groups) {
    const g = groups[key];
    ctx.fillStyle = "#111";
    ctx.textAlign = "center";
    ctx.font = `bold ${14/scale}px sans-serif`;
    ctx.fillText(g.label, g.textX, g.textY - 4/scale);

    let subText = "";
    if (el('showJou').checked) subText += `${(g.totalMasu/2).toFixed(1)}ç•³ `;
    if (el('showTsubo').checked) subText += `${(g.totalMasu/4).toFixed(2)}åª`;

    ctx.font = `${11/scale}px sans-serif`;
    ctx.fillText(subText, g.textX, g.textY + 12/scale);
    ctx.textAlign = "left";
  }

  items.forEach(it => { if(it.type === 'wallLine') drawWallLine(it); });
}

function drawBadge(text, x, y){
  // x,y world coords (top-left)
  ctx.save();
  ctx.font = `bold ${12/scale}px sans-serif`;
  const padX = 8/scale, padY = 6/scale;
  const w = (ctx.measureText(text).width + padX*2);
  const h = (18/scale + padY);
  ctx.fillStyle = "rgba(0,122,255,0.92)";
  ctx.beginPath();
  const r = 10/scale;
  ctx.roundRect(x, y, w, h, r);
  ctx.fill();
  ctx.fillStyle = "#fff";
  ctx.fillText(text, x + padX, y + (14/scale));
  ctx.restore();
}

function drawSelection(){
  if(!selectedItem) return;
  if(isMerged && selectedItem.type === 'frame') return;

  if(selectedItem.type === 'wallLine'){
    drawWallSelection(selectedItem);
    return;
  }

  // rect selection
  ctx.strokeStyle = "#007AFF";
  ctx.lineWidth = 3 / scale;
  ctx.strokeRect(selectedItem.x, selectedItem.y, selectedItem.w, selectedItem.h);

  // â˜… å¤–æ ï¼ˆï¼†å…¨çŸ©å½¢ï¼‰ã‚µã‚¤ã‚ºè¡¨ç¤ºï¼šâ—¯ãƒã‚¹Ã—â—¯ãƒã‚¹
  const wMasu = (selectedItem.w / GRID_SIZE);
  const hMasu = (selectedItem.h / GRID_SIZE);
  const txt = `${wMasu.toFixed(1).replace(".0","")}Ã—${hMasu.toFixed(1).replace(".0","")}ãƒã‚¹`;
  drawBadge(txt, selectedItem.x, selectedItem.y - (26/scale));

  if(!selectedItem.locked){
    ctx.fillStyle = "#fff";
    ctx.strokeStyle = "#007AFF";
    ctx.lineWidth = 2/scale;
    ctx.beginPath();
    ctx.arc(selectedItem.x + selectedItem.w, selectedItem.y + selectedItem.h, 16/scale, 0, Math.PI*2);
    ctx.fill(); ctx.stroke();
  }
}

/* â˜… è·é›¢ã®æç”» */
function drawMeasureOverlay(){
  if(!isMeasureOn()) return;

  // æ“ä½œã‚¬ã‚¤ãƒ‰
  ctx.save();
  ctx.fillStyle = "rgba(0,0,0,0.55)";
  ctx.font = `bold ${12/scale}px sans-serif`;
  const guide = "è·é›¢: 2ç‚¹ã‚¿ãƒƒãƒ—ï¼ˆ3å›ç›®ã§èµ·ç‚¹æ›´æ–°ï¼‰";
  ctx.fillText(guide, (-canvas.width/2 + 14) / scale, (-canvas.height/2 + 22) / scale);
  ctx.restore();

  if(!measureA) return;

  const r = 7/scale;

  // Aç‚¹
  ctx.save();
  ctx.fillStyle = "rgba(255,59,48,0.95)";
  ctx.beginPath();
  ctx.arc(measureA.x, measureA.y, r, 0, Math.PI*2);
  ctx.fill();

  ctx.fillStyle = "#fff";
  ctx.font = `bold ${12/scale}px sans-serif`;
  ctx.fillText("A", measureA.x + (10/scale), measureA.y - (10/scale));
  ctx.restore();

  if(!measureB) return;

  // Bç‚¹ + line
  ctx.save();
  ctx.strokeStyle = "rgba(255,59,48,0.95)";
  ctx.lineWidth = 3/scale;
  ctx.setLineDash([8/scale, 6/scale]);
  ctx.beginPath();
  ctx.moveTo(measureA.x, measureA.y);
  ctx.lineTo(measureB.x, measureB.y);
  ctx.stroke();
  ctx.setLineDash([]);

  ctx.fillStyle = "rgba(255,59,48,0.95)";
  ctx.beginPath();
  ctx.arc(measureB.x, measureB.y, r, 0, Math.PI*2);
  ctx.fill();

  ctx.fillStyle = "#fff";
  ctx.font = `bold ${12/scale}px sans-serif`;
  ctx.fillText("B", measureB.x + (10/scale), measureB.y - (10/scale));

  // distance label
  const d = measureDistance();
  if(d){
    const mx = (measureA.x + measureB.x)/2;
    const my = (measureA.y + measureB.y)/2;
    const mText = `${d.meters.toFixed(2)}m`;
    const masuText = `(${d.masuLen.toFixed(2)}ãƒã‚¹)`;
    drawBadge(`${mText} ${masuText}`, mx, my - (28/scale));
  }
  ctx.restore();
}

window.draw = function(){
  ctx.save();
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  ctx.translate(canvas.width/2 + camera.x, canvas.height/2 + camera.y);
  ctx.scale(scale, scale);

  drawGrid();

  if(isMerged) drawMerged();
  else{
    drawRectItems();
    items.forEach(it => { if(it.type === 'wallLine') drawWallLine(it); });
  }

  drawSelection();
  drawMeasureOverlay();

  ctx.restore();

  updateSummary();
  syncBottomBarState();
  syncHistoryButtons();
};

function fitToFrame(){
  const frames = items.filter(i => i.type === 'frame');
  const targets = frames.length ? frames : items.filter(i => i.type !== 'wallLine');
  if (!targets.length) return;

  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
  targets.forEach(it => {
    if(it.type === "wallLine"){
      minX = Math.min(minX, it.x1, it.x2);
      minY = Math.min(minY, it.y1, it.y2);
      maxX = Math.max(maxX, it.x1, it.x2);
      maxY = Math.max(maxY, it.y1, it.y2);
    }else{
      minX = Math.min(minX, it.x);
      minY = Math.min(minY, it.y);
      maxX = Math.max(maxX, it.x + it.w);
      maxY = Math.max(maxY, it.y + it.h);
    }
  });

  const cx = (minX + maxX)/2;
  const cy = (minY + maxY)/2;
  camera = { x: -cx * scale, y: -cy * scale };
  draw();
}

/* ===== UI wiring ===== */
function init(){
  presets = loadPresets();
  renderPresetChips();

  library = loadLibrary();
  renderLibraryList();
  renderCompare();

  resizeCanvas();
  window.addEventListener('resize', resizeCanvas);

  el('segEdit').onclick = () => setMergedMode(false);
  el('segMerge').onclick = () => setMergedMode(true);

  el('undoBtn').onclick = undo;
  el('redoBtn').onclick = redo;
  syncHistoryButtons();

  const params = new URLSearchParams(window.location.search);
  layoutId = params.get('id') || null;

  if(layoutId){
    getDoc(doc(db, "layouts", layoutId)).then(snap => {
      if(snap.exists()){
        const data = snap.data();
        items = (data.items || []).map(i => ({...i}));
        ensureIds();
        normalizeZ();
        isMerged = !!data.isMerged;
        updateSegmentUI();
        draw();
      }else{
        addRect('å¤–æ ', DEFAULT_FRAME_W, DEFAULT_FRAME_H, '#f8f8f8', 'frame');
        updateSegmentUI();
      }
    });
  }else{
    addRect('å¤–æ ', DEFAULT_FRAME_W, DEFAULT_FRAME_H, '#f8f8f8', 'frame');
    updateSegmentUI();
  }
}

el('openHelpBtn').onclick = () => el('helpModal').style.display = 'flex';
el('helpModal').onclick = () => el('helpModal').style.display = 'none';

el('saveBtn').onclick = async () => {
  if(!layoutId){
    const r = await addDoc(collection(db, "layouts"), { items, isMerged, updatedAt: new Date() });
    layoutId = r.id;
    const newUrl = `${window.location.origin}${window.location.pathname}?id=${layoutId}`;
    history.replaceState(null, "", newUrl);
  }
  await setDoc(doc(db, "layouts", layoutId), { items, isMerged, updatedAt: new Date() }, { merge: true });

  // â˜… æ‰‹å‹•ä¿å­˜æ™‚ã¯ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚‚æ›´æ–°ï¼ˆURLå¿˜ã‚Œé˜²æ­¢ï¼‰
  upsertLibraryEntry(layoutId, {
    name: library.find(x => x.id === layoutId)?.name || "æœªå‘½å",
    updatedAt: Date.now(),
    snapshot: captureSnapshot(),
    stats: calcStats()
  });
  renderLibraryList();

  el('shareUrlInput').value = `${window.location.origin}${window.location.pathname}?id=${layoutId}`;
  el('saveModal').style.display = 'flex';
};

el('copyUrlBtn').onclick = () => {
  navigator.clipboard.writeText(el('shareUrlInput').value);
  alert("ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ");
};
el('closeSaveModalBtn').onclick = () => el('saveModal').style.display = 'none';

el('colorPicker').oninput = (e) => {
  if(!selectedItem) return;
  pushHistory();
  selectedItem.color = e.target.value;
  draw();
  scheduleAutoSave();
};

el('fitBtn').onclick = fitToFrame;
el('centerBtn').onclick = () => { camera = { x: 0, y: 0 }; scale = 1.0; draw(); };

// ãƒã‚§ãƒƒã‚¯å¤‰æ›´ã§å³åæ˜ ï¼ˆshowM2 / measureMode ã‚‚ã“ã“ã§åŠ¹ãï¼‰
document.querySelectorAll('input[type="checkbox"]').forEach(c => c.onchange = () => {
  // è·é›¢ONã«ã—ãŸã‚‰é¸æŠã‚’é‚ªé­”ã—ãªã„ãŸã‚ã€å¿…è¦ãªã‚‰è§£é™¤ï¼ˆå¥½ã¿ï¼‰
  if(c.id === "measureMode" && c.checked){
    // é¸æŠã¯ãã®ã¾ã¾ã§ã‚‚è‰¯ã„ãŒã€è¦‹ã‚„ã™ã•å„ªå…ˆãªã‚‰è§£é™¤
    // selectedItem = null;
  }
  draw();
});

// Label modal OK/CANCELï¼ˆè¿½åŠ ãƒ¢ãƒ¼ãƒ‰åˆ†å²ï¼‰
el('labelCancelBtn').onclick = closeLabelModal;

el('labelOkBtn').onclick = () => {
  const name = el('labelInput').value.trim();
  if(!name) return;

  if(labelModalMode === "add"){
    closeLabelModal();
    addRect(name, 4, 4, addPendingColor || "#FFF3E0", 'room');
    return;
  }
  applyLabel(false, null);
};

el('labelModal').onclick = (e) => { if (e.target.id === 'labelModal') closeLabelModal(); };

el('labelInput').addEventListener('keydown', (e) => {
  if (e.key === 'Enter') el('labelOkBtn').click();
});

// Preset editor
el('openPresetBtn').onclick = () => {
  el('presetModal').style.display = 'flex';
  renderPresetEditorList();
};
el('presetCloseBtn').onclick = () => el('presetModal').style.display = 'none';
el('presetModal').onclick = (e) => { if(e.target.id === 'presetModal') el('presetModal').style.display = 'none'; };
el('presetAddBtn').onclick = () => {
  presets.push({ name: "éƒ¨å±‹", color: "#FFF3E0" });
  renderPresetEditorList();
};
el('presetSaveBtn').onclick = () => {
  presets = presets
    .map(p => ({ name: (p.name||"éƒ¨å±‹").trim().slice(0,12) || "éƒ¨å±‹", color: p.color || "#FFF3E0" }))
    .filter(p => p.name.length > 0);
  savePresets();
  renderPresetChips();
  el('presetModal').style.display = 'none';
};

// Menu modal
el('menuCloseBtn').onclick = closeMenu;
el('menuModal').onclick = (e) => { if (e.target.id === 'menuModal') closeMenu(); };
el('menuEditBtn').onclick = () => { const it = menuItem; closeMenu(); if(it) openLabelEditor(it); };
el('menuDupBtn').onclick  = () => { const it = menuItem; closeMenu(); if(it) duplicateItem(it); };
el('menuDelBtn').onclick  = () => { const it = menuItem; closeMenu(); if(it) deleteItem(it); };
el('menuFrontBtn').onclick= () => { const it = menuItem; closeMenu(); if(it) bringFront(it); };
el('menuBackBtn').onclick = () => { const it = menuItem; closeMenu(); if(it) bringBack(it); };
el('menuLockBtn').onclick = () => { const it = menuItem; closeMenu(); if(it) toggleLock(it); };

// Bottom actions
el('addGenericRoomBtn2').onclick = () => {
  editingItem = null;
  addPendingColor = addPendingColor || "#FFF3E0";
  openLabelModal("add");
};

el('addFrameBtn2').onclick = () => addRect('å¤–æ ', DEFAULT_FRAME_W, DEFAULT_FRAME_H, '#f8f8f8', 'frame');
el('addWallBtn2').onclick = addWallLine;

el('copyBtn2').onclick = () => { if(selectedItem) duplicateItem(selectedItem); };
el('resetBtn2').onclick = () => {
  if(selectedItem) deleteItem(selectedItem);
  else if(confirm("å…¨æ¶ˆå»ã—ã¾ã™ã‹ï¼Ÿ")) {
    pushHistory();
    items = [];
    selectedItem = null;
    addRect('å¤–æ ', DEFAULT_FRAME_W, DEFAULT_FRAME_H, '#f8f8f8', 'frame');
  }
};

/* ===== Library modal wiring ===== */
function openLibrary(){
  library = loadLibrary();
  renderLibraryList();
  renderCompare();
  el("libraryModal").style.display = "flex";
}
function closeLibrary(){
  el("libraryModal").style.display = "none";
}
el("libraryBtn").onclick = openLibrary;
el("libraryCloseBtn").onclick = closeLibrary;
el("libraryCloseX").onclick = closeLibrary;
el("libraryModal").onclick = (e) => { if(e.target.id === "libraryModal") closeLibrary(); };

el("libUpdateBtn").onclick = async () => {
  await updateLibraryFromCurrent();
  alert("ä¸€è¦§ã‚’æ›´æ–°ã—ã¾ã—ãŸ");
};

el("libSaveAsBtn").onclick = async () => {
  if(confirm("ã“ã®æ¡ˆã‚’åˆ¥æ¡ˆã¨ã—ã¦ä¿å­˜ã—ã¾ã™ï¼ˆæ–°URLç™ºè¡Œï¼‰\nã‚ˆã‚ã—ã„ã§ã™ã‹ï¼Ÿ")){
    await saveAsNewLayout();
  }
};

el("libClearCompareBtn").onclick = () => clearCompare();
el("swapCompareBtn").onclick = () => swapCompare();

/* ===== touch handling (longpress vs drag) ===== */
function clearTouchState(){
  if(longPressTimer) clearTimeout(longPressTimer);
  longPressTimer = null;

  pressStart = null;
  pressStartWorld = null;
  pendingItem = null;
  pendingWallHandle = null;
  pendingAction = null;
  dragActive = false;
  rectDragOffset = null;
  wallMoveOffset = null;
  movedDist = 0;
  tapNoHit = false;
}

function startLongPress(item){
  if(longPressTimer) clearTimeout(longPressTimer);
  longPressTimer = setTimeout(() => {
    if(!dragActive && pendingItem === item && !isMeasureOn()){
      openMenu(item);
    }
  }, 450);
}

function getPinchInfo(touches){
  const a = touches[0], b = touches[1];
  const dx = b.clientX - a.clientX;
  const dy = b.clientY - a.clientY;
  const dist = Math.hypot(dx, dy);
  const mid = { x: (a.clientX + b.clientX)/2, y: (a.clientY + b.clientY)/2 };
  return { dist, mid };
}

canvas.addEventListener('touchstart', (e) => {
  if(isAnyModalOpen()) return;

  if(e.touches.length === 2){
    pinchActive = true;
    clearTouchState();
    gestureSnapshot = snapshot();

    const { dist, mid } = getPinchInfo(e.touches);
    pinchStartDist = dist;
    pinchStartScale = scale;
    pinchWorldMid = screenToWorld(mid.x, mid.y);
    return;
  }

  if(e.touches.length !== 1) return;
  const t = e.touches[0];

  const now = Date.now();
  if(!isMeasureOn() && now - lastTapTime < 300 && selectedItem && !isMerged){
    openLabelEditor(selectedItem);
    return;
  }
  lastTapTime = now;

  clearTouchState();
  pressStart = { clientX: t.clientX, clientY: t.clientY };
  pressStartWorld = screenToWorld(t.clientX, t.clientY);

  // è·é›¢ãƒ¢ãƒ¼ãƒ‰ä¸­ã¯ã€Œé¸æŠ/é•·æŠ¼ã—ã€ã‚’é‚ªé­”ã—ãªã„ãŸã‚ã€åŸºæœ¬ã¯ãƒ‘ãƒ³æ‰±ã„
  if(isMeasureOn()){
    pendingAction = "pan";
    tapNoHit = true; // ã‚¿ãƒƒãƒ—ç¢ºå®šæ™‚ã«è·é›¢å‡¦ç†ã¸
    draw();
    return;
  }

  const worldP = pressStartWorld;

  let found = null;
  let wallHandle = null;

  for (let i = items.length-1; i >= 0; i--) {
    if (!isMerged || items[i].type !== 'frame') {
      const it = items[i];

      if(it.type === 'wallLine'){
        const r = wallHitTest(worldP, it);
        if(r.hit){
          found = it; wallHandle = r.handle; break;
        }
      } else {
        if (worldP.x >= it.x && worldP.x <= it.x+it.w && worldP.y >= it.y && worldP.y <= it.y+it.h) {
          found = it; break;
        }
      }
    }
  }

  if(found){
    const wasSelected = (selectedItem === found);
    selectedItem = found;
    pendingItem = found;

    startLongPress(found);

    if(found.locked){
      pendingAction = null;
      draw();
      return;
    }

    if(found.type === 'wallLine'){
      // å£ã‚‚ã€Œæœªé¸æŠâ†’ã¾ãšã¯ç§»å‹•å„ªå…ˆã€ã«å¯„ã›ã‚‹
      pendingWallHandle = wallHandle;
      if(!wasSelected){
        pendingAction = "moveWall";
      }else{
        if(wallHandle === "p1" || wallHandle === "p2") pendingAction = wallHandle;
        else pendingAction = "moveWall";
      }
    }else{
      const nearResize = (Math.abs(worldP.x-(found.x+found.w)) < 30/scale) && (Math.abs(worldP.y-(found.y+found.h)) < 30/scale);
      // â˜…å°ã•ã„æ™‚ã®èª¤ãƒªã‚µã‚¤ã‚ºå¯¾ç­–ï¼šæœªé¸æŠãªã‚‰ç§»å‹•å„ªå…ˆã€é¸æŠæ¸ˆãªã‚‰è§’ã§ãƒªã‚µã‚¤ã‚ºå¯
      pendingAction = (!wasSelected) ? "moveRect" : (nearResize ? "resizeRect" : "moveRect");
    }
    tapNoHit = false;
  }else{
    pendingAction = "pan";
    pendingItem = null;
    tapNoHit = true; // â˜…å¤–ã‚’ã‚¿ãƒƒãƒ—ã—ãŸã‚‰é¸æŠè§£é™¤ã—ãŸã„ï¼ˆtouchendã§ç¢ºå®šï¼‰
  }

  draw();
});

canvas.addEventListener('touchmove', (e) => {
  e.preventDefault();
  if(isAnyModalOpen()) return;

  if(pinchActive && e.touches.length === 2){
    const { dist, mid } = getPinchInfo(e.touches);

    const factor = dist / pinchStartDist;
    scale = clamp(pinchStartScale * factor, 0.5, 3.0);

    const rect = canvas.getBoundingClientRect();
    const cx = canvas.width/2;
    const cy = canvas.height/2;
    const mx = mid.x - rect.left;
    const my = mid.y - rect.top;

    camera.x = mx - cx - (pinchWorldMid.x * scale);
    camera.y = my - cy - (pinchWorldMid.y * scale);

    draw();
    return;
  }

  if(e.touches.length !== 1) return;
  const t = e.touches[0];

  if(!pressStart) return;

  const dx = t.clientX - pressStart.clientX;
  const dy = t.clientY - pressStart.clientY;
  movedDist = Math.hypot(dx, dy);

  const worldP = screenToWorld(t.clientX, t.clientY);
  const snap = getSnapStep();

  if(!dragActive && movedDist >= 6){
    dragActive = true;
    if(longPressTimer) clearTimeout(longPressTimer);
    longPressTimer = null;

    gestureSnapshot = snapshot();

    if(pendingItem){
      items.splice(items.indexOf(pendingItem), 1);
      items.push(pendingItem);
      normalizeZ();
    }

    if(pendingAction === "moveRect" && pendingItem){
      rectDragOffset = { dx: worldP.x - pendingItem.x, dy: worldP.y - pendingItem.y };
    }
    if(pendingAction === "moveWall" && pendingItem){
      wallMoveOffset = { dx: worldP.x - pendingItem.x1, dy: worldP.y - pendingItem.y1 };
    }
  }

  if(dragActive){
    if(pendingAction === "pan"){
      camera.x += dx;
      camera.y += dy;
      pressStart = { clientX: t.clientX, clientY: t.clientY };
      draw();
      return;
    }

    if(pendingItem && !pendingItem.locked){
      if(pendingItem.type === 'wallLine'){
        const w = pendingItem;

        if(pendingAction === "p1"){
          w.x1 = getSnapped(worldP.x, snap);
          w.y1 = getSnapped(worldP.y, snap);
          applyRightAngleSnap(w, "p1");
        } else if(pendingAction === "p2"){
          w.x2 = getSnapped(worldP.x, snap);
          w.y2 = getSnapped(worldP.y, snap);
          applyRightAngleSnap(w, "p2");
        } else if(pendingAction === "moveWall"){
          const vx = w.x2 - w.x1;
          const vy = w.y2 - w.y1;
          const nx1 = getSnapped(worldP.x - (wallMoveOffset?.dx ?? 0), snap);
          const ny1 = getSnapped(worldP.y - (wallMoveOffset?.dy ?? 0), snap);
          w.x1 = nx1; w.y1 = ny1;
          w.x2 = nx1 + vx; w.y2 = ny1 + vy;
        }
      }else{
        const it = pendingItem;
        if(pendingAction === "resizeRect"){
          it.w = Math.max(snap, getSnapped(worldP.x - it.x, snap));
          it.h = Math.max(snap, getSnapped(worldP.y - it.y, snap));
        }else if(pendingAction === "moveRect"){
          it.x = getSnapped(worldP.x - (rectDragOffset?.dx ?? 0), snap);
          it.y = getSnapped(worldP.y - (rectDragOffset?.dy ?? 0), snap);
        }
      }
    }
  }

  draw();
});

function commitGestureIfAny(){
  if(dragActive && gestureSnapshot){
    undoStack.push(gestureSnapshot);
    if (undoStack.length > HISTORY_MAX) undoStack.shift();
    redoStack = [];
    gestureSnapshot = null;
    syncHistoryButtons();
    scheduleAutoSave();
  }else{
    gestureSnapshot = null;
  }
}

function handleTapActions(touch){
  // ã‚¿ãƒƒãƒ—ç¢ºå®šï¼ˆãƒ‰ãƒ©ãƒƒã‚°ã—ã¦ãªã„ï¼‰
  const wp = screenToWorld(touch.clientX, touch.clientY);

  if(isMeasureOn()){
    // â˜…è·é›¢ãƒ¢ãƒ¼ãƒ‰ï¼š2ç‚¹ã‚¿ãƒƒãƒ—ï¼ˆ3å›ç›®ã¯èµ·ç‚¹æ›´æ–°ï¼‰
    const sp = snapPoint(wp);
    pushHistory();
    if(!measureA){
      measureA = sp;
      measureB = null;
    }else if(!measureB){
      measureB = sp;
    }else{
      measureA = sp;
      measureB = null;
    }
    draw();
    scheduleAutoSave();
    return;
  }

  // â˜…å¤–æ å¤–ï¼ˆç©ºç™½ï¼‰ã‚¿ãƒƒãƒ—ã§é¸æŠè§£é™¤ï¼ˆå›³é¢ç¢ºèªç”¨ï¼‰
  if(tapNoHit){
    selectedItem = null;
    draw();
  }
}

canvas.addEventListener('touchend', (e) => {
  if(isAnyModalOpen()) return;

  if(pinchActive){
    if(e.touches.length < 2){
      pinchActive = false;
      commitGestureIfAny();
    }
    clearTouchState();
    draw();
    return;
  }

  if(longPressTimer) clearTimeout(longPressTimer);
  longPressTimer = null;

  // ã‚¿ãƒƒãƒ—åˆ¤å®šï¼ˆãƒ‰ãƒ©ãƒƒã‚°ã—ã¦ãªã„ï¼‰
  const tapped = !dragActive && (movedDist < 6);
  const touch = e.changedTouches?.[0];

  commitGestureIfAny();
  const prevTapNoHit = tapNoHit;
  clearTouchState();

  if(tapped && touch){
    // tapNoHit ã¯ clearTouchState ã§æ¶ˆãˆã‚‹ã®ã§ã€å¿…è¦ãªã‚‰ prevTapNoHit ã‚’ä½¿ã†
    tapNoHit = prevTapNoHit;
    handleTapActions(touch);
    tapNoHit = false;
  }

  draw();
});

canvas.addEventListener('touchcancel', () => {
  pinchActive = false;
  if(longPressTimer) clearTimeout(longPressTimer);
  longPressTimer = null;
  gestureSnapshot = null;
  clearTouchState();
  draw();
});

init();
</script>
</body>
</html>
