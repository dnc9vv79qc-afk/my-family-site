<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<title>é–“å–ã‚Šæ¤œè¨ã‚µã‚¤ãƒˆï¼ˆIchijo) v6.00</title>

<style>
:root{
  --accent:#007AFF;
  --danger:#ff3b30;
  --bg:#f2f2f7;
  --card: rgba(255,255,255,.72);
  --stroke: rgba(60,60,67,.18);
  --text:#111;
  --muted: rgba(60,60,67,.6);
  --shadow: 0 10px 30px rgba(0,0,0,.10);
  --radius2: 26px;
}

@media (prefers-color-scheme: dark){
  :root{
    --bg:#000;
    --card: rgba(28,28,30,.68);
    --stroke: rgba(84,84,88,.55);
    --text:#fff;
    --muted: rgba(235,235,245,.6);
    --shadow: 0 16px 50px rgba(0,0,0,.45);
  }
}

*{ box-sizing: border-box; }

body{
  font-family:
    -apple-system, BlinkMacSystemFont,
    "SF Pro Display", "SF Pro Text",
    "Hiragino Sans", "Hiragino Kaku Gothic ProN",
    "Noto Sans JP",
    "Yu Gothic", "YuGothic",
    "Meiryo",
    sans-serif;
  -webkit-font-smoothing: antialiased;
  text-rendering: optimizeLegibility;

  margin: 0;
  background: var(--bg);
  color: var(--text);
  touch-action: none;
  display: flex;
  flex-direction: column;
  height: 100vh;
  overflow: hidden;
}

.ver-label{
  position: fixed;
  top: 6px;
  right: 10px;
  font-size: 10px;
  color: var(--muted);
  z-index: 100;
  pointer-events: none;
  font-weight: 800;
  text-align: right;
  opacity: .85;
}

/* ===== Top bar ===== */
.toolbar{
  margin: 12px;
  border-radius: var(--radius2);
  background: var(--card);
  border: 1px solid var(--stroke);
  box-shadow: var(--shadow);
  backdrop-filter: blur(16px);
  -webkit-backdrop-filter: blur(16px);

  padding: 10px;
  display:flex;
  align-items:center;
  justify-content: space-between;
  gap: 10px;

  z-index: 10;
}
.top-left, .top-right{ display:flex; align-items:center; gap: 10px; }
.top-title{ font-weight: 900; font-size: 13px; letter-spacing: .3px; opacity: .9; user-select:none; }

button{
  height: 44px;
  font-size: 13px;
  border: none;
  border-radius: 16px;
  color: white;
  font-weight: 900;
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  padding: 0 14px;
  -webkit-tap-highlight-color: transparent;
  letter-spacing: .2px;
  transition: transform .08s ease, filter .08s ease, opacity .08s ease;
}
button:active { opacity: 0.85; transform: scale(0.98); }

.btn-primary{ background: rgba(255,149,0,.95); }
.btn-help{
  background: rgba(120,120,128,.18);
  color: var(--text);
  font-size: 18px;
  width: 44px;
  padding: 0;
}

.color-circle{
  background: rgba(120,120,128,.18);
  border: 1px solid var(--stroke);
  border-radius: 16px;
  width: 44px;
  height: 44px;
  display:flex;
  align-items:center;
  justify-content:center;
  overflow:hidden;
}
input[type="color"]{
  width: 70px;
  height: 70px;
  border: none;
  background: none;
  cursor: pointer;
  padding: 0;
}

/* ===== Config bar ===== */
.config-bar{
  margin: 0 12px 12px;
  border-radius: var(--radius2);
  background: var(--card);
  border: 1px solid var(--stroke);
  box-shadow: var(--shadow);
  backdrop-filter: blur(16px);
  -webkit-backdrop-filter: blur(16px);

  padding: 10px;
  display:flex;
  justify-content: space-between;
  align-items:center;
  gap: 10px;
}

.chip-group { display: flex; gap: 6px; flex-wrap: wrap; }
.chip{
  background: rgba(255,255,255,.55);
  border: 1px solid var(--stroke);
  padding: 8px 12px;
  border-radius: 999px;
  font-size: 13px;
  font-weight: 900;
  display:flex;
  align-items:center;
  gap: 6px;
  box-shadow: 0 1px 6px rgba(0,0,0,.06);
  cursor: pointer;
  color: var(--text);
}
@media (prefers-color-scheme: dark){
  .chip{ background: rgba(44,44,46,.65); }
}
.chip input { margin: 0; width: 18px; height: 18px; }

.right-actions{
  display:flex;
  align-items:center;
  gap: 10px;
  flex-wrap: wrap;
  justify-content: flex-end;
}

.segment{
  display:flex;
  align-items: center;
  border: 1px solid var(--stroke);
  border-radius: 14px;
  background: rgba(120,120,128,.12);
  padding: 2px;
  height: 36px;
}
.seg-btn{
  height: 32px;
  min-width: 56px;
  padding: 0 12px;
  border-radius: 12px;
  background: transparent;
  color: var(--text);
  font-size: 12px;
  font-weight: 900;
  line-height: 1;
  box-shadow:none;
  white-space: nowrap;
}
.seg-btn.active{ background: var(--accent); color: #fff; }
.seg-btn:active{ transform: none; }

.small-btn{
  height: 34px;
  border-radius: 999px;
  padding: 0 12px;
  background: var(--accent);
  color:#fff;
  font-size: 12px;
  font-weight: 900;
}
.small-btn.gray{
  background: rgba(120,120,128,.25);
  color: var(--text);
  border: 1px solid var(--stroke);
}
.small-btn:disabled{ opacity: .4; transform: none !important; cursor: default; }

/* ===== Summary ===== */
.summary{
  margin: 0 12px 12px;
  border-radius: 999px;
  background: var(--card);
  border: 1px solid var(--stroke);
  box-shadow: var(--shadow);
  backdrop-filter: blur(16px);
  -webkit-backdrop-filter: blur(16px);

  padding: 10px 14px;
  display:flex;
  justify-content: space-around;
  align-items:center;

  font-size: 14px;
  font-weight: 900;
}
.summary b{ color: var(--accent); }

/* ===== Canvas ===== */
#canvas-container{
  flex: 1;
  position: relative;
  margin: 0 12px 12px;
  border-radius: 24px;
  overflow: hidden;
  border: 1px solid var(--stroke);
  box-shadow: var(--shadow);
  background: #fff;
  touch-action: none;

  margin-bottom: 96px;
}
canvas{ display:block; }

/* ===== Bottom Bar ===== */
.bottom-bar{
  position: fixed;
  left: 12px; right: 12px;
  bottom: calc(12px + env(safe-area-inset-bottom));
  display: grid;
  grid-template-columns: repeat(5, 1fr);
  gap: 10px;
  padding: 10px;
  border-radius: 24px;
  background: var(--card);
  border: 1px solid var(--stroke);
  box-shadow: var(--shadow);
  backdrop-filter: blur(16px);
  -webkit-backdrop-filter: blur(16px);
  z-index: 60;
}

.pill{
  height: 48px;
  border-radius: 18px;
  background: rgba(120,120,128,.16);
  color: var(--text);
  box-shadow: none;
  font-weight: 900;
  font-size: 13px;
  letter-spacing: .2px;

  display:flex;
  align-items:center;
  justify-content:center;
  flex-direction: column;
  gap: 2px;
  padding: 6px 0;
}
.pill::after{
  content: attr(data-sub);
  font-size: 10px;
  font-weight: 800;
  color: var(--muted);
  letter-spacing: .1px;
}
.pill.primary{ background: var(--accent); color:#fff; }
.pill.primary::after{ color: rgba(255,255,255,.85); }
.pill.danger{
  background: rgba(255,59,48,.14);
  color: #ff3b30;
}
.pill:disabled{
  opacity: .35;
  filter: grayscale(1);
  transform: none !important;
  cursor: default;
}

/* ===== Modals ===== */
.modal-overlay{
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.6);
  z-index: 1000;
  align-items: center;
  justify-content: center;
}
.modal{
  background: #fff;
  padding: 25px;
  border-radius: 20px;
  width: 85%;
  max-width: 360px;
  text-align: center;
  box-shadow: 0 10px 30px rgba(0,0,0,0.3);
}
.modal input{
  width: 100%;
  padding: 12px;
  margin: 15px 0;
  border: 1px solid #ddd;
  border-radius: 10px;
  font-size: 14px;
  box-sizing: border-box;
}
#helpModal .modal{
  max-width: 420px;
  text-align: left;
  max-height: 80vh;
  overflow-y: auto;
}
#helpModal ul{ padding-left: 20px; font-size: 13px; line-height: 1.6; }
#helpModal h3{ text-align: center; margin-top: 0; }

.modal.sheet{ width: 92%; max-width: 420px; text-align: left; border-radius: 22px; }

#labelInput{
  width: 100%;
  padding: 12px 12px;
  border: 1px solid #ddd;
  border-radius: 14px;
  font-size: 16px;
  font-weight: 800;
  outline: none;
}

.chip-grid{
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 8px;
  margin-top: 12px;
}
.name-chip{
  height: 38px;
  border-radius: 14px;
  border: 1px solid var(--stroke);
  background: rgba(120,120,128,.14);
  color: var(--text);
  font-weight: 900;
  font-size: 13px;
  letter-spacing: .2px;
  padding: 0 8px;
  width: 100%;
  justify-content: center;
  box-shadow: none;
  gap: 8px;
  display:flex;
}
.name-chip .dot{
  width: 12px;
  height: 12px;
  border-radius: 999px;
  border: 1px solid rgba(0,0,0,.08);
}
.name-chip:active{ transform: scale(.98); opacity: .9; }

.menu-list{
  display:flex;
  flex-direction: column;
  gap: 10px;
  margin-top: 14px;
}
.menu-btn{
  height: 42px;
  border-radius: 16px;
  border: 1px solid var(--stroke);
  background: rgba(120,120,128,.14);
  color: var(--text);
  font-weight: 900;
  justify-content: center;
}
.menu-btn.danger{
  background: rgba(255,59,48,.14);
  color: #ff3b30;
}

/* ===== Preset manager (A+B+D) ===== */
.preset-list{ display:flex; flex-direction:column; gap:10px; margin-top: 10px; }
.preset-row{
  display:grid;
  grid-template-columns: 1fr 54px 54px;
  gap: 8px;
  align-items:center;
}
.preset-row input[type="text"]{
  margin: 0;
  padding: 10px 10px;
  border-radius: 14px;
  border: 1px solid #ddd;
  font-weight: 800;
}
.preset-row input[type="color"]{
  width: 54px;
  height: 42px;
  border-radius: 14px;
  padding: 0;
  border: 1px solid var(--stroke);
  background: transparent;
}
.preset-del{
  height: 42px;
  border-radius: 14px;
  background: rgba(255,59,48,.14);
  color:#ff3b30;
  border: 1px solid rgba(255,59,48,.25);
  font-weight: 900;
}

/* A: preset modal = flex column, list scroll, footer sticky */
#presetModal .modal.sheet{
  max-height: calc(86vh - env(safe-area-inset-bottom));
  display: flex;
  flex-direction: column;
}
#presetList{
  overflow: auto;
  -webkit-overflow-scrolling: touch;
  flex: 1;
  padding-right: 4px;
}
.preset-footer{
  position: sticky;
  bottom: 0;
  padding-top: 10px;
  background: inherit;
}

/* B: search input */
#presetSearch{
  width: 100%;
  padding: 10px 12px;
  border-radius: 14px;
  border: 1px solid #ddd;
  font-weight: 800;
  outline: none;
}

/* ===== Layout list (ä¿å­˜ä¸€è¦§: æ¯”è¼ƒç”¨) ===== */
.layout-list{
  overflow:auto;
  -webkit-overflow-scrolling: touch;
  flex: 1;
  padding-right: 4px;
  margin-top: 10px;
}
.layout-row{
  display: grid;
  grid-template-columns: 1fr 74px 74px 44px;
  gap: 8px;
  align-items: center;
  margin-bottom: 10px;
}
.layout-row input[type="text"]{
  margin: 0;
  padding: 10px 10px;
  border-radius: 14px;
  border: 1px solid #ddd;
  font-weight: 800;
}
.layout-btn{
  height: 42px;
  border-radius: 14px;
  border: 1px solid var(--stroke);
  background: rgba(120,120,128,.14);
  color: var(--text);
  font-weight: 900;
  justify-content: center;
}
.layout-del{
  height: 42px;
  border-radius: 14px;
  background: rgba(255,59,48,.14);
  color:#ff3b30;
  border: 1px solid rgba(255,59,48,.25);
  font-weight: 900;
  padding: 0;
}
</style>
</head>

<body>
<div class="ver-label">ver 1.11<br>by yuchiğŸ”</div>

<div class="toolbar">
  <div class="top-left">
    <button class="btn-help" id="openHelpBtn" aria-label="ãƒ˜ãƒ«ãƒ—">ï¼Ÿ</button>
    <div class="top-title">é–“å–ã‚Šæ¤œè¨ã‚µã‚¤ãƒˆ</div>
  </div>
  <div class="top-right">
    <button class="btn-primary" id="saveBtn">å…±æœ‰URL</button>
    <div class="color-circle" title="é¸æŠä¸­ãƒ‘ãƒ¼ãƒ„ã®è‰²">
      <input type="color" id="colorPicker" value="#ffffff" />
    </div>
  </div>
</div>

<div class="config-bar">
  <div class="chip-group">
    <label class="chip"><input type="checkbox" id="showJou" checked />ç•³</label>
    <label class="chip"><input type="checkbox" id="showTsubo" checked />åª</label>
    <label class="chip"><input type="checkbox" id="showM2" checked />mÂ²</label>
    <label class="chip" style="background:rgba(120,120,128,.20);"><input type="checkbox" id="useHalfGrid" />åŠã¾ã™</label>
  </div>

  <div class="right-actions">
    <div class="segment" role="tablist" aria-label="è¡¨ç¤ºãƒ¢ãƒ¼ãƒ‰">
      <button class="seg-btn active" id="segEdit" type="button">ç·¨é›†</button>
      <button class="seg-btn" id="segMerge" type="button">çµåˆ</button>
    </div>

    <button id="undoBtn" class="small-btn gray" type="button">æˆ»ã‚‹</button>
    <button id="redoBtn" class="small-btn gray" type="button">é€²ã‚€</button>

    <button id="fitBtn" class="small-btn" type="button">å¤–æ ã«ãƒ•ã‚£ãƒƒãƒˆ</button>
    <button id="centerBtn" class="small-btn" type="button">è¡¨ç¤ºãƒªã‚»ãƒƒãƒˆ</button>
  </div>
</div>

<div class="summary">
  <span>å»¶åºŠ: <b id="totalTsubo">0.00</b> åª</span>
  <span><b id="totalJou">0.0</b> ç•³</span>
  <span id="m2Wrap"><b id="totalM2">0.0</b> mÂ²</span>
</div>

<div id="canvas-container"><canvas id="canvas"></canvas></div>

<div class="bottom-bar" id="bottomBar">
  <button class="pill" id="addFrameBtn2" data-sub="æ ã‚’è¿½åŠ ">å¤–æ </button>
  <button class="pill primary" id="addGenericRoomBtn2" data-sub="ãƒ—ãƒªã‚»ãƒƒãƒˆé¸æŠ">éƒ¨å±‹</button>
  <button class="pill" id="addWallBtn2" data-sub="ç·šåˆ†å£ã‚’è¿½åŠ ">å£</button>
  <button class="pill" id="copyBtn2" data-sub="é¸æŠã‚’è¤‡è£½">è¤‡è£½</button>
  <button class="pill danger" id="resetBtn2" data-sub="é¸æŠ/å…¨æ¶ˆå»">å‰Šé™¤</button>
</div>

<!-- Save Modal -->
<div id="saveModal" class="modal-overlay">
  <div class="modal">
    <h3>å…±æœ‰URL</h3>
    <div style="font-size:12px;color:#666;margin-top:-6px;">ï¼ˆç™ºè¡Œå¾Œã¯è‡ªå‹•ã§ä¸Šæ›¸ãä¿å­˜ã•ã‚Œã¾ã™ï¼‰</div>
    <input type="text" id="shareUrlInput" readonly onclick="this.select()" />
    <div style="display:flex; gap:10px;">
      <button style="flex:1; background:var(--accent);" id="copyUrlBtn">ã‚³ãƒ”ãƒ¼</button>
      <button style="flex:1; background:rgba(120,120,128,.45); color:#fff;" id="closeSaveModalBtn">é–‰ã˜ã‚‹</button>
    </div>

    <div style="display:flex; gap:10px; margin-top:10px;">
      <button style="flex:1; background:rgba(120,120,128,.18); color:#111; border:1px solid rgba(60,60,67,.18);" id="openLayoutsBtn">ä¿å­˜ä¸€è¦§</button>
      <button style="flex:1; background:rgba(120,120,128,.18); color:#111; border:1px solid rgba(60,60,67,.18);" id="saveAsBtn">åˆ¥åã§ä¿å­˜</button>
    </div>
  </div>
</div>

<!-- Layouts Modal (è¤‡æ•°é–“å–ã‚Šã®ä¿å­˜/æ¯”è¼ƒ) -->
<div id="layoutsModal" class="modal-overlay">
  <div class="modal sheet" style="max-height:calc(86vh - env(safe-area-inset-bottom)); display:flex; flex-direction:column;">
    <h3 style="margin:0 0 6px;">ä¿å­˜ä¸€è¦§</h3>
    <div style="font-size:12px;color:#666;margin-bottom:6px;">åå‰ã‚’ç·¨é›†ã§ãã¾ã™ / ã€Œæ–°è¦ã‚¿ãƒ–ã€ã§æ¯”è¼ƒãŒãƒ©ã‚¯</div>

    <div class="layout-list" id="layoutList"></div>

    <div class="preset-footer">
      <div style="display:flex; gap:10px; margin-top:10px;">
        <button class="small-btn gray" id="layoutsCloseBtn" type="button" style="height:42px; flex:1;">é–‰ã˜ã‚‹</button>
      </div>
    </div>
  </div>
</div>

<!-- Help Modal -->
<div id="helpModal" class="modal-overlay">
  <div class="modal">
    <h3>ğŸ  æ“ä½œãƒãƒ‹ãƒ¥ã‚¢ãƒ«</h3>
    <ul>
      <li><b>ç§»å‹•:</b> ãƒ‘ãƒ¼ãƒ„ã®â€œä¸­å¤®ãƒãƒ³ãƒ‰ãƒ«â€ã‚’ãƒ‰ãƒ©ãƒƒã‚°ï¼ˆèª¤ãƒªã‚µã‚¤ã‚ºé˜²æ­¢ï¼‰ã€‚</li>
      <li><b>ã‚µã‚¤ã‚º:</b> å³ä¸‹ã®ä¸¸ã„ãƒãƒ³ãƒ‰ãƒ«ã‚’ãƒ‰ãƒ©ãƒƒã‚°ã€‚</li>
      <li><b>é¸æŠè§£é™¤:</b> ä½•ã‚‚ãªã„æ‰€ã‚’è»½ãã‚¿ãƒƒãƒ—ã€‚</li>
      <li><b>é•·æŠ¼ã—:</b> æŒ‡ã‚’å‹•ã‹ã•ãšæŠ¼ã—ç¶šã‘ã‚‹ã¨ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã€‚</li>
      <li><b>å£(ç·š):</b> ç«¯ç‚¹ãƒ‰ãƒ©ãƒƒã‚°ã§é•·ã•ã€ç·šãƒ‰ãƒ©ãƒƒã‚°ã§ç§»å‹•ã€‚</li>
      <li><b>ãƒ”ãƒ³ãƒ:</b> 2æœ¬æŒ‡ã§ã‚ºãƒ¼ãƒ ï¼†ç§»å‹•ã€‚</li>
      <li><b>åå‰ç·¨é›†:</b> 2å›ã‚¿ãƒƒãƒ—ï¼ˆç·¨é›†ãƒ¢ãƒ¼ãƒ‰ã®ã¿ï¼‰ã€‚</li>
      <li><b>ä¿å­˜:</b> å…±æœ‰URLã‚’ç™ºè¡Œã—ã¦ç¶šãã‚’ç·¨é›†å¯èƒ½ï¼ˆç™ºè¡Œå¾Œã¯è‡ªå‹•ä¸Šæ›¸ãä¿å­˜ï¼‰ã€‚</li>
    </ul>
    <p style="font-size:11px; color:#666; text-align:center;">ï¼ˆç”»é¢ã‚’ã‚¿ãƒƒãƒ—ã—ã¦é–‰ã˜ã‚‹ï¼‰</p>
  </div>
</div>

<!-- Label / Add Modal -->
<div id="labelModal" class="modal-overlay">
  <div class="modal sheet">
    <h3 id="labelModalTitle" style="margin:0 0 6px;">éƒ¨å±‹åã‚’å¤‰æ›´</h3>
    <div id="labelModalSub" style="font-size:12px;color:#666;margin-bottom:10px;">å€™è£œã‚’ã‚¿ãƒƒãƒ—ï¼ˆåå‰ï¼‹è‰²ï¼‰ / å…¥åŠ›ã—ã¦OK</div>

    <input type="text" id="labelInput" placeholder="éƒ¨å±‹å" maxlength="12" />

    <div style="display:flex; gap:10px; margin:12px 0 6px;">
      <button class="small-btn gray" id="openPresetBtn" type="button" style="height:36px;">ãƒ—ãƒªã‚»ãƒƒãƒˆç·¨é›†</button>
      <div id="addHint" style="font-size:12px;color:#666;align-self:center;">â€»ãƒãƒƒãƒ—ã¯å³è¿½åŠ </div>
    </div>

    <div class="chip-grid" id="labelChips"></div>

    <div style="display:flex; gap:10px; margin-top:14px;">
      <button style="flex:1; background:rgba(120,120,128,.45); color:#fff;" id="labelCancelBtn" type="button">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
      <button style="flex:1; background:var(--accent);" id="labelOkBtn" type="button">OK</button>
    </div>
  </div>
</div>

<!-- Context Menu -->
<div id="menuModal" class="modal-overlay">
  <div class="modal sheet">
    <h3 style="margin:0 0 6px;">ãƒ¡ãƒ‹ãƒ¥ãƒ¼</h3>
    <div id="menuTitle" style="font-size:12px;color:#666;margin-bottom:8px;">é¸æŠä¸­</div>

    <div class="menu-list">
      <button class="menu-btn" id="menuEditBtn" type="button">åå‰å¤‰æ›´</button>
      <button class="menu-btn" id="menuDupBtn" type="button">è¤‡è£½</button>
      <button class="menu-btn danger" id="menuDelBtn" type="button">å‰Šé™¤</button>
      <button class="menu-btn" id="menuFrontBtn" type="button">æœ€å‰é¢</button>
      <button class="menu-btn" id="menuBackBtn" type="button">æœ€èƒŒé¢</button>
      <button class="menu-btn" id="menuLockBtn" type="button">ãƒ­ãƒƒã‚¯/è§£é™¤</button>
    </div>

    <div style="display:flex; gap:10px; margin-top:14px;">
      <button style="flex:1; background:rgba(120,120,128,.45); color:#fff;" id="menuCloseBtn" type="button">é–‰ã˜ã‚‹</button>
    </div>
  </div>
</div>

<!-- Preset Manager -->
<div id="presetModal" class="modal-overlay">
  <div class="modal sheet">
    <h3 style="margin:0 0 6px;">ãƒ—ãƒªã‚»ãƒƒãƒˆç·¨é›†</h3>
    <div style="font-size:12px;color:#666;margin-bottom:8px;">éƒ¨å±‹åã¨è‰²ã‚’è¿½åŠ /å¤‰æ›´ã§ãã¾ã™</div>

    <!-- B: search -->
    <input id="presetSearch" type="text" placeholder="æ¤œç´¢ï¼ˆä¾‹ï¼šLDKï¼‰" />

    <div class="preset-list" id="presetList"></div>

    <!-- A: sticky footer -->
    <div class="preset-footer">
      <div style="display:flex; gap:10px; margin-top:12px;">
        <button class="small-btn gray" id="presetAddBtn" type="button" style="height:42px;">ï¼‹è¿½åŠ </button>
        <button class="small-btn" id="presetSaveBtn" type="button" style="height:42px;">ä¿å­˜</button>
      </div>

      <div style="display:flex; gap:10px; margin-top:10px;">
        <button style="flex:1; background:rgba(120,120,128,.45); color:#fff;" id="presetCloseBtn" type="button">é–‰ã˜ã‚‹</button>
      </div>
    </div>
  </div>
</div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
import { getFirestore, collection, addDoc, getDoc, doc, setDoc } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

const firebaseConfig = {
  apiKey: "AIzaSyBH4zoH5ZnfPcZmmXNvfeGOJz9__KkSMrg",
  authDomain: "test-55430.firebaseapp.com",
  projectId: "test-55430",
  storageBucket: "test-55430.firebasestorage.app",
  messagingSenderId: "742726212885",
  appId: "1:742726212885:web:597a48fc1ce0cb7f529d1c",
  measurementId: "G-PW24JY2LBP"
};

const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

const el = (id) => document.getElementById(id);

const canvas = el('canvas');
const ctx = canvas.getContext('2d');
const container = el('canvas-container');

const GRID_SIZE = 32;
const HISTORY_MAX = 50;

const PRESET_KEY = "floorplan_presets_v1";

/* ä¿å­˜ä¸€è¦§ï¼ˆè¤‡æ•°é–“å–ã‚Šï¼‰ */
const LAYOUTS_KEY = "floorplan_saved_layouts_v1";

const WALL_DEFAULT_THICK = 12;
const WALL_HANDLE_R = 18;      // screen px
const WALL_HIT_PAD = 12;       // screen px
const SNAP_ANGLE_DEG = 15;

const AUTOSAVE_DELAY = 1500;

// â˜… mÂ²æ›ç®—ï¼ˆåªâ†’mÂ²ï¼‰
const TSUBO_TO_M2 = 3.305785;

/* â˜…ç§»å‹•ãƒãƒ³ãƒ‰ãƒ« */
const MOVE_HANDLE_R = 14;      // screen px
const MOVE_HANDLE_HIT = 22;    // screen px

/* å°éƒ¨å±‹åˆ¤å®šï¼ˆãƒã‚¹æ•°ï¼‰ */
const SMALL_ROOM_MAX_MASU = 4;

let items = [];
let selectedItem = null;

let isMerged = false;

let camera = { x: 0, y: 0 };   // screen px
let scale = 1.0;               // zoom

let lastTapTime = 0;

let layoutId = null;

let editingItem = null;
let menuItem = null;

// â˜…è¿½åŠ /ç·¨é›†ãƒ¢ãƒ¼ãƒ‰
let labelModalMode = "edit";  // "edit" | "add"
let addPendingColor = "#FFF3E0"; // å…¥åŠ›è¿½åŠ æ™‚ã®è‰²ï¼ˆç›´å‰é¸æŠã‚’ä¿æŒï¼‰

// Undo/Redo
let undoStack = [];
let redoStack = [];
let gestureSnapshot = null;

// Auto-save
let autosaveTimer = null;

// Presets
let presets = [];
let presetSearchQuery = "";

// Touch states
let longPressTimer = null;
let pressStart = null;           // {clientX, clientY}
let pressStartWorld = null;      // {x,y}
let pendingItem = null;          // hit item (rect or wallLine)
let pendingWallHandle = null;    // "p1"|"p2"|null
let pendingAction = null;        // "moveRect"|"resizeRect"|"moveWall"|"p1"|"p2"|"pan"|null
let dragActive = false;
let rectDragOffset = null;       // {dx,dy} in world for rect move
let wallMoveOffset = null;       // {dx,dy} in world for wall move
let emptyTapCandidate = false;   // â˜…ä½•ã‚‚ãªã„æ‰€ã‚¿ãƒƒãƒ—ã§é¸æŠè§£é™¤

// Pinch
let pinchActive = false;
let pinchStartDist = 0;
let pinchStartScale = 1;
let pinchWorldMid = null;

function uid(){
  return Math.random().toString(36).slice(2, 10) + Date.now().toString(36).slice(-4);
}

function ensureIds(){
  items.forEach(it => {
    if(!it.id) it.id = uid();
    if(typeof it.locked !== "boolean") it.locked = false;
    if(it.type === 'wallLine'){
      if(typeof it.thick !== "number") it.thick = WALL_DEFAULT_THICK;
      if(!it.color) it.color = "#616161";
      if(!it.label) it.label = "å£";
    }
  });
}

function normalizeZ(){
  const frames = items.filter(i => i.type === 'frame');
  const others = items.filter(i => i.type !== 'frame');
  items = [...frames, ...others];
}

function getSnapStep(){
  return el('useHalfGrid').checked ? 16 : 32;
}
function getSnapped(val, step){
  return Math.round(val / step) * step;
}
function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

/* ===== coordinate ===== */
function screenToWorld(screenX, screenY){
  const rect = canvas.getBoundingClientRect();
  const cx = canvas.width/2;
  const cy = canvas.height/2;
  const x = (screenX - rect.left - cx - camera.x) / scale;
  const y = (screenY - rect.top  - cy - camera.y) / scale;
  return {x,y};
}

/* ===== autosave ===== */
async function saveLayoutToFirestore(){
  if(!layoutId) return;
  try{
    await setDoc(doc(db, "layouts", layoutId), { items, isMerged, updatedAt: new Date() }, { merge: true });
  }catch(e){
    console.warn("save failed", e);
  }
}

function scheduleAutoSave(){
  if(!layoutId) return;
  if(autosaveTimer) clearTimeout(autosaveTimer);
  autosaveTimer = setTimeout(async () => {
    await saveLayoutToFirestore();
    touchLayoutMeta(layoutId); // ä¿å­˜ä¸€è¦§ã®updatedæ›´æ–°
  }, AUTOSAVE_DELAY);
}

/* ===== history ===== */
function snapshot(){
  ensureIds();
  return {
    items: items.map(i => ({...i})),
    selectedId: selectedItem?.id || null,
    isMerged,
    camera: {...camera},
    scale,
    layoutId
  };
}

function restore(s){
  items = (s.items || []).map(i => ({...i}));
  ensureIds();
  normalizeZ();
  isMerged = !!s.isMerged;
  camera = s.camera ? {...s.camera} : {x:0,y:0};
  scale = typeof s.scale === "number" ? s.scale : 1.0;
  layoutId = s.layoutId ?? layoutId;
  selectedItem = s.selectedId ? items.find(i => i.id === s.selectedId) || null : null;
  updateSegmentUI();
  draw();
}

function pushHistory(){
  undoStack.push(snapshot());
  if (undoStack.length > HISTORY_MAX) undoStack.shift();
  redoStack = [];
  syncHistoryButtons();
}

function undo(){
  if (!undoStack.length) return;
  redoStack.push(snapshot());
  restore(undoStack.pop());
  syncHistoryButtons();
  scheduleAutoSave();
}

function redo(){
  if (!redoStack.length) return;
  undoStack.push(snapshot());
  restore(redoStack.pop());
  syncHistoryButtons();
  scheduleAutoSave();
}

function syncHistoryButtons(){
  el('undoBtn').disabled = undoStack.length === 0;
  el('redoBtn').disabled = redoStack.length === 0;
}

/* ===== presets ===== */
function defaultPresets(){
  return [
    { name: "LDK", color: "#FFF3E0" },
    { name: "æ´‹å®¤", color: "#E3F2FD" },
    { name: "å¯å®¤", color: "#E8F5E9" },
    { name: "åœŸé–“", color: "#ECEFF1" },
    { name: "åç´", color: "#F3E5F5" },
    { name: "æ´—é¢", color: "#E0F7FA" },
    { name: "ãƒˆã‚¤ãƒ¬", color: "#FFFDE7" },
    { name: "ç„é–¢", color: "#FBE9E7" },
  ];
}
function loadPresets(){
  try{
    const raw = localStorage.getItem(PRESET_KEY);
    if(raw){
      const arr = JSON.parse(raw);
      if(Array.isArray(arr) && arr.length){
        return arr.map(p => ({
          name: String(p.name||"").trim() || "éƒ¨å±‹",
          color: String(p.color||"#FFF3E0")
        }));
      }
    }
  }catch(_){}
  return defaultPresets();
}
function savePresets(){
  localStorage.setItem(PRESET_KEY, JSON.stringify(presets));
}
function escapeHtml(s){
  return String(s).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'}[m]));
}

function onPresetPicked(name, color){
  // â˜…è¿½åŠ ãƒ¢ãƒ¼ãƒ‰ï¼šãƒãƒƒãƒ—ã¯å³è¿½åŠ 
  if(labelModalMode === "add"){
    addPendingColor = color || "#FFF3E0";
    closeLabelModal();
    addRect(name, 4, 4, addPendingColor, 'room');
    return;
  }
  // ç·¨é›†ãƒ¢ãƒ¼ãƒ‰ï¼šåå‰ï¼‹è‰²ã‚’é©ç”¨
  el('labelInput').value = name;
  applyLabel(true, color);
}

function renderPresetChips(){
  const box = el('labelChips');
  box.innerHTML = "";
  presets.forEach(p => {
    const b = document.createElement("button");
    b.type = "button";
    b.className = "name-chip";
    b.innerHTML = `<span class="dot" style="background:${p.color}"></span><span>${escapeHtml(p.name)}</span>`;
    b.addEventListener("click", () => onPresetPicked(p.name, p.color));
    box.appendChild(b);
  });
}

/* A+B: editor list = scroll + search filter */
function renderPresetEditorList(){
  const list = el('presetList');
  list.innerHTML = "";

  const q = (presetSearchQuery || "").toLowerCase();
  const visible = presets
    .map((p, idx) => ({...p, idx}))
    .filter(p => !q || (p.name || "").toLowerCase().includes(q));

  visible.forEach(({name, color, idx}) => {
    const row = document.createElement("div");
    row.className = "preset-row";
    row.innerHTML = `
      <input type="text" value="${escapeHtml(name)}" maxlength="12" data-idx="${idx}" data-k="name">
      <input type="color" value="${color}" data-idx="${idx}" data-k="color">
      <button class="preset-del" type="button" data-idx="${idx}">å‰Šé™¤</button>
    `;
    list.appendChild(row);
  });

  list.querySelectorAll('input').forEach(inp => {
    inp.addEventListener('input', () => {
      const i = Number(inp.dataset.idx);
      const k = inp.dataset.k;
      if(!presets[i]) return;
      if(k === 'name') presets[i].name = (inp.value || "").trim().slice(0,12) || "éƒ¨å±‹";
      if(k === 'color') presets[i].color = inp.value || "#FFF3E0";
    });
  });

  list.querySelectorAll('.preset-del').forEach(btn => {
    btn.addEventListener('click', () => {
      const i = Number(btn.dataset.idx);
      presets.splice(i, 1);
      renderPresetEditorList();
    });
  });
}

/* D: focus row into view (keyboard-safe) */
el('presetList').addEventListener('focusin', (e) => {
  const row = e.target.closest?.('.preset-row');
  if(row) row.scrollIntoView({ block: 'center', behavior: 'smooth' });
});

/* ===== layouts list (ä¿å­˜/æ¯”è¼ƒ) ===== */
function loadLayouts(){
  try{
    const raw = localStorage.getItem(LAYOUTS_KEY);
    const arr = raw ? JSON.parse(raw) : [];
    if(Array.isArray(arr)) return arr;
  }catch(_){}
  return [];
}
function saveLayouts(arr){
  localStorage.setItem(LAYOUTS_KEY, JSON.stringify(arr));
}
function formatDate(ts){
  try{
    const d = new Date(ts);
    return d.toLocaleString('ja-JP', { month:'2-digit', day:'2-digit', hour:'2-digit', minute:'2-digit' });
  }catch(_){ return ""; }
}
function upsertLayoutMeta(id, patch){
  const list = loadLayouts();
  const idx = list.findIndex(x => x.id === id);
  if(idx >= 0){
    list[idx] = { ...list[idx], ...patch };
  }else{
    list.unshift({ id, title: patch.title || `é–“å–ã‚Š ${new Date().toLocaleString('ja-JP')}`, updatedAt: patch.updatedAt || Date.now() });
  }
  saveLayouts(list);
}
function touchLayoutMeta(id){
  if(!id) return;
  upsertLayoutMeta(id, { updatedAt: Date.now() });
}
function renderLayoutList(){
  const box = el('layoutList');
  box.innerHTML = "";
  const list = loadLayouts();

  if(!list.length){
    box.innerHTML = `<div style="font-size:13px;color:#666;">ã¾ã ä¿å­˜ãŒã‚ã‚Šã¾ã›ã‚“ï¼ˆå…±æœ‰URLç™ºè¡Œã§è‡ªå‹•ç™»éŒ²ï¼‰</div>`;
    return;
  }

  list.forEach((it) => {
    const row = document.createElement('div');
    row.className = 'layout-row';
    row.innerHTML = `
      <input type="text" value="${escapeHtml(it.title || "")}" maxlength="24" data-id="${it.id}">
      <button class="layout-btn" type="button" data-act="open" data-id="${it.id}">é–‹ã</button>
      <button class="layout-btn" type="button" data-act="newtab" data-id="${it.id}">æ–°è¦ã‚¿ãƒ–</button>
      <button class="layout-del" type="button" data-act="del" data-id="${it.id}">Ã—</button>
      <div style="grid-column:1 / -1; font-size:12px; color:#666; margin-top:-4px;">æœ€çµ‚: ${formatDate(it.updatedAt || Date.now())} / id: ${it.id}</div>
    `;
    box.appendChild(row);
  });

  box.querySelectorAll('input[type="text"]').forEach(inp => {
    inp.addEventListener('input', () => {
      const id = inp.dataset.id;
      upsertLayoutMeta(id, { title: (inp.value||"").trim().slice(0,24) || "é–“å–ã‚Š" });
      // UIæ›´æ–°ã¯é‡ããªã„ã‘ã©ã€å…¥åŠ›ä¸­ã¯ãã®ã¾ã¾ã«ã™ã‚‹
    });
  });

  box.querySelectorAll('button').forEach(btn => {
    const act = btn.dataset.act;
    const id = btn.dataset.id;
    if(!act || !id) return;

    btn.addEventListener('click', () => {
      if(act === 'open'){
        const url = `${window.location.origin}${window.location.pathname}?id=${id}`;
        window.location.href = url;
      }
      if(act === 'newtab'){
        const url = `${window.location.origin}${window.location.pathname}?id=${id}`;
        window.open(url, "_blank");
      }
      if(act === 'del'){
        const list = loadLayouts().filter(x => x.id !== id);
        saveLayouts(list);
        renderLayoutList();
      }
    });
  });
}

/* ===== UI helpers ===== */
function resizeCanvas(){
  canvas.width = container.clientWidth;
  canvas.height = container.clientHeight;
  draw();
}
function updateSegmentUI(){
  el('segEdit').classList.toggle('active', !isMerged);
  el('segMerge').classList.toggle('active', isMerged);
}
function setMergedMode(val){
  isMerged = val;
  updateSegmentUI();
  draw();
}

/* â˜… mÂ²è¡¨ç¤ºON/OFFå¯¾å¿œã®ã‚µãƒãƒªãƒ¼ */
function updateSummary(){
  let tm = 0;
  items.forEach(i => { if(i.type === 'frame') tm += (i.w/GRID_SIZE)*(i.h/GRID_SIZE); });

  const tsubo = tm/4;
  const jou = tm/2;
  const m2 = tsubo * TSUBO_TO_M2;

  el('totalTsubo').innerText = tsubo.toFixed(2);
  el('totalJou').innerText = jou.toFixed(1);
  el('totalM2').innerText = m2.toFixed(1);

  const showM2 = el('showM2')?.checked ?? true;
  const wrap = el('m2Wrap');
  if(wrap) wrap.style.display = showM2 ? "" : "none";
}

function syncBottomBarState(){
  el('copyBtn2').disabled = !selectedItem;
}

/* ===== add items ===== */
function addRect(label, w, h, color, type='room'){
  pushHistory();
  const targetX = getSnapped((-camera.x)/scale, GRID_SIZE);
  const targetY = getSnapped((-camera.y)/scale, GRID_SIZE);
  const i = { id: uid(), locked:false, type, x: targetX, y: targetY, w: w*GRID_SIZE, h: h*GRID_SIZE, label, color };
  if(type === 'frame') items.unshift(i); else items.push(i);
  ensureIds();
  normalizeZ();
  selectedItem = i;
  draw();
  scheduleAutoSave();
}
function addWallLine(){
  pushHistory();
  const targetX = getSnapped((-camera.x)/scale, GRID_SIZE);
  const targetY = getSnapped((-camera.y)/scale, GRID_SIZE);
  const len = 4 * GRID_SIZE;
  const wall = {
    id: uid(),
    locked:false,
    type: 'wallLine',
    label: 'å£',
    color: '#616161',
    thick: WALL_DEFAULT_THICK,
    x1: targetX,
    y1: targetY,
    x2: targetX + len,
    y2: targetY
  };
  items.push(wall);
  ensureIds();
  normalizeZ();
  selectedItem = wall;
  draw();
  scheduleAutoSave();
}

/* ===== menu actions ===== */
function openMenu(item){
  if(!item) return;
  menuItem = item;
  const lockedText = item.locked ? "ï¼ˆãƒ­ãƒƒã‚¯ï¼‰" : "";
  el('menuTitle').innerText = `${item.label || "ï¼ˆç„¡åï¼‰"} / ${item.type}${lockedText}`;
  el('menuModal').style.display = 'flex';
}
function closeMenu(){
  el('menuModal').style.display = 'none';
  menuItem = null;
}
function duplicateItem(it){
  if(!it) return;
  pushHistory();
  let n;
  if(it.type === 'wallLine'){
    n = { ...it, id: uid(), x1: it.x1 + GRID_SIZE, y1: it.y1 + GRID_SIZE, x2: it.x2 + GRID_SIZE, y2: it.y2 + GRID_SIZE };
  }else{
    n = { ...it, id: uid(), x: it.x + GRID_SIZE, y: it.y + GRID_SIZE };
  }
  items.push(n);
  normalizeZ();
  selectedItem = n;
  draw();
  scheduleAutoSave();
}
function deleteItem(it){
  if(!it) return;
  pushHistory();
  items = items.filter(x => x !== it);
  selectedItem = null;
  normalizeZ();
  draw();
  scheduleAutoSave();
}
function bringFront(it){
  if(!it) return;
  pushHistory();
  items = items.filter(x => x !== it);
  items.push(it);
  normalizeZ();
  draw();
  scheduleAutoSave();
}
function bringBack(it){
  if(!it) return;
  pushHistory();
  const frames = items.filter(i => i.type === 'frame');
  const others = items.filter(i => i.type !== 'frame' && i !== it);
  items = [...frames, it, ...others];
  normalizeZ();
  draw();
  scheduleAutoSave();
}
function toggleLock(it){
  if(!it) return;
  pushHistory();
  it.locked = !it.locked;
  draw();
  scheduleAutoSave();
}

/* ===== label modal (edit/add) ===== */
function openLabelModal(mode){
  labelModalMode = mode; // "add" or "edit"
  el('labelModal').style.display = 'flex';

  if(mode === "add"){
    el('labelModalTitle').innerText = "éƒ¨å±‹ã‚’è¿½åŠ ";
    el('labelModalSub').innerText = "ãƒ—ãƒªã‚»ãƒƒãƒˆã‚’ã‚¿ãƒƒãƒ—ã§å³è¿½åŠ  / å…¥åŠ›ã—ã¦OKã§ã‚‚è¿½åŠ ";
    el('addHint').style.display = "block";
    el('labelInput').placeholder = "éƒ¨å±‹åï¼ˆå…¥åŠ›è¿½åŠ ï¼‰";
    el('labelInput').value = "";
  }else{
    el('labelModalTitle').innerText = "éƒ¨å±‹åã‚’å¤‰æ›´";
    el('labelModalSub').innerText = "å€™è£œã‚’ã‚¿ãƒƒãƒ—ï¼ˆåå‰ï¼‹è‰²ï¼‰ / å…¥åŠ›ã—ã¦OK";
    el('addHint').style.display = "none";
    el('labelInput').placeholder = "éƒ¨å±‹å";
  }

  setTimeout(() => el('labelInput').focus(), 50);
}

function closeLabelModal(){
  el('labelModal').style.display = 'none';
  labelModalMode = "edit";
  editingItem = null;
}

function openLabelEditor(item){
  if(!item) return;
  editingItem = item;
  el('labelInput').value = item.label || "";
  openLabelModal("edit");
}

function applyLabel(applyColor=false, colorValue=null){
  if (!editingItem) return;
  const v = el('labelInput').value.trim();
  if (!v) return;

  pushHistory();
  editingItem.label = v;
  if(applyColor && colorValue) editingItem.color = colorValue;

  closeLabelModal();
  draw();
  scheduleAutoSave();
}

/* ===== wall helpers ===== */
function distPointToSegment(px, py, x1, y1, x2, y2){
  const vx = x2 - x1, vy = y2 - y1;
  const wx = px - x1, wy = py - y1;
  const c1 = vx*wx + vy*wy;
  if (c1 <= 0) return Math.hypot(px - x1, py - y1);
  const c2 = vx*vx + vy*vy;
  if (c2 <= c1) return Math.hypot(px - x2, py - y2);
  const t = c1 / c2;
  const bx = x1 + t*vx;
  const by = y1 + t*vy;
  return Math.hypot(px - bx, py - by);
}
function wallHitTest(worldP, wall){
  const handleRWorld = WALL_HANDLE_R / scale;
  const padWorld = WALL_HIT_PAD / scale;

  const d1 = Math.hypot(worldP.x - wall.x1, worldP.y - wall.y1);
  if(d1 <= handleRWorld) return {hit:true, handle:"p1"};

  const d2 = Math.hypot(worldP.x - wall.x2, worldP.y - wall.y2);
  if(d2 <= handleRWorld) return {hit:true, handle:"p2"};

  const dSeg = distPointToSegment(worldP.x, worldP.y, wall.x1, wall.y1, wall.x2, wall.y2);
  const thickWorld = (wall.thick || WALL_DEFAULT_THICK) / scale;
  if(dSeg <= (thickWorld/2 + padWorld)) return {hit:true, handle:null};

  return {hit:false, handle:null};
}
function applyRightAngleSnap(wall, movingHandle){
  const ax = (movingHandle === "p1") ? wall.x2 : wall.x1;
  const ay = (movingHandle === "p1") ? wall.y2 : wall.y1;
  const bx = (movingHandle === "p1") ? wall.x1 : wall.x2;
  const by = (movingHandle === "p1") ? wall.y1 : wall.y2;

  const dx = bx - ax;
  const dy = by - ay;
  const adx = Math.abs(dx), ady = Math.abs(dy);
  if(adx < 1e-6 && ady < 1e-6) return;

  const tan = Math.tan(SNAP_ANGLE_DEG * Math.PI/180);

  if(ady <= adx * tan){
    if(movingHandle === "p1") wall.y1 = wall.y2;
    else wall.y2 = wall.y1;
    return;
  }
  if(adx <= ady * tan){
    if(movingHandle === "p1") wall.x1 = wall.x2;
    else wall.x2 = wall.x1;
  }
}

/* ===== rect helpers ===== */
function isSmallRoom(it){
  if(!it || it.type !== 'room') return false;
  const masu = (it.w/GRID_SIZE) * (it.h/GRID_SIZE);
  return masu <= SMALL_ROOM_MAX_MASU;
}
function rectMoveHandleCenter(it){
  return { x: it.x + it.w/2, y: it.y + it.h/2 };
}
function rectMoveHandleHit(worldP, it){
  const c = rectMoveHandleCenter(it);
  const r = MOVE_HANDLE_HIT / scale;
  return Math.hypot(worldP.x - c.x, worldP.y - c.y) <= r;
}

/* ===== draw ===== */
function drawGrid(){
  ctx.strokeStyle = "#e5e5ea";
  ctx.lineWidth = 0.5 / scale;
  const range = 1600;
  for (let x = -range; x <= range; x += GRID_SIZE) {
    ctx.beginPath(); ctx.moveTo(x, -range); ctx.lineTo(x, range); ctx.stroke();
  }
  for (let y = -range; y <= range; y += GRID_SIZE) {
    ctx.beginPath(); ctx.moveTo(-range, y); ctx.lineTo(range, y); ctx.stroke();
  }
}

/* â˜…é‡ãªã‚Šå¯¾ç­–ï¼šfillâ†’strokeâ†’label ã‚’åˆ†ã‘ã‚‹ï¼ˆä¸‹ã®éƒ¨å±‹ã‚‚è¼ªéƒ­ãŒè¦‹ãˆã‚‹ï¼‰ */
function drawRectItems(){
  const rects = items.filter(i => i.type !== 'wallLine');

  // 1) fill
  rects.forEach(item => {
    ctx.fillStyle = item.color;
    ctx.globalAlpha = item.type==='room' ? 0.82 : 1.0;
    ctx.fillRect(item.x, item.y, item.w, item.h);
    ctx.globalAlpha = 1.0;

    if(item.locked){
      ctx.fillStyle = "rgba(0,0,0,0.08)";
      ctx.fillRect(item.x, item.y, item.w, item.h);
    }
  });

  // 2) stroke (small rooms double border)
  rects.forEach(item => {
    const isFrame = item.type === 'frame';
    const baseStroke = isFrame ? "#cfcfd6" : "#333";

    if(isSmallRoom(item)){
      // outer white halo
      ctx.strokeStyle = "rgba(255,255,255,0.95)";
      ctx.lineWidth = 4 / scale;
      ctx.strokeRect(item.x, item.y, item.w, item.h);
      // inner dark
      ctx.strokeStyle = baseStroke;
      ctx.lineWidth = 2 / scale;
      ctx.strokeRect(item.x, item.y, item.w, item.h);
    }else{
      ctx.strokeStyle = baseStroke;
      ctx.lineWidth = 1 / scale;
      ctx.strokeRect(item.x, item.y, item.w, item.h);
    }
  });

  // 3) label (white stroke text)
  rects.forEach(item => {
    const label = item.locked ? `${item.label} ğŸ”’` : (item.label || "");
    if(!label) return;

    const x = item.x + 6/scale;
    const y = item.y + 18/scale;

    ctx.font = `900 ${13/scale}px sans-serif`;

    // â˜…ç™½ãƒ•ãƒ
    ctx.lineJoin = "round";
    ctx.lineWidth = 4/scale;
    ctx.strokeStyle = "rgba(255,255,255,0.95)";
    ctx.strokeText(label, x, y);

    ctx.fillStyle = "#111";
    ctx.fillText(label, x, y);
  });
}

function drawWallLine(wall){
  const thick = wall.thick || WALL_DEFAULT_THICK;
  ctx.save();
  ctx.lineCap = "round";
  ctx.strokeStyle = wall.color || "#616161";
  ctx.lineWidth = thick / scale;
  ctx.beginPath();
  ctx.moveTo(wall.x1, wall.y1);
  ctx.lineTo(wall.x2, wall.y2);
  ctx.stroke();

  const mx = (wall.x1 + wall.x2)/2;
  const my = (wall.y1 + wall.y2)/2;
  ctx.fillStyle = "#111";
  ctx.font = `bold ${12/scale}px sans-serif`;

  const text = wall.locked ? `${wall.label} ğŸ”’` : wall.label;

  // å£ãƒ©ãƒ™ãƒ«ã‚‚ç™½ãƒ•ãƒ
  ctx.lineJoin = "round";
  ctx.lineWidth = 4/scale;
  ctx.strokeStyle = "rgba(255,255,255,0.95)";
  ctx.strokeText(text, mx + 8/scale, my - 8/scale);
  ctx.fillText(text, mx + 8/scale, my - 8/scale);

  ctx.restore();
}

function drawWallSelection(wall){
  ctx.save();
  ctx.lineCap = "round";
  ctx.strokeStyle = "#007AFF";
  ctx.lineWidth = ((wall.thick || WALL_DEFAULT_THICK) + 4) / scale;
  ctx.globalAlpha = 0.25;
  ctx.beginPath();
  ctx.moveTo(wall.x1, wall.y1);
  ctx.lineTo(wall.x2, wall.y2);
  ctx.stroke();
  ctx.globalAlpha = 1;

  if(!wall.locked){
    const r = WALL_HANDLE_R / scale;
    ctx.fillStyle = "#fff";
    ctx.strokeStyle = "#007AFF";
    ctx.lineWidth = 2/scale;
    ctx.beginPath(); ctx.arc(wall.x1, wall.y1, r, 0, Math.PI*2); ctx.fill(); ctx.stroke();
    ctx.beginPath(); ctx.arc(wall.x2, wall.y2, r, 0, Math.PI*2); ctx.fill(); ctx.stroke();
  }
  ctx.restore();
}

/* â˜…ç§»å‹•ãƒãƒ³ãƒ‰ãƒ«æç”» */
function drawMoveHandleRect(it){
  const c = rectMoveHandleCenter(it);
  const r = MOVE_HANDLE_R / scale;

  ctx.save();
  ctx.fillStyle = "#fff";
  ctx.strokeStyle = "#007AFF";
  ctx.lineWidth = 2/scale;

  ctx.beginPath(); ctx.arc(c.x, c.y, r, 0, Math.PI*2); ctx.fill(); ctx.stroke();

  // cross
  ctx.beginPath();
  ctx.moveTo(c.x - r*0.55, c.y);
  ctx.lineTo(c.x + r*0.55, c.y);
  ctx.moveTo(c.x, c.y - r*0.55);
  ctx.lineTo(c.x, c.y + r*0.55);
  ctx.stroke();

  ctx.restore();
}

function drawSizeBadge(it){
  const mw = (it.w / GRID_SIZE).toFixed(1).replace('.0','');
  const mh = (it.h / GRID_SIZE).toFixed(1).replace('.0','');
  const text = (it.type === 'frame') ? `å¤–æ : ${mw}Ã—${mh}ãƒã‚¹` : `${mw}Ã—${mh}ãƒã‚¹`;

  const pad = 8/scale;
  ctx.save();
  ctx.font = `900 ${12/scale}px sans-serif`;
  const w = ctx.measureText(text).width + pad*2;
  const h = 22/scale;

  const x = it.x;
  const y = it.y - (h + 8/scale);

  ctx.fillStyle = "rgba(0,122,255,0.92)";
  ctx.beginPath();
  const rx = 10/scale;
  ctx.roundRect(x, y, w, h, rx);
  ctx.fill();

  ctx.fillStyle = "#fff";
  ctx.fillText(text, x + pad, y + 15/scale);
  ctx.restore();
}

function drawMerged(){
  const roomMap = {};
  const frameMap = {};
  const groups = {};
  const sub = 16;

  items.forEach((item, index) => {
    if(item.type === 'wallLine') return;

    if (item.type !== 'frame') {
      if (!groups[item.label]) groups[item.label] = { label: item.label, totalMasu: 0, textX: 0, textY: 0, lastIdx: -1 };
      groups[item.label].totalMasu += (item.w / GRID_SIZE) * (item.h / GRID_SIZE);
      if (index > groups[item.label].lastIdx) {
        groups[item.label].textX = item.x + item.w/2;
        groups[item.label].textY = item.y + item.h/2;
        groups[item.label].lastIdx = index;
      }
    }

    for (let x = item.x; x < item.x + item.w; x += sub) {
      for (let y = item.y; y < item.y + item.h; y += sub) {
        const pos = `${x},${y}`;
        if (item.type === 'frame') frameMap[pos] = item.label;
        else roomMap[pos] = { label: item.label, color: item.color };
      }
    }
  });

  items.forEach(item => {
    if(item.type === 'wallLine') return;
    ctx.fillStyle = item.type === 'frame' ? "#f8f8f8" : item.color;
    ctx.fillRect(item.x, item.y, item.w, item.h);
  });

  const drawEdge = (map, color, width) => {
    ctx.strokeStyle = color;
    ctx.lineWidth = width / scale;
    for (const pos in map) {
      const [x, y] = pos.split(',').map(Number);
      const label = map[pos].label || map[pos];
      [{dx:0, dy:-sub}, {dx:0, dy:sub}, {dx:-sub, dy:0}, {dx:sub, dy:0}].forEach(d => {
        if ((map[`${x+d.dx},${y+d.dy}`]?.label || map[`${x+d.dx},${y+d.dy}`]) !== label) {
          ctx.beginPath();
          if(d.dy!==0){
            ctx.moveTo(x, y+(d.dy>0?sub:0));
            ctx.lineTo(x+sub, y+(d.dy>0?sub:0));
          } else {
            ctx.moveTo(x+(d.dx>0?sub:0), y);
            ctx.lineTo(x+(d.dx>0?sub:0), y+sub);
          }
          ctx.stroke();
        }
      });
    }
  };

  drawEdge(roomMap, "#333", 2);
  drawEdge(frameMap, "#111", 6);

  for (const key in groups) {
    const g = groups[key];
    ctx.fillStyle = "#111";
    ctx.textAlign = "center";
    ctx.font = `bold ${14/scale}px sans-serif`;

    // ç™½ãƒ•ãƒ
    ctx.lineJoin="round";
    ctx.lineWidth=4/scale;
    ctx.strokeStyle="rgba(255,255,255,0.95)";
    ctx.strokeText(g.label, g.textX, g.textY - 4/scale);
    ctx.fillText(g.label, g.textX, g.textY - 4/scale);

    let subText = "";
    if (el('showJou').checked) subText += `${(g.totalMasu/2).toFixed(1)}ç•³ `;
    if (el('showTsubo').checked) subText += `${(g.totalMasu/4).toFixed(2)}åª`;

    ctx.font = `${11/scale}px sans-serif`;
    ctx.lineWidth=4/scale;
    ctx.strokeText(subText, g.textX, g.textY + 12/scale);
    ctx.fillText(subText, g.textX, g.textY + 12/scale);
    ctx.textAlign = "left";
  }

  items.forEach(it => { if(it.type === 'wallLine') drawWallLine(it); });
}

window.draw = function(){
  ctx.save();
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  ctx.translate(canvas.width/2 + camera.x, canvas.height/2 + camera.y);
  ctx.scale(scale, scale);

  drawGrid();

  if(isMerged) drawMerged();
  else{
    drawRectItems();
    items.forEach(it => { if(it.type === 'wallLine') drawWallLine(it); });
  }

  if(selectedItem && !(isMerged && selectedItem.type === 'frame')){
    if(selectedItem.type === 'wallLine'){
      drawWallSelection(selectedItem);
    }else{
      ctx.strokeStyle = "#007AFF";
      ctx.lineWidth = 3 / scale;
      ctx.strokeRect(selectedItem.x, selectedItem.y, selectedItem.w, selectedItem.h);

      // â˜…ç§»å‹•ãƒãƒ³ãƒ‰ãƒ«
      if(!selectedItem.locked){
        drawMoveHandleRect(selectedItem);

        // resize handle
        ctx.fillStyle = "#fff";
        ctx.strokeStyle = "#007AFF";
        ctx.lineWidth = 2/scale;
        ctx.beginPath();
        ctx.arc(selectedItem.x + selectedItem.w, selectedItem.y + selectedItem.h, 16/scale, 0, Math.PI*2);
        ctx.fill(); ctx.stroke();
      }

      // â˜…å¤–æ ã‚µã‚¤ã‚ºãŒã‚ã‹ã‚‹ï¼ˆãƒ‰ãƒ©ãƒƒã‚°ä¸­/ãƒªã‚µã‚¤ã‚ºä¸­ï¼‰
      if(dragActive && pendingItem === selectedItem){
        drawSizeBadge(selectedItem);
      }
    }
  }else if(selectedItem && selectedItem.type === 'frame' && isMerged){
    // çµåˆä¸­ã¯ãƒ•ãƒ¬ãƒ¼ãƒ é¸æŠæç”»ã—ãªã„ä»•æ§˜ã ãŒã€ãƒ‰ãƒ©ãƒƒã‚°ä¸­ã¯ã‚µã‚¤ã‚ºãƒãƒƒã‚¸ã ã‘å‡ºã™
    if(dragActive && pendingItem === selectedItem){
      drawSizeBadge(selectedItem);
    }
  }

  ctx.restore();

  updateSummary();
  syncBottomBarState();
  syncHistoryButtons();
};

function fitToFrame(){
  const frames = items.filter(i => i.type === 'frame');
  const targets = frames.length ? frames : items.filter(i => i.type !== 'wallLine');
  if (!targets.length) return;

  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
  targets.forEach(it => {
    if(it.type === 'wallLine') return;
    minX = Math.min(minX, it.x);
    minY = Math.min(minY, it.y);
    maxX = Math.max(maxX, it.x + it.w);
    maxY = Math.max(maxY, it.y + it.h);
  });

  const cx = (minX + maxX)/2;
  const cy = (minY + maxY)/2;
  camera = { x: -cx * scale, y: -cy * scale };
  draw();
}

/* ===== UI wiring ===== */
function init(){
  presets = loadPresets();
  renderPresetChips();

  resizeCanvas();
  window.addEventListener('resize', resizeCanvas);

  el('segEdit').onclick = () => setMergedMode(false);
  el('segMerge').onclick = () => setMergedMode(true);

  el('undoBtn').onclick = undo;
  el('redoBtn').onclick = redo;
  syncHistoryButtons();

  const params = new URLSearchParams(window.location.search);
  layoutId = params.get('id') || null;

  if(layoutId){
    getDoc(doc(db, "layouts", layoutId)).then(snap => {
      if(snap.exists()){
        const data = snap.data();
        items = (data.items || []).map(i => ({...i}));
        ensureIds();
        normalizeZ();
        isMerged = !!data.isMerged;
        updateSegmentUI();
        draw();
        upsertLayoutMeta(layoutId, { updatedAt: Date.now() });
      }else{
        addRect('å¤–æ ', 2, 2, '#f8f8f8', 'frame'); // â˜…åˆæœŸå¤–æ : 2Ã—2
        updateSegmentUI();
      }
    });
  }else{
    addRect('å¤–æ ', 2, 2, '#f8f8f8', 'frame'); // â˜…åˆæœŸå¤–æ : 2Ã—2
    updateSegmentUI();
  }
}

el('openHelpBtn').onclick = () => el('helpModal').style.display = 'flex';
el('helpModal').onclick = () => el('helpModal').style.display = 'none';

el('saveBtn').onclick = async () => {
  if(!layoutId){
    const r = await addDoc(collection(db, "layouts"), { items, isMerged, updatedAt: new Date() });
    layoutId = r.id;
    const newUrl = `${window.location.origin}${window.location.pathname}?id=${layoutId}`;
    history.replaceState(null, "", newUrl);
    upsertLayoutMeta(layoutId, { title: `é–“å–ã‚Š ${new Date().toLocaleString('ja-JP')}`, updatedAt: Date.now() });
  }
  await saveLayoutToFirestore();
  touchLayoutMeta(layoutId);

  el('shareUrlInput').value = `${window.location.origin}${window.location.pathname}?id=${layoutId}`;
  el('saveModal').style.display = 'flex';
};

el('saveAsBtn').onclick = async () => {
  // åˆ¥åã§ä¿å­˜ï¼ˆæ–°ã—ã„IDã‚’ä½œã£ã¦è¤‡æ•°é–“å–ã‚Šã‚’æŒã¦ã‚‹ï¼‰
  const r = await addDoc(collection(db, "layouts"), { items, isMerged, updatedAt: new Date() });
  layoutId = r.id;
  const newUrl = `${window.location.origin}${window.location.pathname}?id=${layoutId}`;
  history.replaceState(null, "", newUrl);
  upsertLayoutMeta(layoutId, { title: `é–“å–ã‚Š ${new Date().toLocaleString('ja-JP')}`, updatedAt: Date.now() });

  el('shareUrlInput').value = newUrl;
  alert("åˆ¥åã§ä¿å­˜ã—ã¾ã—ãŸï¼ˆæ–°ã—ã„URLã«ãªã‚Šã¾ã—ãŸï¼‰");
};

el('openLayoutsBtn').onclick = () => {
  renderLayoutList();
  el('layoutsModal').style.display = 'flex';
};
el('layoutsCloseBtn').onclick = () => el('layoutsModal').style.display = 'none';
el('layoutsModal').onclick = (e) => { if(e.target.id === 'layoutsModal') el('layoutsModal').style.display = 'none'; };

el('copyUrlBtn').onclick = () => {
  navigator.clipboard.writeText(el('shareUrlInput').value);
  alert("ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ");
};
el('closeSaveModalBtn').onclick = () => el('saveModal').style.display = 'none';

el('colorPicker').oninput = (e) => {
  if(!selectedItem) return;
  pushHistory();
  selectedItem.color = e.target.value;
  draw();
  scheduleAutoSave();
};

el('fitBtn').onclick = fitToFrame;
el('centerBtn').onclick = () => { camera = { x: 0, y: 0 }; scale = 1.0; draw(); };

// â˜…ãƒã‚§ãƒƒã‚¯å¤‰æ›´ã§å³åæ˜ ï¼ˆshowM2ã‚‚ã“ã“ã§åŠ¹ãï¼‰
document.querySelectorAll('input[type="checkbox"]').forEach(c => c.onchange = draw);

// Label modal OK/CANCELï¼ˆâ˜…è¿½åŠ ãƒ¢ãƒ¼ãƒ‰åˆ†å²ï¼‰
el('labelCancelBtn').onclick = closeLabelModal;

el('labelOkBtn').onclick = () => {
  const name = el('labelInput').value.trim();
  if(!name) return;

  if(labelModalMode === "add"){
    closeLabelModal();
    addRect(name, 4, 4, addPendingColor || "#FFF3E0", 'room');
    return;
  }
  applyLabel(false, null);
};

el('labelModal').onclick = (e) => { if (e.target.id === 'labelModal') closeLabelModal(); };

el('labelInput').addEventListener('keydown', (e) => {
  if (e.key === 'Enter') el('labelOkBtn').click();
});

// Preset editor (A+B+D)
el('openPresetBtn').onclick = () => {
  el('presetModal').style.display = 'flex';
  presetSearchQuery = "";
  el('presetSearch').value = "";
  renderPresetEditorList();
};
el('presetSearch').addEventListener('input', (e) => {
  presetSearchQuery = (e.target.value || "").trim();
  renderPresetEditorList();
});
el('presetCloseBtn').onclick = () => el('presetModal').style.display = 'none';
el('presetModal').onclick = (e) => { if(e.target.id === 'presetModal') el('presetModal').style.display = 'none'; };
el('presetAddBtn').onclick = () => {
  presets.push({ name: "éƒ¨å±‹", color: "#FFF3E0" });
  renderPresetEditorList();
};
el('presetSaveBtn').onclick = () => {
  presets = presets
    .map(p => ({ name: (p.name||"éƒ¨å±‹").trim().slice(0,12) || "éƒ¨å±‹", color: p.color || "#FFF3E0" }))
    .filter(p => p.name.length > 0);
  savePresets();
  renderPresetChips();
  el('presetModal').style.display = 'none';
};

// Menu modal
el('menuCloseBtn').onclick = closeMenu;
el('menuModal').onclick = (e) => { if (e.target.id === 'menuModal') closeMenu(); };
el('menuEditBtn').onclick = () => { const it = menuItem; closeMenu(); if(it) openLabelEditor(it); };
el('menuDupBtn').onclick  = () => { const it = menuItem; closeMenu(); if(it) duplicateItem(it); };
el('menuDelBtn').onclick  = () => { const it = menuItem; closeMenu(); if(it) deleteItem(it); };
el('menuFrontBtn').onclick= () => { const it = menuItem; closeMenu(); if(it) bringFront(it); };
el('menuBackBtn').onclick = () => { const it = menuItem; closeMenu(); if(it) bringBack(it); };
el('menuLockBtn').onclick = () => { const it = menuItem; closeMenu(); if(it) toggleLock(it); };

// Bottom actions
el('addGenericRoomBtn2').onclick = () => {
  editingItem = null;
  addPendingColor = addPendingColor || "#FFF3E0";
  openLabelModal("add");
};

el('addFrameBtn2').onclick = () => addRect('å¤–æ ', 2, 2, '#f8f8f8', 'frame'); // â˜…å¤–æ åˆæœŸ 2Ã—2
el('addWallBtn2').onclick = addWallLine;

el('copyBtn2').onclick = () => { if(selectedItem) duplicateItem(selectedItem); };
el('resetBtn2').onclick = () => {
  if(selectedItem) deleteItem(selectedItem);
  else if(confirm("å…¨æ¶ˆå»ã—ã¾ã™ã‹ï¼Ÿ")) {
    pushHistory();
    items = [];
    selectedItem = null;
    addRect('å¤–æ ', 2, 2, '#f8f8f8', 'frame');
  }
};

/* ===== touch handling (longpress vs drag) ===== */
function clearTouchState(){
  if(longPressTimer) clearTimeout(longPressTimer);
  longPressTimer = null;

  pressStart = null;
  pressStartWorld = null;
  pendingItem = null;
  pendingWallHandle = null;
  pendingAction = null;
  dragActive = false;
  rectDragOffset = null;
  wallMoveOffset = null;
  emptyTapCandidate = false;
}

function startLongPress(item){
  if(longPressTimer) clearTimeout(longPressTimer);
  longPressTimer = setTimeout(() => {
    if(!dragActive && pendingItem === item){
      openMenu(item);
    }
  }, 450);
}

function getPinchInfo(touches){
  const a = touches[0], b = touches[1];
  const dx = b.clientX - a.clientX;
  const dy = b.clientY - a.clientY;
  const dist = Math.hypot(dx, dy);
  const mid = { x: (a.clientX + b.clientX)/2, y: (a.clientY + b.clientY)/2 };
  return { dist, mid };
}

canvas.addEventListener('touchstart', (e) => {
  if(e.touches.length === 2){
    pinchActive = true;
    clearTouchState();
    gestureSnapshot = snapshot();

    const { dist, mid } = getPinchInfo(e.touches);
    pinchStartDist = dist;
    pinchStartScale = scale;
    pinchWorldMid = screenToWorld(mid.x, mid.y);
    return;
  }

  if(e.touches.length !== 1) return;
  const t = e.touches[0];

  const now = Date.now();
  if(now - lastTapTime < 300 && selectedItem && !isMerged){
    openLabelEditor(selectedItem);
    return;
  }
  lastTapTime = now;

  clearTouchState();
  pressStart = { clientX: t.clientX, clientY: t.clientY };
  pressStartWorld = screenToWorld(t.clientX, t.clientY);

  const worldP = pressStartWorld;

  let found = null;
  let wallHandle = null;

  for (let i = items.length-1; i >= 0; i--) {
    if (!isMerged || items[i].type !== 'frame') {
      const it = items[i];

      if(it.type === 'wallLine'){
        const r = wallHitTest(worldP, it);
        if(r.hit){
          found = it; wallHandle = r.handle; break;
        }
      } else {
        if (worldP.x >= it.x && worldP.x <= it.x+it.w && worldP.y >= it.y && worldP.y <= it.y+it.h) {
          found = it; break;
        }
      }
    }
  }

  if(found){
    selectedItem = found;
    pendingItem = found;

    startLongPress(found);

    if(found.locked){
      pendingAction = null;
      draw();
      return;
    }

    if(found.type === 'wallLine'){
      pendingWallHandle = wallHandle;
      if(wallHandle === "p1" || wallHandle === "p2") pendingAction = wallHandle;
      else pendingAction = "moveWall";
    }else{
      // â˜…ç§»å‹•ãƒãƒ³ãƒ‰ãƒ«å„ªå…ˆï¼ˆèª¤ãƒªã‚µã‚¤ã‚ºé˜²æ­¢ï¼‰
      if(rectMoveHandleHit(worldP, found)){
        pendingAction = "moveRect";
      }else{
        // â˜…ãƒªã‚µã‚¤ã‚ºåˆ¤å®šã‚’ã‚„ã‚„å³ã—ãï¼ˆå°ç‰©ã»ã©ï¼‰
        const base = isSmallRoom(found) ? 16 : 22; // screen px
        const nearResize = (Math.abs(worldP.x-(found.x+found.w)) < base/scale) && (Math.abs(worldP.y-(found.y+found.h)) < base/scale);
        pendingAction = nearResize ? "resizeRect" : "moveRect";
      }
    }
  }else{
    // â˜…ä½•ã‚‚ãªã„æ‰€ï¼šã‚¿ãƒƒãƒ—ãªã‚‰é¸æŠè§£é™¤ã€ãƒ‰ãƒ©ãƒƒã‚°ãªã‚‰ãƒ‘ãƒ³
    emptyTapCandidate = true;
    pendingAction = "pan";
    pendingItem = null;
  }

  draw();
});

canvas.addEventListener('touchmove', (e) => {
  e.preventDefault();

  if(pinchActive && e.touches.length === 2){
    const { dist, mid } = getPinchInfo(e.touches);

    const factor = dist / pinchStartDist;
    scale = clamp(pinchStartScale * factor, 0.5, 3.0);

    const rect = canvas.getBoundingClientRect();
    const cx = canvas.width/2;
    const cy = canvas.height/2;
    const mx = mid.x - rect.left;
    const my = mid.y - rect.top;

    camera.x = mx - cx - (pinchWorldMid.x * scale);
    camera.y = my - cy - (pinchWorldMid.y * scale);

    draw();
    return;
  }

  if(e.touches.length !== 1) return;
  const t = e.touches[0];

  if(!pressStart) return;

  const dx = t.clientX - pressStart.clientX;
  const dy = t.clientY - pressStart.clientY;
  const moved = Math.hypot(dx, dy);

  const worldP = screenToWorld(t.clientX, t.clientY);
  const snap = getSnapStep();

  if(!dragActive && moved >= 6){
    dragActive = true;
    emptyTapCandidate = false;

    if(longPressTimer) clearTimeout(longPressTimer);
    longPressTimer = null;

    gestureSnapshot = snapshot();

    if(pendingItem){
      items.splice(items.indexOf(pendingItem), 1);
      items.push(pendingItem);
      normalizeZ();
    }

    if(pendingAction === "moveRect" && pendingItem){
      rectDragOffset = { dx: worldP.x - pendingItem.x, dy: worldP.y - pendingItem.y };
    }
    if(pendingAction === "moveWall" && pendingItem){
      wallMoveOffset = { dx: worldP.x - pendingItem.x1, dy: worldP.y - pendingItem.y1 };
    }
  }

  if(dragActive){
    if(pendingAction === "pan"){
      camera.x += dx;
      camera.y += dy;
      pressStart = { clientX: t.clientX, clientY: t.clientY };
      draw();
      return;
    }

    if(pendingItem && !pendingItem.locked){
      if(pendingItem.type === 'wallLine'){
        const w = pendingItem;

        if(pendingAction === "p1"){
          w.x1 = getSnapped(worldP.x, snap);
          w.y1 = getSnapped(worldP.y, snap);
          applyRightAngleSnap(w, "p1");
        } else if(pendingAction === "p2"){
          w.x2 = getSnapped(worldP.x, snap);
          w.y2 = getSnapped(worldP.y, snap);
          applyRightAngleSnap(w, "p2");
        } else if(pendingAction === "moveWall"){
          const vx = w.x2 - w.x1;
          const vy = w.y2 - w.y1;
          const nx1 = getSnapped(worldP.x - (wallMoveOffset?.dx ?? 0), snap);
          const ny1 = getSnapped(worldP.y - (wallMoveOffset?.dy ?? 0), snap);
          w.x1 = nx1; w.y1 = ny1;
          w.x2 = nx1 + vx; w.y2 = ny1 + vy;
        }
      }else{
        const it = pendingItem;
        if(pendingAction === "resizeRect"){
          it.w = Math.max(snap, getSnapped(worldP.x - it.x, snap));
          it.h = Math.max(snap, getSnapped(worldP.y - it.y, snap));
        }else if(pendingAction === "moveRect"){
          it.x = getSnapped(worldP.x - (rectDragOffset?.dx ?? 0), snap);
          it.y = getSnapped(worldP.y - (rectDragOffset?.dy ?? 0), snap);
        }
      }
    }
  }

  draw();
});

function commitGestureIfAny(){
  if(dragActive && gestureSnapshot){
    undoStack.push(gestureSnapshot);
    if (undoStack.length > HISTORY_MAX) undoStack.shift();
    redoStack = [];
    gestureSnapshot = null;
    syncHistoryButtons();
    scheduleAutoSave();
  }else{
    gestureSnapshot = null;
  }
}

canvas.addEventListener('touchend', (e) => {
  if(pinchActive){
    if(e.touches.length < 2){
      pinchActive = false;
      commitGestureIfAny();
    }
    clearTouchState();
    draw();
    return;
  }

  if(longPressTimer) clearTimeout(longPressTimer);
  longPressTimer = null;

  // â˜…ç©ºã‚¿ãƒƒãƒ—ã§é¸æŠè§£é™¤ï¼ˆãƒ‘ãƒ³ã—ãªã„å ´åˆã®ã¿ï¼‰
  if(emptyTapCandidate && !dragActive){
    selectedItem = null;
  }

  commitGestureIfAny();
  clearTouchState();
  draw();
});

canvas.addEventListener('touchcancel', () => {
  pinchActive = false;
  if(longPressTimer) clearTimeout(longPressTimer);
  longPressTimer = null;
  gestureSnapshot = null;
  clearTouchState();
  draw();
});

init();
</script>
</body>
</html>
